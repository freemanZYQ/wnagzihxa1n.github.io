<!DOCTYPE html>
<html>
<head>
<title>安卓应用签名原理</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="-">安卓应用签名原理</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<h2 id="0x00-">0x00 前言</h2>
<p>签名是安卓应用重要的一个组成部分，本文简单介绍下安卓签名的原理</p>
<h2 id="0x01-">0x01 四种签名方式</h2>
<p>先随便写一个应用作为测试，非常随便</p>
<p><img src="Image/1.png" alt=""></p>
<p>使用Build功能生成一个编译器默认签名的APK，命名为<code>Demo1</code></p>
<pre><code>Build-&gt;Build APK
</code></pre><p>解压缩<code>Demo1</code>，有一个<code>META-INF</code>文件夹，里面有三个文件，这就是签名相关的文件</p>
<pre><code>CERT.RSA
CERT.SF
MANIFEST.MF
</code></pre><p><img src="Image/2.png" alt=""></p>
<p>再使用签名功能给<code>Demo1</code>重签名，重签名后的APK命名为<code>Demo2</code></p>
<pre><code>Build-&gt;Generate Signed APK
</code></pre><p>弹出一个框，需要输入数据</p>
<p><img src="Image/3.png" alt=""></p>
<p>解释一下每一个Item的意思</p>
<pre><code>- Key store path : 签名文件存储的路径
- Key store password : 存储的密码
- Key alias : 别名
- Key password : 秘钥的密码
- Remember passwords : 记住密码
</code></pre><p>可以选择生成一个<code>.jks</code>文件，也可以选择一个已存在的</p>
<p>生成一个，按照说明填</p>
<p><img src="Image/4.png" alt=""></p>
<p>生成后，回到上一层</p>
<p><img src="Image/5.png" alt=""></p>
<p>下一步，红框内有两个勾选的选项，这个<code>V2</code>是在<code>Android 7.0</code>开始引入的校验机制</p>
<p><img src="Image/6.png" alt=""></p>
<p>我们这里暂时不使用<code>V2</code>选项，只勾选<code>V1</code>进行签名</p>
<p>使用<code>keytool + jarsigner</code>来签名，两个工具都在<code>jdk\bin</code>路径下</p>
<p>使用说明</p>
<pre><code>-alias &lt;alias&gt;                  要处理的条目的别名
-keyalg &lt;keyalg&gt;                密钥算法名称
-keysize &lt;keysize&gt;              密钥位大小
-sigalg &lt;sigalg&gt;                签名算法名称
-destalias &lt;destalias&gt;          目标别名
-dname &lt;dname&gt;                  唯一判别名
-startdate &lt;startdate&gt;          证书有效期开始日期/时间
-ext &lt;value&gt;                    X.509 扩展
-validity &lt;valDays&gt;             有效天数
-keypass &lt;arg&gt;                  密钥口令
-keystore &lt;keystore&gt;            密钥库名称
-storepass &lt;arg&gt;                密钥库口令
-storetype &lt;storetype&gt;          密钥库类型
-providername &lt;providername&gt;    提供方名称
-providerclass &lt;providerclass&gt;  提供方类名
-providerarg &lt;arg&gt;              提供方参数
-providerpath &lt;pathlist&gt;        提供方类路径
-v                              详细输出
-protected                      通过受保护的机制的口令
</code></pre><p>生成<code>keystore</code></p>
<pre><code>E:\安卓应用签名原理&gt;keytool -genkey -v -keyalg RSA -keystore Demo.keystore -alias wnagzihxain.keystore -validity 10000
输入密钥库口令:
再次输入新口令:
您的名字与姓氏是什么?
  [Unknown]:  zihxain wnag
您的组织单位名称是什么?
  [Unknown]:  0xLuyu Team
您的组织名称是什么?
  [Unknown]:  0xLuyu Team
您所在的城市或区域名称是什么?
  [Unknown]:  WZ
您所在的省/市/自治区名称是什么?
  [Unknown]:  WZ
该单位的双字母国家/地区代码是什么?
  [Unknown]:  CN
CN=zihxain wnag, OU=0xLuyu Team, O=0xLuyu Team, L=WZ, ST=WZ, C=CN是否正确?
  [否]:  y

正在为以下对象生成 2,048 位RSA密钥对和自签名证书 (SHA256withRSA) (有效期为 10,000 天):
         CN=zihxain wnag, OU=0xLuyu Team, O=0xLuyu Team, L=WZ, ST=WZ, C=CN
输入 &lt;wnagzihxain.keystore&gt; 的密钥口令
        (如果和密钥库口令相同, 按回车):
[正在存储Demo.keystore]
</code></pre><p>查看<code>keystore</code>的信息</p>
<pre><code>E:\&gt;keytool -list -v -keystore Demo.keystore -storepass ******

密钥库类型: JKS
密钥库提供方: SUN

您的密钥库包含 1 个条目

别名: wnagzihxain.keystore
创建日期: 2017-5-7
条目类型: PrivateKeyEntry
证书链长度: 1
证书[1]:
所有者: CN=zihxain wnag, OU=0xLuyu Team, O=0xLuyu Team, L=WZ, ST=WZ, C=CN
发布者: CN=zihxain wnag, OU=0xLuyu Team, O=0xLuyu Team, L=WZ, ST=WZ, C=CN
序列号: 5afa7ea1
有效期开始日期: Sun May 07 23:33:06 CST 2017, 截止日期: Thu Sep 22 23:33:06 CST 2044
证书指纹:
         MD5: C7:F3:21:43:C2:AF:AC:3C:78:E2:60:52:A2:A9:7B:9F
         SHA1: CD:E7:06:96:19:64:E0:B3:CA:9E:DE:37:39:61:20:D5:9E:77:8F:EF
         SHA256: 62:11:21:B4:5F:C6:DC:86:24:4F:58:4C:9C:0E:7C:8D:51:C4:B9:2E:DB:84:A9:D4:8B:26:11:24:AF:53:F2:00
         签名算法名称: SHA256withRSA
         版本: 3

扩展:

#1: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 32 CE CB F2 1A 7B A2 49   63 84 A1 4E 6E 27 93 6B  2......Ic..Nn&#39;.k
0010: 67 CF 41 89                                        g.A.
]
]



*******************************************
*******************************************
</code></pre><p>在前面使用Android Studio签名的时候，生成了一个<code>Demo.jks</code>，同样使用<code>keytool</code>查看</p>
<pre><code>E:\&gt;keytool -list -v -keystore Demo.jks -storepass ******

密钥库类型: JKS
密钥库提供方: SUN

您的密钥库包含 1 个条目

别名: wnagzihxain
创建日期: 2016-8-6
条目类型: PrivateKeyEntry
证书链长度: 1
证书[1]:
所有者: CN=wnagzihxain, C=CN
发布者: CN=wnagzihxain, C=CN
序列号: 1037b03b
有效期开始日期: Sat Aug 06 23:38:41 CST 2016, 截止日期: Wed Jul 31 23:38:41 CST 2041
证书指纹:
         MD5: 01:C2:69:AA:DB:25:FD:44:60:0C:5C:B3:7C:AA:6A:94
         SHA1: FD:BE:50:C4:99:27:BA:A2:27:F2:0E:BC:64:27:B1:18:BD:5C:96:F3
         SHA256: 81:01:B4:D9:C9:0E:8F:4E:30:F2:AC:8C:83:19:AD:07:37:6E:11:4D:C7:C5:F6:7B:D7:0B:2B:87:48:CC:45:D0
         签名算法名称: SHA256withRSA
         版本: 3

扩展:

#1: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 02 DB 43 1B 4A 53 92 E8   E5 48 99 D9 AE 53 53 B0  ..C.JS...H...SS.
0010: 29 06 B9 88                                        )...
]
]



*******************************************
*******************************************
</code></pre><p>再使用该文件给<code>app-debug.apk</code>重签名，要注意的是，得先把<code>app-debug.apk</code>里的<code>META-INF</code>删除</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_72\bin&gt;jarsigner -verbose -keystore Demo.keystore -signedjar E:\Demo3.apk app-debug.apk wnagzihxain.keystore
</code></pre><p>出现一大堆</p>
<pre><code>......
  正在签名: res/layout/notification_template_lines_media.xml
  正在签名: res/layout/notification_template_media.xml
  正在签名: res/layout/notification_template_media_custom.xml
  正在签名: res/layout/notification_template_part_chronometer.xml
  正在签名: res/layout/notification_template_part_time.xml
  正在签名: res/layout/select_dialog_item_material.xml
  正在签名: res/layout/select_dialog_multichoice_material.xml
  正在签名: res/layout/select_dialog_singlechoice_material.xml
  正在签名: res/layout/support_simple_spinner_dropdown_item.xml
  正在签名: res/mipmap-hdpi-v4/ic_launcher.png
  正在签名: res/mipmap-hdpi-v4/ic_launcher_round.png
  正在签名: res/mipmap-mdpi-v4/ic_launcher.png
  正在签名: res/mipmap-mdpi-v4/ic_launcher_round.png
  正在签名: res/mipmap-xhdpi-v4/ic_launcher.png
  正在签名: res/mipmap-xhdpi-v4/ic_launcher_round.png
  正在签名: res/mipmap-xxhdpi-v4/ic_launcher.png
  正在签名: res/mipmap-xxhdpi-v4/ic_launcher_round.png
  正在签名: res/mipmap-xxxhdpi-v4/ic_launcher.png
  正在签名: res/mipmap-xxxhdpi-v4/ic_launcher_round.png
  正在签名: resources.arsc
jar 已签名。
</code></pre><p><code>jarsigner.exe</code>是JDK自带的工具，还有一个签名工具，从名字来看就知道是专门为APK而生的，它就是<code>signapk.jar</code></p>
<p>前者使用的是<code>.keystore</code>，后者需要使用<code>.pk8</code>，<code>x509.pem</code></p>
<p>这两个可以使用默认的，也可以自己生成，生成略微有点麻烦</p>
<p>大概的生成过程就是</p>
<pre><code>Demo.keystore-&gt;.p12-&gt;.rsa.pem
打开.rsa.pem，拷贝如下段，存为.x509.pem
-----BEGIN CERTIFICATE-----
......
-----END CERTIFICATE-----
再生成.pk8
</code></pre><p>这里使用Android Killer默认的签名文件</p>
<pre><code>E:\&gt;java -jar signapk.jar testkey.x509.pem testkey.pk8 app-debug.apk Demo4.apk
</code></pre><h2 id="0x02-">0x02 签名原理</h2>
<p>在上面四种签名过程中，最终都生成了<code>META-INF</code>文件夹，里面有三个文件，虽然不同签名方式文件名不一样</p>
<p>首先是<code>MANIFEST.MF</code></p>
<pre><code>Manifest-Version: 1.0
Built-By: Generated-by-ADT
Created-By: Android Gradle 2.3.1

Name: res/drawable-hdpi-v4/abc_list_longpressed_holo.9.png
SHA-256-Digest: 1cZEsA7nm9Tx/LeJ67+J55wMb+qHjfvEqMZMO+NLWwM=

Name: res/drawable-xxhdpi-v4/abc_ic_star_half_black_16dp.png
SHA-256-Digest: XSYy3/spelJXwJKhqb00BpK8HO9SdNyiy8Shyc0V+c4=

Name: res/drawable-xhdpi-v4/notification_bg_low_pressed.9.png
SHA-256-Digest: IDQyIvn3ndVlw6IkhJTUUucIIKwcQ3Fzw4ut1F+WKv0=

Name: res/drawable-xxxhdpi-v4/abc_btn_switch_to_on_mtrl_00012.9.png
SHA-256-Digest: 3+UAh4D2QnFyzLSc0ML1zNCqo745Ibh1NiyeZaCN92w=

Name: res/color-v23/abc_btn_colored_text_material.xml
SHA-256-Digest: QVTY0LLLS88VfhbxAV7Y2goakoKqmGaZ1crFtTBIP18=

Name: res/drawable/notification_bg_low.xml
SHA-256-Digest: blvD+yxBki5ik7P9etg0bk0ZVC2fMNlnsqvcfoEDYXo=

Name: res/drawable-xhdpi-v4/abc_ic_star_black_48dp.png
SHA-256-Digest: 0QhcZfJCFkxFlZiBNdW1/bCAhtXMptbAENd8hTDMsgQ=
......
</code></pre><p>这个文件存储了所有文件的<code>SHA256</code>散列值经过<code>Base64</code>编码的数据</p>
<p>比如我们拿第一个Item计算一下</p>
<pre><code>Name: res/drawable-hdpi-v4/abc_list_longpressed_holo.9.png
SHA-256-Digest: 1cZEsA7nm9Tx/LeJ67+J55wMb+qHjfvEqMZMO+NLWwM=
</code></pre><p>使用工具得到<code>SHA256</code>的<code>Hex String</code>值</p>
<pre><code>d5c644b00ee79bd4f1fcb789ebbf89e79c0c6fea878dfbc4a8c64c3be34b5b03 *abc_list_longpressed_holo.9.png
</code></pre><p>写一下Java模拟过程，要注意的是，这里<code>SHA256</code>计算出来的是<code>Hex String</code>，需要转为<code>byte[]</code>再计算，所以直接拿去<code>Base64</code>解密是会看到一堆乱码的</p>
<pre><code>import java.lang.reflect.Method;

public class MyClass {

    public static void main(String[] args) throws Exception {
        String encodeString = encodeBase64(hexToBytes(&quot;d5c644b00ee79bd4f1fcb789ebbf89e79c0c6fea878dfbc4a8c64c3be34b5b03&quot;));
        System.out.println(encodeString);
    }

    public static byte[] hexToBytes(String hexString) {  
        char[] hex = hexString.toCharArray();  
        int length = hex.length / 2;  
        byte[] rawData = new byte[length];  
        for (int i = 0; i &lt; length; i++) {  
            int high = Character.digit(hex[i * 2], 16);  
            int low = Character.digit(hex[i * 2 + 1], 16);  
            int value = (high &lt;&lt; 4) | low;  
            if (value &gt; 127) {  
                value -= 256;  
            }   
            rawData[i] = (byte) value;  
        }  
        return rawData;  
    }  

    public static String encodeBase64(byte[]input) throws Exception{  
        Class&lt;?&gt; clazz=Class.forName(&quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64&quot;);  
        Method mainMethod= clazz.getMethod(&quot;encode&quot;, byte[].class);  
        mainMethod.setAccessible(true);  
        Object retObj=mainMethod.invoke(null, new Object[]{input});  
        return (String)retObj;  
    }
}
</code></pre><p>输出</p>
<pre><code>1cZEsA7nm9Tx/LeJ67+J55wMb+qHjfvEqMZMO+NLWwM=
</code></pre><p>跟<code>MANIFEST.MF</code>中是一样的，这里有一点要注意</p>
<p>这里是<code>SHA1</code>还是<code>SHA256</code>需要根据前缀来确定，比如有的是</p>
<pre><code>SHA1-Digest: *********************************
</code></pre><p>这两个散列算法的输出长度是不一样的，前者输出<code>160bit</code>，后者则是<code>256bit</code>，长度不一样，计算结果也不一样，一定要注意这点</p>
<p>然后是<code>CERT.SF</code>文件，这个看起来和<code>MANIFEST.MF</code>一样</p>
<pre><code>Signature-Version: 1.0
SHA-256-Digest-Manifest: /Hxz0liA9+ZerFY/Vl7MeXlUXx3sxC7silsy2SKAB8k=
Created-By: 1.0 (Android)

Name: res/drawable-hdpi-v4/abc_list_longpressed_holo.9.png
SHA-256-Digest: 1cZEsA7nm9Tx/LeJ67+J55wMb+qHjfvEqMZMO+NLWwM=

Name: res/drawable-xxhdpi-v4/abc_ic_star_half_black_16dp.png
SHA-256-Digest: XSYy3/spelJXwJKhqb00BpK8HO9SdNyiy8Shyc0V+c4=

Name: res/drawable-xhdpi-v4/notification_bg_low_pressed.9.png
SHA-256-Digest: IDQyIvn3ndVlw6IkhJTUUucIIKwcQ3Fzw4ut1F+WKv0=

Name: res/drawable-xxxhdpi-v4/abc_btn_switch_to_on_mtrl_00012.9.png
SHA-256-Digest: 3+UAh4D2QnFyzLSc0ML1zNCqo745Ibh1NiyeZaCN92w=

Name: res/color-v23/abc_btn_colored_text_material.xml
SHA-256-Digest: QVTY0LLLS88VfhbxAV7Y2goakoKqmGaZ1crFtTBIP18=
</code></pre><p>首先是最上面那个块，这个值存储的是<code>MANIFEST.MF</code>整个文件的<code>SHA256</code>散列值的<code>Base64</code>编码</p>
<pre><code>SHA-256-Digest-Manifest: /Hxz0liA9+ZerFY/Vl7MeXlUXx3sxC7silsy2SKAB8k=
</code></pre><p>计算出<code>MANIFEST.MF</code>的<code>SHA256</code>散列值</p>
<pre><code>fc7c73d25880f7e65eac563f565ecc7979545f1decc42eec8a5b32d9228007c9 *MANIFEST.MF
</code></pre><p>使用上面的代码计算出结果，对比发现，两者是一样的</p>
<pre><code>/Hxz0liA9+ZerFY/Vl7MeXlUXx3sxC7silsy2SKAB8k=
</code></pre><p>后面的数据就是将每一个Item做<code>SHA256</code>散列，然后<code>Base64</code>编码</p>
<p>最后是<code>CERT.RSA</code>，这个后缀就是所使用的算法，有的是<code>.DSA</code></p>
<p>这个文件要用<code>openssl</code>解开。。。。。。</p>
<p>我就不解了。。。。。。</p>
<p>具体我们在代码里分析，<code>jarsigner.exe</code>我就不分析了。。。。。。</p>
<p>直接分析<code>signapk.jar</code>，这个Java写的比较容易读</p>
<p>网上有一些版本只有一个<code>SignApk.class</code>文件，我这里是1000k的版本</p>
<p><img src="Image/7.png" alt=""></p>
<p>首先是判断参数个数，参数个数不对输出Usage</p>
<pre><code>if (array.length &lt; 4) {
    usage();
}
</code></pre><p>输出Usage</p>
<pre><code>private static void usage() {
    System.err.println(&quot;Usage: signapk [-w] [-providerClass &lt;className&gt;] publickey.x509[.pem] privatekey.pk8 [publickey2.x509[.pem] privatekey2.pk8 ...] input.jar output.jar&quot;);
    System.exit(2);
}
</code></pre><p>然后接下来就是一大堆处理参数以及各种判断，我们关注最终的计算</p>
<pre><code>final JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream);
jarOutputStream.setLevel(9);
final Manifest addDigestsToManifest = addDigestsToManifest(jarFile, n3);
copyFiles(addDigestsToManifest, jarFile, jarOutputStream, n4);
signFile(addDigestsToManifest, jarFile, array2, array3, jarOutputStream);
jarOutputStream.close();
</code></pre><p>跟过去也都是很明显的计算</p>
<p>这里可以对比一下另一个很类似的工具<code>apksigner.jar</code>，路径如下</p>
<pre><code>Android\sdk\build-tools\25.0.1\lib\apksigner.jar
</code></pre><p>使用工具反编译，入口根据参数的不同调用函数，签名是<code>sign</code>，如图红框所示</p>
<p><img src="Image/8.png" alt=""></p>
<p>入口调用</p>
<pre><code>sign(Arrays.&lt;String&gt;copyOfRange(params, 1, params.length));
</code></pre><p>具体实现如下</p>
<pre><code>private static void sign(String[] params) throws Exception {
    if (params.length == 0) {
        printUsage(&quot;help_sign.txt&quot;);
        return;
    }
    File outputApk = null;
    boolean verbose = false;
    boolean v1SigningEnabled = true;
    boolean v2SigningEnabled = true;
    int minSdkVersion = 1;
    boolean minSdkVersionSpecified = false;
    int maxSdkVersion = Integer.MAX_VALUE;
    final List&lt;SignerParams&gt; signers = new ArrayList&lt;SignerParams&gt;(1);
    SignerParams signerParams = new SignerParams();
    final OptionsParser optionsParser = new OptionsParser(params);
    String optionName;
    while ((optionName = optionsParser.nextOption()) != null) {
        final String optionOriginalForm = optionsParser.getOptionOriginalForm();
        if (&quot;help&quot;.equals(optionName) || &quot;h&quot;.equals(optionName)) {
            printUsage(&quot;help_sign.txt&quot;);
            return;
        }
        if (&quot;out&quot;.equals(optionName)) {
            outputApk = new File(optionsParser.getRequiredValue(&quot;Output file name&quot;));
        }
        else if (&quot;min-sdk-version&quot;.equals(optionName)) {
            minSdkVersion = optionsParser.getRequiredIntValue(&quot;Mininimum API Level&quot;);
            minSdkVersionSpecified = true;
        }
        else if (&quot;max-sdk-version&quot;.equals(optionName)) {
            maxSdkVersion = optionsParser.getRequiredIntValue(&quot;Maximum API Level&quot;);
        }
        else if (&quot;v1-signing-enabled&quot;.equals(optionName)) {
            v1SigningEnabled = optionsParser.getOptionalBooleanValue(true);
        }
        else if (&quot;v2-signing-enabled&quot;.equals(optionName)) {
            v2SigningEnabled = optionsParser.getOptionalBooleanValue(true);
        }
        else if (&quot;next-signer&quot;.equals(optionName)) {
            if (signerParams.isEmpty()) {
                continue;
            }
            signers.add(signerParams);
            signerParams = new SignerParams();
        }
        else if (&quot;ks&quot;.equals(optionName)) {
            signerParams.keystoreFile = optionsParser.getRequiredValue(&quot;KeyStore file&quot;);
        }
        else if (&quot;ks-key-alias&quot;.equals(optionName)) {
            signerParams.keystoreKeyAlias = optionsParser.getRequiredValue(&quot;KeyStore key alias&quot;);
        }
        else if (&quot;ks-pass&quot;.equals(optionName)) {
            signerParams.keystorePasswordSpec = optionsParser.getRequiredValue(&quot;KeyStore password&quot;);
        }
        else if (&quot;key-pass&quot;.equals(optionName)) {
            signerParams.keyPasswordSpec = optionsParser.getRequiredValue(&quot;Key password&quot;);
        }
        else if (&quot;v1-signer-name&quot;.equals(optionName)) {
            signerParams.v1SigFileBasename = optionsParser.getRequiredValue(&quot;JAR signature file basename&quot;);
        }
        else if (&quot;ks-type&quot;.equals(optionName)) {
            signerParams.keystoreType = optionsParser.getRequiredValue(&quot;KeyStore type&quot;);
        }
        else if (&quot;ks-provider-name&quot;.equals(optionName)) {
            signerParams.keystoreProviderName = optionsParser.getRequiredValue(&quot;JCA KeyStore Provider name&quot;);
        }
        else if (&quot;ks-provider-class&quot;.equals(optionName)) {
            signerParams.keystoreProviderClass = optionsParser.getRequiredValue(&quot;JCA KeyStore Provider class name&quot;);
        }
        else if (&quot;ks-provider-arg&quot;.equals(optionName)) {
            signerParams.keystoreProviderArg = optionsParser.getRequiredValue(&quot;JCA KeyStore Provider constructor argument&quot;);
        }
        else if (&quot;key&quot;.equals(optionName)) {
            signerParams.keyFile = optionsParser.getRequiredValue(&quot;Private key file&quot;);
        }
        else if (&quot;cert&quot;.equals(optionName)) {
            signerParams.certFile = optionsParser.getRequiredValue(&quot;Certificate file&quot;);
        }
        else {
            if (!&quot;v&quot;.equals(optionName) &amp;&amp; !&quot;verbose&quot;.equals(optionName)) {
                throw new ParameterException(&quot;Unsupported option: &quot; + optionOriginalForm + &quot;. See --help for supported&quot; + &quot; options.&quot;);
            }
            verbose = optionsParser.getOptionalBooleanValue(true);
        }
    }
    if (!signerParams.isEmpty()) {
        signers.add(signerParams);
    }
    signerParams = null;
    if (signers.isEmpty()) {
        throw new ParameterException(&quot;At least one signer must be specified&quot;);
    }
    params = optionsParser.getRemainingParams();
    if (params.length &lt; 1) {
        throw new ParameterException(&quot;Missing input APK&quot;);
    }
    if (params.length &gt; 1) {
        throw new ParameterException(&quot;Unexpected parameter(s) after input APK (&quot; + params[0] + &quot;)&quot;);
    }
    if (minSdkVersionSpecified &amp;&amp; minSdkVersion &gt; maxSdkVersion) {
        throw new ParameterException(&quot;Min API Level (&quot; + minSdkVersion + &quot;) &gt; max API Level (&quot; + maxSdkVersion + &quot;)&quot;);
    }
    final List&lt;ApkSigner.SignerConfig&gt; signerConfigs = new ArrayList&lt;ApkSigner.SignerConfig&gt;(signers.size());
    int signerNumber = 0;
    try (final PasswordRetriever passwordRetriever = new PasswordRetriever()) {
        for (final SignerParams signer : signers) {
            ++signerNumber;
            signer.name = &quot;signer #&quot; + signerNumber;
            try {
                signer.loadPrivateKeyAndCerts(passwordRetriever);
            }
            catch (ParameterException e) {
                System.err.println(&quot;Failed to load signer \&quot;&quot; + signer.name + &quot;\&quot;: &quot; + e.getMessage());
                System.exit(2);
                return;
            }
            catch (Exception e2) {
                System.err.println(&quot;Failed to load signer \&quot;&quot; + signer.name + &quot;\&quot;&quot;);
                e2.printStackTrace();
                System.exit(2);
                return;
            }
            String v1SigBasename;
            if (signer.v1SigFileBasename != null) {
                v1SigBasename = signer.v1SigFileBasename;
            }
            else if (signer.keystoreKeyAlias != null) {
                v1SigBasename = signer.keystoreKeyAlias;
            }
            else {
                if (signer.keyFile == null) {
                    throw new RuntimeException(&quot;Neither KeyStore key alias nor private key file available&quot;);
                }
                final String keyFileName = new File(signer.keyFile).getName();
                final int delimiterIndex = keyFileName.indexOf(46);
                if (delimiterIndex == -1) {
                    v1SigBasename = keyFileName;
                }
                else {
                    v1SigBasename = keyFileName.substring(0, delimiterIndex);
                }
            }
            final ApkSigner.SignerConfig signerConfig = new ApkSigner.SignerConfig.Builder(v1SigBasename, signer.privateKey, signer.certs).build();
            signerConfigs.add(signerConfig);
        }
    }
    final File inputApk = new File(params[0]);
    if (outputApk == null) {
        outputApk = inputApk;
    }
    File tmpOutputApk;
    if (inputApk.getCanonicalPath().equals(outputApk.getCanonicalPath())) {
        tmpOutputApk = File.createTempFile(&quot;apksigner&quot;, &quot;.apk&quot;);
        tmpOutputApk.deleteOnExit();
    }
    else {
        tmpOutputApk = outputApk;
    }
    final ApkSigner.Builder apkSignerBuilder = new ApkSigner.Builder(signerConfigs).setInputApk(inputApk).setOutputApk(tmpOutputApk).setOtherSignersSignaturesPreserved(false).setV1SigningEnabled(v1SigningEnabled).setV2SigningEnabled(v2SigningEnabled).setCreatedBy(&quot;0.3 (Android apksigner)&quot;);
    if (minSdkVersionSpecified) {
        apkSignerBuilder.setMinSdkVersion(minSdkVersion);
    }
    final ApkSigner apkSigner = apkSignerBuilder.build();
    try {
        apkSigner.sign();
    }
    catch (MinSdkVersionException e3) {
        String msg = e3.getMessage();
        if (!msg.endsWith(&quot;.&quot;)) {
            msg += &#39;.&#39;;
        }
        throw new MinSdkVersionException(&quot;Failed to determine APK&#39;s minimum supported platform version. Use --min-sdk-version to override&quot;, e3);
    }
    if (!tmpOutputApk.getCanonicalPath().equals(outputApk.getCanonicalPath())) {
        final FileSystem fs = FileSystems.getDefault();
        Files.move(fs.getPath(tmpOutputApk.getPath(), new String[0]), fs.getPath(outputApk.getPath(), new String[0]), StandardCopyOption.REPLACE_EXISTING);
    }
    if (verbose) {
        System.out.println(&quot;Signed&quot;);
    }
}
</code></pre><p>入口传入的是在调用<code>apksigned.jar</code>时的参数，需要判断参数的个数，如果个数为0，输出Usage并返回</p>
<pre><code>if (params.length == 0) {
    printUsage(&quot;help_sign.txt&quot;);
    return;
}
</code></pre><p>这个<code>help_sign.txt</code>的内容如下</p>
<pre><code>USAGE: apksigner sign [options] apk

This signs the provided APK using one or more signers, each represented by
an asymmetric key pair and a corresponding certificate. Typically, an APK is
signed by just one signer. For each signer, you need to provide the signer&#39;s
private key and certificate.


        OPTIONS

--out                 File into which to output the signed APK. By default, the
                      APK is signed in-place, overwriting the input file.

--min-sdk-version     Lowest API Level on which this APK&#39;s signatures will be
                      verified. By default, the value from AndroidManifest.xml
                      is used. The higher the value, the stronger security
                      parameters are used when signing.

--max-sdk-version     Highest API Level on which this APK&#39;s signatures will be
                      verified. By default, the highest possible value is used.

--v1-signing-enabled  Whether to enable signing using JAR signing scheme (aka v1
                      signing scheme, the one used in Android since day one). By
                      default, signing using this scheme is enabled based on min
                      and max SDK version (see --min-sdk-version and
                      --max-sdk-version).

--v2-signing-enabled  Whether to enable signing using APK Signature Scheme v2
                      (aka v2 signing scheme, the one introduced in Android
                      Nougat, API Level 24). By default, signing using this
                      scheme is enabled based on min and max SDK version (see
                      --min-sdk-version and --max-sdk-version).

-v, --verbose         Verbose output mode

-h, --help            Show help about this command and exit


        PER-SIGNER OPTIONS
These options specify the configuration of a particular signer. To delimit
options of different signers, use --next-signer.

--next-signer         Delimits options of two different signers. There is no
                      need to use this option when only one signer is used.

--v1-signer-name      Basename for files comprising the JAR signature scheme
                      (aka v1 scheme) signature of this signer. By default,
                      KeyStore key alias or basename of key file is used.

        PER-SIGNER SIGNING KEY &amp; CERTIFICATE OPTIONS
There are two ways to provide the signer&#39;s private key and certificate: (1) Java
KeyStore (see --ks), or (2) private key file in PKCS #8 format and certificate
file in X.509 format (see --key and --cert).

--ks                  Load private key and certificate chain from the Java
                      KeyStore initialized from the specified file. NONE means
                      no file is needed by KeyStore, which is the case for some
                      PKCS #11 KeyStores.

--ks-key-alias        Alias under which the private key and certificate are
                      stored in the KeyStore. This must be specified if the
                      KeyStore contains multiple keys.

--ks-pass             KeyStore password (see --ks). The following formats are
                      supported:
                          pass:&lt;password&gt; password provided inline
                          env:&lt;name&gt;      password provided in the named
                                          environment variable
                          file:&lt;file&gt;     password provided in the named
                                          file, as a single line
                          stdin           password provided on standard input,
                                          as a single line
                      A password is required to open a KeyStore.
                      By default, the tool will prompt for password via console
                      or standard input.
                      When the same file (including standard input) is used for
                      providing multiple passwords, the passwords are read from
                      the file one line at a time. Passwords are read in the
                      order in which signers are specified and, within each
                      signer, KeyStore password is read before the key password
                      is read.

--key-pass            Password with which the private key is protected. By
                      default it is assumed that KeyStore keys are protected
                      using the same password as their KeyStore (see --ks-pass).
                      The following formats are supported:
                          pass:&lt;password&gt; password provided inline
                          env:&lt;name&gt;      password provided in the named
                                          environment variable
                          file:&lt;file&gt;     password provided in the named
                                          file, as a single line
                          stdin           password provided on standard input,
                                          as a single line
                      By default, if the key is password-protected, the tool
                      will prompt for password via console or standard input.
                      When the same file (including standard input) is used for
                      providing multiple passwords, the passwords are read from
                      the file one line at a time. Passwords are read in the
                      order in which signers are specified and, within each
                      signer, KeyStore password is read before the key password
                      is read.

--ks-type             Type/algorithm of KeyStore to use. By default, the default
                      type is used.

--ks-provider-name    Name of the JCA Provider from which to request the
                      KeyStore implementation. By default, the highest priority
                      provider is used. See --ks-provider-class for the
                      alternative way to specify a provider.

--ks-provider-class   Fully-qualified class name of the JCA Provider from which
                      to request the KeyStore implementation. By default, the
                      provider is chosen based on --ks-provider-name.

--ks-provider-arg     Value to pass into the constructor of the JCA Provider
                      class specified by --ks-provider-class. The value is
                      passed into the constructor as java.lang.String. By
                      default, the no-arg provider&#39;s constructor is used.

--key                 Load private key from the specified file. If the key is
                      password-protected, the password will be prompted via
                      standard input unless specified otherwise using
                      --key-pass. The file must be in PKCS #8 DER format.

--cert                Load certificate chain from the specified file. The file
                      must be in X.509 PEM or DER format.


        EXAMPLES

1. Sign an APK using the one and only key in keystore release.jks:
$ apksigner sign --ks release.jks app.apk

2. Sign an APK using a private key and certificate stored as individual files:
$ apksigner sign --key release.pk8 --cert release.x509.pem app.apk

3. Sign an APK using two keys:
$ apksigner sign --ks release.jks --next-signer --ks magic.jks app.apk
</code></pre><p>如<code>EXAMPLES</code>里第一条，至少都有一个参数</p>
<p>在确定有<code>[option]</code>之后，进入循环进行参数判断以及处理</p>
<pre><code>while ((optionName = optionsParser.nextOption()) != null) {
    final String optionOriginalForm = optionsParser.getOptionOriginalForm();
    if (&quot;help&quot;.equals(optionName) || &quot;h&quot;.equals(optionName)) {
        printUsage(&quot;help_sign.txt&quot;);
        return;
    }
    if (&quot;out&quot;.equals(optionName)) {
        outputApk = new File(optionsParser.getRequiredValue(&quot;Output file name&quot;));
    }
    else if (&quot;min-sdk-version&quot;.equals(optionName)) {
        minSdkVersion = optionsParser.getRequiredIntValue(&quot;Mininimum API Level&quot;);
        minSdkVersionSpecified = true;
    }
    else if (&quot;max-sdk-version&quot;.equals(optionName)) {
        maxSdkVersion = optionsParser.getRequiredIntValue(&quot;Maximum API Level&quot;);
    }
    else if (&quot;v1-signing-enabled&quot;.equals(optionName)) {
        v1SigningEnabled = optionsParser.getOptionalBooleanValue(true);
    }
    else if (&quot;v2-signing-enabled&quot;.equals(optionName)) {
        v2SigningEnabled = optionsParser.getOptionalBooleanValue(true);
    }
    else if (&quot;next-signer&quot;.equals(optionName)) {
        if (signerParams.isEmpty()) {
            continue;
        }
        signers.add(signerParams);
        signerParams = new SignerParams();
    }
    else if (&quot;ks&quot;.equals(optionName)) {
        signerParams.keystoreFile = optionsParser.getRequiredValue(&quot;KeyStore file&quot;);
    }
    else if (&quot;ks-key-alias&quot;.equals(optionName)) {
        signerParams.keystoreKeyAlias = optionsParser.getRequiredValue(&quot;KeyStore key alias&quot;);
    }
    else if (&quot;ks-pass&quot;.equals(optionName)) {
        signerParams.keystorePasswordSpec = optionsParser.getRequiredValue(&quot;KeyStore password&quot;);
    }
    else if (&quot;key-pass&quot;.equals(optionName)) {
        signerParams.keyPasswordSpec = optionsParser.getRequiredValue(&quot;Key password&quot;);
    }
    else if (&quot;v1-signer-name&quot;.equals(optionName)) {
        signerParams.v1SigFileBasename = optionsParser.getRequiredValue(&quot;JAR signature file basename&quot;);
    }
    else if (&quot;ks-type&quot;.equals(optionName)) {
        signerParams.keystoreType = optionsParser.getRequiredValue(&quot;KeyStore type&quot;);
    }
    else if (&quot;ks-provider-name&quot;.equals(optionName)) {
        signerParams.keystoreProviderName = optionsParser.getRequiredValue(&quot;JCA KeyStore Provider name&quot;);
    }
    else if (&quot;ks-provider-class&quot;.equals(optionName)) {
        signerParams.keystoreProviderClass = optionsParser.getRequiredValue(&quot;JCA KeyStore Provider class name&quot;);
    }
    else if (&quot;ks-provider-arg&quot;.equals(optionName)) {
        signerParams.keystoreProviderArg = optionsParser.getRequiredValue(&quot;JCA KeyStore Provider constructor argument&quot;);
    }
    else if (&quot;key&quot;.equals(optionName)) {
        signerParams.keyFile = optionsParser.getRequiredValue(&quot;Private key file&quot;);
    }
    else if (&quot;cert&quot;.equals(optionName)) {
        signerParams.certFile = optionsParser.getRequiredValue(&quot;Certificate file&quot;);
    }
    else {
        if (!&quot;v&quot;.equals(optionName) &amp;&amp; !&quot;verbose&quot;.equals(optionName)) {
            throw new ParameterException(&quot;Unsupported option: &quot; + optionOriginalForm + &quot;. See --help for supported&quot; + &quot; options.&quot;);
        }
        verbose = optionsParser.getOptionalBooleanValue(true);
    }
}
</code></pre><p>有两个字段需要注意，这个<code>V2</code>是在<code>Android 7.0</code>开始引入的校验机制，这也是<code>signapk.jar</code>所没有的</p>
<pre><code>else if (&quot;v1-signing-enabled&quot;.equals(optionName)) {
    v1SigningEnabled = optionsParser.getOptionalBooleanValue(true);
}
else if (&quot;v2-signing-enabled&quot;.equals(optionName)) {
    v2SigningEnabled = optionsParser.getOptionalBooleanValue(true);
}
</code></pre><p>处理完参数校验一下</p>
<pre><code>if (!signerParams.isEmpty()) {
    signers.add(signerParams);
}
signerParams = null;
if (signers.isEmpty()) {
    throw new ParameterException(&quot;At least one signer must be specified&quot;);
}
params = optionsParser.getRemainingParams();
if (params.length &lt; 1) {
    throw new ParameterException(&quot;Missing input APK&quot;);
}
if (params.length &gt; 1) {
    throw new ParameterException(&quot;Unexpected parameter(s) after input APK (&quot; + params[0] + &quot;)&quot;);
}
if (minSdkVersionSpecified &amp;&amp; minSdkVersion &gt; maxSdkVersion) {
    throw new ParameterException(&quot;Min API Level (&quot; + minSdkVersion + &quot;) &gt; max API Level (&quot; + maxSdkVersion + &quot;)&quot;);
}
</code></pre><p>后面就是很类似的计算计算计算了，至于V2，还没研究，据谷歌官方文档说，是根据字节来的</p>
<p><img src="Image/9.png" alt=""></p>
<h2 id="0x03-">0x03 小结</h2>
<p>我好像跳了很多地方没有写。。。。。。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
