<!DOCTYPE html>
<html>
<head>
<title>DexClassLoader和PathClassLoader(3)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="dexclassloader-pathclassloader-3-">DexClassLoader和PathClassLoader(3)</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<h2 id="0x00-">0x00 前言</h2>
<p>在DexClassLoader和PathClassLoader(2)中，将加载Dex文件前期的准备工作详细的分析了一遍，包括几个很关键的结构体</p>
<p>篇幅问题，留了几个方法，从命名来看，明显的看出来这是关键的几个方法</p>
<pre><code>- dvmOpenCachedDexFile(fileName, cachedName, modTime, adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true)
- copyFileToFile(optFd, dexFd, fileSize)
- dvmOptimizeDexFile(optFd, dexOffset, fileSize, fileName, modTime, adler32, isBootstrap)
- dvmDexFileOpenFromFd(optFd, &amp;pDvmDex)
</code></pre><h2 id="0x01-">0x01 四个关键</h2>
<p><code>dvmOpenCachedDexFile()</code>方法参数蛮多的</p>
<ul>
<li>fileName</li><li>cachedName</li><li>modTime</li><li>adler32</li><li>isBootstrap</li><li>&amp;newFile</li><li>/<em>createIfMissing=</em>/true</li></ul>
<p>主要作用就是判断是否存在已优化的ODex文件</p>
<ul>
<li>如果不存在，先创建一个，然后写一下ODex Header，返回文件描述符</li><li>如果存在，则各种判断，再返回文件描述符(该分支我们后面分析)</li></ul>
<pre><code>int dvmOpenCachedDexFile(const char* fileName, const char* cacheFileName,
    u4 modWhen, u4 crc, bool isBootstrap, bool* pNewFile, bool createIfMissing)
{
    int fd, cc;
    struct stat fdStat, fileStat;
    bool readOnly = false;

    *pNewFile = false;

retry:
    //传进来的createIfMissing是True，所以这里会创建文件
    //第一个参数: 文件路径
    //第二个参数O_CREAT: 文件不存在则创建
    //第二个参数O_RDWR: 可读可写打开文件
    //第三个参数0664: 权限的数字表示，用于描述前面创建的文件权限: rw-rw-rw-
    fd = createIfMissing ? open(cacheFileName, O_CREAT|O_RDWR, 0644) : -1;

    //出问题未获得ODex文件的文件描述符
    if (fd &lt; 0) {
        //只读模式打开
        fd = open(cacheFileName, O_RDONLY, 0);
        if (fd &lt; 0) {
            //只读打开依旧失败，那就只能失败了，返回小于0的文件描述符fd
            if (createIfMissing) {
                const std::string errnoString(strerror(errno));
                if (directoryIsValid(cacheFileName)) {
                    ALOGE(&quot;Can&#39;t open dex cache file &#39;%s&#39;: %s&quot;, cacheFileName, errnoString.c_str());
                }
            }
            return fd;
        }
        //readOnly变量对于后续的逻辑判断很重要，不过总归是已经创建了ODex文件
        readOnly = true;
    } else {
        fchmod(fd, 0644);
    }

    //这里给新建的ODex文件描述符fd上了个锁，并且将线程状态设置为VMWAIT状态
    //注释里的说法是一定要上个锁，就算这个时候有其它线程在操作这个文件，也要等它操作完了
    //再给它上锁，说是后面有大用处，说是在等待某外部资源，其实应该是在等待Dex文件的数据写进来:)
    ALOGV(&quot;DexOpt: locking cache file %s (fd=%d, boot=%d)&quot;,
        cacheFileName, fd, isBootstrap);
    ThreadStatus oldStatus = dvmChangeStatus(NULL, THREAD_VMWAIT);
    cc = flock(fd, LOCK_EX | LOCK_NB);
    if (cc != 0) {
        ALOGD(&quot;DexOpt: sleeping on flock(%s)&quot;, cacheFileName);
        cc = flock(fd, LOCK_EX);
    }
    dvmChangeStatus(NULL, oldStatus);
    if (cc != 0) {
        ALOGE(&quot;Can&#39;t lock dex cache &#39;%s&#39;: %d&quot;, cacheFileName, cc);
        close(fd);
        return -1;
    }
    ALOGV(&quot;DexOpt:  locked cache file&quot;);

    //进行两重校验，比如创建文件出错，打开出错的问题
    cc = fstat(fd, &amp;fdStat);
    if (cc != 0) {
        ALOGE(&quot;Can&#39;t stat open file &#39;%s&#39;&quot;, cacheFileName);
        LOGVV(&quot;DexOpt: unlocking cache file %s&quot;, cacheFileName);
        goto close_fail;
    }
    cc = stat(cacheFileName, &amp;fileStat);
    if (cc != 0 ||
        fdStat.st_dev != fileStat.st_dev || fdStat.st_ino != fileStat.st_ino)
    {
        ALOGD(&quot;DexOpt: our open cache file is stale; sleeping and retrying&quot;);
        LOGVV(&quot;DexOpt: unlocking cache file %s&quot;, cacheFileName);
        flock(fd, LOCK_UN);
        close(fd);
        usleep(250 * 1000);     /* if something is hosed, don&#39;t peg machine */
        goto retry;
    }

    //如果文件大小为0，说明是我们刚创建的
    //注意readOnly变量，我刚才说这个变量非常重要，这里有所体现
    if (fdStat.st_size == 0) {
        //ODex文件的头部是ODex Header，如果是只读打开，那么并不符合这里的操作需求
        //所以如果是只读，跳到失败分支
        if (readOnly) {
            ALOGW(&quot;DexOpt: file has zero length and isn&#39;t writable&quot;);
            goto close_fail;
        }
        //创建一个空的ODex Header
        cc = dexOptCreateEmptyHeader(fd);
        if (cc != 0)
            goto close_fail;
        //这个变量会在上一层函数中作为是否是新建文件的标志决定是否执行优化Dex的操作
        *pNewFile = true;
        ALOGV(&quot;DexOpt: successfully initialized new cache file&quot;);
    } else {
        //这个分支其实是以前加载该Dex过后，在目标路径存在对应的ODex文件
        //那么就会直接使用该ODex文件，而且会使用NewFile变量表示不是新创建的文件
        bool expectVerify, expectOpt;

        if (gDvm.classVerifyMode == VERIFY_MODE_NONE) {
            expectVerify = false;
        } else if (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) {
            expectVerify = !isBootstrap;
        } else /*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/ {
            expectVerify = true;
        }

        if (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) {
            expectOpt = false;
        } else if (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||
                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) {
            expectOpt = expectVerify;
        } else /*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/ {
            expectOpt = true;
        }

        ALOGV(&quot;checking deps, expecting vfy=%d opt=%d&quot;,
            expectVerify, expectOpt);

        if (!dvmCheckOptHeaderAndDependencies(fd, true, modWhen, crc,
                expectVerify, expectOpt))
        {
            if (readOnly) {
                if (createIfMissing) {
                    ALOGW(&quot;Cached DEX &#39;%s&#39; (%s) is stale and not writable&quot;,
                        fileName, cacheFileName);
                }
                goto close_fail;
            }

            ALOGD(&quot;ODEX file is stale or bad; removing and retrying (%s)&quot;,
                cacheFileName);
            if (ftruncate(fd, 0) != 0) {
                ALOGW(&quot;Warning: unable to truncate cache file &#39;%s&#39;: %s&quot;,
                    cacheFileName, strerror(errno));
                /* keep going */
            }
            if (unlink(cacheFileName) != 0) {
                ALOGW(&quot;Warning: unable to remove cache file &#39;%s&#39;: %d %s&quot;,
                    cacheFileName, errno, strerror(errno));
                /* keep going; permission failure should probably be fatal */
            }
            LOGVV(&quot;DexOpt: unlocking cache file %s&quot;, cacheFileName);
            flock(fd, LOCK_UN);
            close(fd);
            goto retry;
        } else {
            ALOGV(&quot;DexOpt: good deps in cache file&quot;);
        }
    }

    assert(fd &gt;= 0);
    return fd;

close_fail:
    flock(fd, LOCK_UN);
    close(fd);
    return -1;
}
</code></pre><p>当打开了目标ODex文件，但是并不知道该ODex文件的状态，到底是新创建的还是已经优化后的？</p>
<p>所以判断了ODex文件的Size，如果是0说明该文件刚创建，会调用<code>dexOptCreateEmptyHeader()</code>方法生成ODex Header</p>
<pre><code>int dexOptCreateEmptyHeader(int fd)
{
    DexOptHeader optHdr;
    ssize_t actual;

    //保证文件指针指向首字节
    assert(lseek(fd, 0, SEEK_CUR) == 0);

    assert((sizeof(optHdr) &amp; 0x07) == 0);

    //初始化整个ODex Header
    memset(&amp;optHdr, 0xff, sizeof(optHdr));

    //ODex Header的后面就是Dex文件
    //此处给成员dexOffset赋值
    optHdr.dexOffset = sizeof(optHdr);

    //将只初始化了一个成员变量值的optHdr数据写进ODex文件
    actual = write(fd, &amp;optHdr, sizeof(optHdr));
    if (actual != sizeof(optHdr)) {
        int err = errno ? errno : -1;
        ALOGE(&quot;opt header write failed: %s&quot;, strerror(errno));
        return errno;
    }

    return 0;
}
</code></pre><p><code>DexOptHeader</code>结构体</p>
<pre><code>struct DexOptHeader {
    u1  magic[8];           /* includes version number */

    u4  dexOffset;          /* file offset of DEX header */
    u4  dexLength;
    u4  depsOffset;         /* offset of optimized DEX dependency table */
    u4  depsLength;
    u4  optOffset;          /* file offset of optimized data tables */
    u4  optLength;

    u4  flags;              /* some info flags */
    u4  checksum;           /* adler32 checksum covering deps/opt */

    /* pad for 64-bit alignment if necessary */
};
</code></pre><p>这隔着蛮远，重新来看<code>dvmRawDexFileOpe()</code>接下来的代码，<code>newFile</code>变量我在前面强调过很多次，用于标记ODex是否是新创建</p>
<p>如果是新创建的ODex，说明未优化，也就需要进入接下来的分支里，如果不是新创建的，说明已经优化过了，那么接下来这个分支里的优化代码没有必要执行，此处我们假设是第一次加载</p>
<pre><code>if (newFile) {
    u8 startWhen, copyWhen, endWhen;
    bool result;
    off_t dexOffset;

    //获取当前文件指针
    //由于dvmOpenCachedDexFile()里创建的ODex文件写了ODex Header进去，所以文件指针一定大于0
    dexOffset = lseek(optFd, 0, SEEK_CUR);
    result = (dexOffset &gt; 0);

    if (result) {
        startWhen = dvmGetRelativeTimeUsec();
        //
        result = copyFileToFile(optFd, dexFd, fileSize) == 0;
        copyWhen = dvmGetRelativeTimeUsec();
    }

    if (result) {
        //继续处理生成ODex文件
        result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,
            fileName, modTime, adler32, isBootstrap);
    }

    if (!result) {
        ALOGE(&quot;Unable to extract+optimize DEX from &#39;%s&#39;&quot;, fileName);
        goto bail;
    }

    endWhen = dvmGetRelativeTimeUsec();
    ALOGD(&quot;DEX prep &#39;%s&#39;: copy in %dms, rewrite %dms&quot;,
        fileName,
        (int) (copyWhen - startWhen) / 1000,
        (int) (endWhen - copyWhen) / 1000);
}
</code></pre><p><code>copyFileToFile()</code>用于将Dex文件拷贝到ODex文件中，执行完后ODex文件已经有了ODex Header和Dex两个成员</p>
<pre><code>static int copyFileToFile(int destFd, int srcFd, size_t size)
{
    //将文件指针指向Dex文件的首字节
    if (lseek(srcFd, 0, SEEK_SET) != 0) {
        ALOGE(&quot;lseek failure: %s&quot;, strerror(errno));
        return -1;
    }

    //拷贝
    return sysCopyFileToFile(destFd, srcFd, size);
}

int sysCopyFileToFile(int outFd, int inFd, size_t count)
{
    const size_t kBufSize = 32768;
    unsigned char buf[kBufSize];

    while (count != 0) {
        size_t getSize = (count &gt; kBufSize) ? kBufSize : count;

        ssize_t actual = TEMP_FAILURE_RETRY(read(inFd, buf, getSize));
        if (actual != (ssize_t) getSize) {
            ALOGW(&quot;sysCopyFileToFile: copy read failed (%d vs %zd)&quot;,
                (int) actual, getSize);
            return -1;
        }

        if (sysWriteFully(outFd, buf, getSize, &quot;sysCopyFileToFile&quot;) != 0)
            return -1;

        count -= getSize;
    }

    return 0;
}
</code></pre><p>在介绍<code>dvmOptimizeDexFile()</code>之前，有一个重要的变量<code>gDvm</code>，前面也有出现过几次，但是都不是很惹眼</p>
<p>随意看几个成员就好了，实在是太长了，<code>gDvm</code>是虚拟机的一个全局变量，存储着<strong>各种</strong>数据，在虚拟机初始化的时候被创建</p>
<pre><code>struct DvmGlobals {
    /*
     * Some options from the command line or environment.
     */
    char*       bootClassPathStr;
    char*       classPathStr;

    size_t      heapStartingSize;
    size_t      heapMaximumSize;
    size_t      heapGrowthLimit;
    bool        lowMemoryMode;
    double      heapTargetUtilization;
    size_t      heapMinFree;
    size_t      heapMaxFree;
    size_t      stackSize;
    size_t      mainThreadStackSize;
    //......
</code></pre><p><code>dvmOptimizeDexFile()</code>调用了<code>dexopt</code>命令来优化Dex，在这里只是做了参数的选择，然后调用了优化命令</p>
<pre><code>bool dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength,
    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
    const char* lastPart = strrchr(fileName, &#39;/&#39;);
    if (lastPart != NULL)
        lastPart++;
    else
        lastPart = fileName;

    ALOGD(&quot;DexOpt: --- BEGIN &#39;%s&#39; (bootstrap=%d) ---&quot;, lastPart, isBootstrap);

    pid_t pid;

    /*
     * This could happen if something in our bootclasspath, which we thought
     * was all optimized, got rejected.
     */
    if (gDvm.optimizing) {
        ALOGW(&quot;Rejecting recursive optimization attempt on &#39;%s&#39;&quot;, fileName);
        return false;
    }

    //fork一个子进程，在子进程中完成优化过程
    //fork()有两个返回值，等于和不等于0
    //返回0的说明在子进程中
    //返回大于0说明在父进程中，小于0说明fork失败了
    pid = fork();
    if (pid == 0) {
        static const int kUseValgrind = 0;
        static const char* kDexOptBin = &quot;/bin/dexopt&quot;;
        static const char* kValgrinder = &quot;/usr/bin/valgrind&quot;;
        static const int kFixedArgCount = 10;
        static const int kValgrindArgCount = 5;
        static const int kMaxIntLen = 12;   // &#39;-&#39;+10dig+&#39;\0&#39; -OR- 0x+8dig
        int bcpSize = dvmGetBootPathSize();
        int argc = kFixedArgCount + bcpSize
            + (kValgrindArgCount * kUseValgrind);
        const char* argv[argc+1];             // last entry is NULL
        char values[argc][kMaxIntLen];
        char* execFile;
        const char* androidRoot;
        int flags;

        /* change process groups, so we don&#39;t clash with ProcessManager */
        setpgid(0, 0);

        //dexopt工具的完整路径
        //类似：/system/bin/dexopt
        androidRoot = getenv(&quot;ANDROID_ROOT&quot;);
        if (androidRoot == NULL) {
            ALOGW(&quot;ANDROID_ROOT not set, defaulting to /system&quot;);
            androidRoot = &quot;/system&quot;;
        }
        execFile = (char*)alloca(strlen(androidRoot) + strlen(kDexOptBin) + 1);
        strcpy(execFile, androidRoot);
        strcat(execFile, kDexOptBin);

        //构造命令参数
        int curArg = 0;

        //这个if里的条件不成立
        //kUseValgrind初始化为0
        if (kUseValgrind) {
            /* probably shouldn&#39;t ship the hard-coded path */
            argv[curArg++] = (char*)kValgrinder;
            argv[curArg++] = &quot;--tool=memcheck&quot;;
            argv[curArg++] = &quot;--leak-check=yes&quot;;        // check for leaks too
            argv[curArg++] = &quot;--leak-resolution=med&quot;;   // increase from 2 to 4
            argv[curArg++] = &quot;--num-callers=16&quot;;        // default is 12
            assert(curArg == kValgrindArgCount);
        }
        argv[curArg++] = execFile;

        argv[curArg++] = &quot;--dex&quot;;

        //#define DALVIK_VM_BUILD         27
        sprintf(values[2], &quot;%d&quot;, DALVIK_VM_BUILD);
        argv[curArg++] = values[2];

        //ODex文件的文件描述符
        sprintf(values[3], &quot;%d&quot;, fd);
        argv[curArg++] = values[3];

        //Dex文件在ODex文件中的偏移，就在ODex Header后面
        sprintf(values[4], &quot;%d&quot;, (int) dexOffset);
        argv[curArg++] = values[4];

        //Dex文件的长度
        sprintf(values[5], &quot;%d&quot;, (int) dexLength);
        argv[curArg++] = values[5];

        //Dex文件名
        argv[curArg++] = (char*)fileName;

        //Dex文件修改时间
        sprintf(values[7], &quot;%d&quot;, (int) modWhen);
        argv[curArg++] = values[7];

        //checksum
        sprintf(values[8], &quot;%d&quot;, (int) crc);
        argv[curArg++] = values[8];

        //这一堆还有待研究
        flags = 0;
        if (gDvm.dexOptMode != OPTIMIZE_MODE_NONE) {
            flags |= DEXOPT_OPT_ENABLED;
            if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)
                flags |= DEXOPT_OPT_ALL;
        }
        if (gDvm.classVerifyMode != VERIFY_MODE_NONE) {
            flags |= DEXOPT_VERIFY_ENABLED;
            if (gDvm.classVerifyMode == VERIFY_MODE_ALL)
                flags |= DEXOPT_VERIFY_ALL;
        }
        if (isBootstrap)
            flags |= DEXOPT_IS_BOOTSTRAP;
        if (gDvm.generateRegisterMaps)
            flags |= DEXOPT_GEN_REGISTER_MAPS;
        sprintf(values[9], &quot;%d&quot;, flags);
        argv[curArg++] = values[9];

        //第一个括号的条件会满足
        assert(((!kUseValgrind &amp;&amp; curArg == kFixedArgCount) ||
               ((kUseValgrind &amp;&amp; curArg == kFixedArgCount+kValgrindArgCount))));

        //前面获取了ClassPath的数量，已经加在了argv的长度中
        ClassPathEntry* cpe;
        for (cpe = gDvm.bootClassPath; cpe-&gt;ptr != NULL; cpe++) {
            argv[curArg++] = cpe-&gt;fileName;
        }
        assert(curArg == argc);

        argv[curArg] = NULL;

        //kUseValgrind一直是0，虽然不排除其它地方会对它修改
        //但是目前来看，会执行else里的代码
        if (kUseValgrind)
            execv(kValgrinder, const_cast&lt;char**&gt;(argv));
        else
            execv(execFile, const_cast&lt;char**&gt;(argv));

        //execv()会停掉本进程，去执行progName
        //所以正常情况下不会到这里，如果这里执行说明上面出了问题
        ALOGE(&quot;execv &#39;%s&#39;%s failed: %s&quot;, execFile,
            kUseValgrind ? &quot; [valgrind]&quot; : &quot;&quot;, strerror(errno));
        exit(1);
    } else {
        ALOGV(&quot;DexOpt: waiting for verify+opt, pid=%d&quot;, (int) pid);
        int status;
        pid_t gotPid;

        //等等等等等等等等等等等等等等等等等等等等
        ThreadStatus oldStatus = dvmChangeStatus(NULL, THREAD_VMWAIT);
        while (true) {
            gotPid = waitpid(pid, &amp;status, 0);
            if (gotPid == -1 &amp;&amp; errno == EINTR) {
                ALOGD(&quot;waitpid interrupted, retrying&quot;);
            } else {
                break;
            }
        }

        //等完继续执行
        dvmChangeStatus(NULL, oldStatus);
        if (gotPid != pid) {
            ALOGE(&quot;waitpid failed: wanted %d, got %d: %s&quot;,
                (int) pid, (int) gotPid, strerror(errno));
            return false;
        }

        if (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == 0) {
            ALOGD(&quot;DexOpt: --- END &#39;%s&#39; (success) ---&quot;, lastPart);
            return true;
        } else {
            ALOGW(&quot;DexOpt: --- END &#39;%s&#39; --- status=0x%04x, process failed&quot;,
                lastPart, status);
            return false;
        }
    }
}
</code></pre><p>上面说到的<code>dexopt</code>源码在<code>/dalvik/dexopt/OptMain.cpp</code></p>
<p>就是一个可执行的ELF文件，找到<code>main()</code>函数入口</p>
<pre><code>int main(int argc, char* const argv[])
{
    //设置进程名
    set_process_name(&quot;dexopt&quot;);

    setvbuf(stdout, NULL, _IONBF, 0);

    //通过第二个参数来决定调用的方法
    //隐约记得命令是&quot;/system/bin/dexopt --dex ......&quot;
    if (argc &gt; 1) {
        if (strcmp(argv[1], &quot;--zip&quot;) == 0)
            return fromZip(argc, argv);
        else if (strcmp(argv[1], &quot;--dex&quot;) == 0)
            return fromDex(argc, argv);
        else if (strcmp(argv[1], &quot;--preopt&quot;) == 0)
            return preopt(argc, argv);
    }

    fprintf(stderr,
        &quot;Usage:\n\n&quot;
        &quot;Short version: Don&#39;t use this.\n\n&quot;
        &quot;Slightly longer version: This system-internal tool is used to\n&quot;
        &quot;produce optimized dex files. See the source code for details.\n&quot;);

    return 1;
}
</code></pre><p><code>fromDex()</code>获取了传进来的参数，并且在最后调用了两个函数</p>
<pre><code>static int fromDex(int argc, char* const argv[])
{
    int result = -1;
    bool vmStarted = false;
    char* bootClassPath = NULL;
    int fd, flags, vmBuildVersion;
    long offset, length;
    const char* debugFileName;
    u4 crc, modWhen;
    char* endp;
    bool onlyOptVerifiedDex = false;
    DexClassVerifyMode verifyMode;
    DexOptimizerMode dexOptMode;

    //参数不够
    if (argc &lt; 10) {
        ALOGE(&quot;Not enough arguments for --dex (found %d)&quot;, argc);
        goto bail;
    }

    //argv先自加1，跳过&quot;--dex&quot;，同时argc自减1
    argc--;
    argv++;

    //接下来这一段都是获取参数
    //一共获取了8个，在上一层中，这里是10个，去掉了&quot;/dexopt --dex&quot;这两个
    GET_ARG(vmBuildVersion, strtol, &quot;bad vm build&quot;);
    if (vmBuildVersion != DALVIK_VM_BUILD) {
        ALOGE(&quot;DexOpt: build rev does not match VM: %d vs %d&quot;,
            vmBuildVersion, DALVIK_VM_BUILD);
        goto bail;
    }
    GET_ARG(fd, strtol, &quot;bad fd&quot;);
    GET_ARG(offset, strtol, &quot;bad offset&quot;);
    GET_ARG(length, strtol, &quot;bad length&quot;);
    debugFileName = *++argv;

    //此处argc自减1，去掉上面的debugFileName
    --argc;
    GET_ARG(modWhen, strtoul, &quot;bad modWhen&quot;);
    GET_ARG(crc, strtoul, &quot;bad crc&quot;);
    GET_ARG(flags, strtol, &quot;bad flags&quot;);

    ALOGV(&quot;Args: fd=%d off=%ld len=%ld name=&#39;%s&#39; mod=%#x crc=%#x flg=%d (argc=%d)&quot;,
        fd, offset, length, debugFileName, modWhen, crc, flags, argc);
    assert(argc &gt; 0);

    //此处判断&quot;bootClassPath&quot;的数量，可为0
    //后续的参数都是&quot;bootClassPath&quot;，数量不为0则使用&quot;:&quot;进行拼接
    if (--argc == 0) {
        bootClassPath = strdup(&quot;&quot;);
    } else {
        int i, bcpLen;
        char* const* argp;
        char* cp;

        bcpLen = 0;
        for (i = 0, argp = argv; i &lt; argc; i++) {
            ++argp;
            ALOGV(&quot;DEP: &#39;%s&#39;&quot;, *argp);
            bcpLen += strlen(*argp) + 1;
        }

        cp = bootClassPath = (char*) malloc(bcpLen +1);
        for (i = 0, argp = argv; i &lt; argc; i++) {
            int strLen;

            ++argp;
            strLen = strlen(*argp);
            if (i != 0)
                *cp++ = &#39;:&#39;;
            memcpy(cp, *argp, strLen);
            cp += strLen;
        }
        *cp = &#39;\0&#39;;

        assert((int) strlen(bootClassPath) == bcpLen-1);
    }
    ALOGV(&quot;  bootclasspath is &#39;%s&#39;&quot;, bootClassPath);

    //这一段依旧有待研究
    if ((flags &amp; DEXOPT_VERIFY_ENABLED) != 0) {
        if ((flags &amp; DEXOPT_VERIFY_ALL) != 0)
            verifyMode = VERIFY_MODE_ALL;
        else
            verifyMode = VERIFY_MODE_REMOTE;
    } else {
        verifyMode = VERIFY_MODE_NONE;
    }
    if ((flags &amp; DEXOPT_OPT_ENABLED) != 0) {
        if ((flags &amp; DEXOPT_OPT_ALL) != 0)
            dexOptMode = OPTIMIZE_MODE_ALL;
        else
            dexOptMode = OPTIMIZE_MODE_VERIFIED;
    } else {
        dexOptMode = OPTIMIZE_MODE_NONE;
    }

    //从命名来看，是优化前的初始化工作
    if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags) != 0) {
        ALOGE(&quot;VM init failed&quot;);
        goto bail;
    }

    vmStarted = true;

    //这里应该就是真正的优化操作
    if (!dvmContinueOptimization(fd, offset, length, debugFileName,
            modWhen, crc, (flags &amp; DEXOPT_IS_BOOTSTRAP) != 0))
    {
        ALOGE(&quot;Optimization failed&quot;);
        goto bail;
    }

    result = 0;

bail:

#if 0
    if (vmStarted) {
        ALOGI(&quot;DexOpt shutting down, result=%d&quot;, result);
        dvmShutdown();
    }
#endif

    free(bootClassPath);
    ALOGV(&quot;DexOpt command complete (result=%d)&quot;, result);
    return result;
}
</code></pre><p>最后调用的两个函数，从注释以及命名来看，第一个是准备工作，第二个是真的进行优化</p>
<pre><code>dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags)
dvmContinueOptimization(fd, offset, length, debugFileName, modWhen, crc, (flags &amp; DEXOPT_IS_BOOTSTRAP)
</code></pre><p><code>dvmPrepForDexOpt()</code>看起来好严肃的样子，都是一些跟Dalvik虚拟机有关的设置</p>
<pre><code>int dvmPrepForDexOpt(const char* bootClassPath, DexOptimizerMode dexOptMode,
    DexClassVerifyMode verifyMode, int dexoptFlags)
{
    gDvm.initializing = true;
    gDvm.optimizing = true;

    blockSignals();

    setCommandLineDefaults();
    free(gDvm.bootClassPathStr);
    gDvm.bootClassPathStr = strdup(bootClassPath);

    gDvm.dexOptMode = dexOptMode;
    gDvm.classVerifyMode = verifyMode;
    gDvm.generateRegisterMaps = (dexoptFlags &amp; DEXOPT_GEN_REGISTER_MAPS) != 0;
    if (dexoptFlags &amp; DEXOPT_SMP) {
        assert((dexoptFlags &amp; DEXOPT_UNIPROCESSOR) == 0);
        gDvm.dexOptForSmp = true;
    } else if (dexoptFlags &amp; DEXOPT_UNIPROCESSOR) {
        gDvm.dexOptForSmp = false;
    } else {
        gDvm.dexOptForSmp = (ANDROID_SMP != 0);
    }

    if (!dvmGcStartup())
        goto fail;
    if (!dvmThreadStartup())
        goto fail;
    if (!dvmInlineNativeStartup())
        goto fail;
    if (!dvmRegisterMapStartup())
        goto fail;
    if (!dvmInstanceofStartup())
        goto fail;
    if (!dvmClassStartup())
        goto fail;

    return 0;

fail:
    dvmShutdown();
    return 1;
}
</code></pre><p><code>dvmContinueOptimization()</code>函数看着长，但是我们记住，它操作的永远是那个ODex文件，无论是映射还是其它什么的，最终都会改变ODex文件，而改变的途径就是修改ODex文件描述符fd</p>
<pre><code>bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,
    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
    DexClassLookup* pClassLookup = NULL;
    RegisterMapBuilder* pRegMapBuilder = NULL;

    assert(gDvm.optimizing);

    ALOGV(&quot;Continuing optimization (%s, isb=%d)&quot;, fileName, isBootstrap);

    assert(dexOffset &gt;= 0);

    //对Dex长度的一个小校验
    if (dexLength &lt; (int) sizeof(DexHeader)) {
        ALOGE(&quot;too small to be DEX&quot;);
        return false;
    }

    //对ODex Header长度的一个小校验
    if (dexOffset &lt; (int) sizeof(DexOptHeader)) {
        ALOGE(&quot;not enough room for opt header&quot;);
        return false;
    }

    bool result = false;

    gDvm.optimizingBootstrapClass = isBootstrap;

    {
        bool success;
        void* mapAddr;

        //将ODex文件映射到内存中，映射的数据长度为ODex Header + Dex
        mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE,
                    MAP_SHARED, fd, 0);
        if (mapAddr == MAP_FAILED) {
            ALOGE(&quot;unable to mmap DEX cache: %s&quot;, strerror(errno));
            goto bail;
        }

        bool doVerify, doOpt;
        if (gDvm.classVerifyMode == VERIFY_MODE_NONE) {
            doVerify = false;
        } else if (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) {
            doVerify = !gDvm.optimizingBootstrapClass;
        } else /*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/ {
            doVerify = true;
        }

        if (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) {
            doOpt = false;
        } else if (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||
                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) {
            doOpt = doVerify;
        } else /*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/ {
            doOpt = true;
        }

        //rewriteDex()负责重写Dex文件，比如4字节对齐，结构重排，字节码优化等
        success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,
                    doVerify, doOpt, &amp;pClassLookup, NULL);

        if (success) {
            DvmDex* pDvmDex = NULL;

            //Dex文件在内存中真实的地址
            u1* dexAddr = ((u1*) mapAddr) + dexOffset;

            //整体dump的脱壳点
            //早期的部分壳可以，比如爱加密，过一下TracerPid反调试就可以整体dump了
            //那是多么幸福的脱壳年代，没有类抽取，没有VMP
            if (dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex) != 0) {
                ALOGE(&quot;Unable to create DexFile&quot;);
                success = false;
            } else {
                if (gDvm.generateRegisterMaps) {
                    //这个结构体用于Precise GC(精确垃圾回收)
                    //少有文章讲这个，能搜到的文章都是简单的提了一句，有必要跟着代码分析一遍
                    //太长不看版：RegisterMap以Method为单位，模拟指令执行，判断是否指向对象
                    //Dalvik虚拟机在执行GC的时候，就可以确定哪些是可以回收的，哪些是不能回收的
                    pRegMapBuilder = dvmGenerateRegisterMaps(pDvmDex);
                    if (pRegMapBuilder == NULL) {
                        ALOGE(&quot;Failed generating register maps&quot;);
                        success = false;
                    }
                }

                //更新dexAddr指向的Dex文件的checksum
                DexHeader* pHeader = (DexHeader*)pDvmDex-&gt;pHeader;
                updateChecksum(dexAddr, dexLength, pHeader);

                //这一段对于ODex文件的操作完成，释放pDvmDex
                dvmDexFileFree(pDvmDex);
            }
        }

        //强行将映射区的数据写回文件，原先这片区域是SHARED，也会进行同步
        if (msync(mapAddr, dexOffset + dexLength, MS_SYNC) != 0) {
            ALOGW(&quot;msync failed: %s&quot;, strerror(errno));
        }
#if 1
        //释放掉映射的内存空间
        if (munmap(mapAddr, dexOffset + dexLength) != 0) {
            ALOGE(&quot;munmap failed: %s&quot;, strerror(errno));
            goto bail;
        }
#endif

        if (!success)
            goto bail;
    }

    off_t depsOffset, optOffset, endOffset, adjOffset;
    int depsLength, optLength;
    u4 optChecksum;

    //ODex文件的Dex段后面是依赖段
    depsOffset = lseek(fd, 0, SEEK_END);
    if (depsOffset &lt; 0) {
        ALOGE(&quot;lseek to EOF failed: %s&quot;, strerror(errno));
        goto bail;
    }

    //调整依赖段的起始偏移，八字节对齐
    adjOffset = (depsOffset + 7) &amp; ~(0x07);
    if (adjOffset != depsOffset) {
        ALOGV(&quot;Adjusting deps start from %d to %d&quot;,
            (int) depsOffset, (int) adjOffset);
        depsOffset = adjOffset;
        lseek(fd, depsOffset, SEEK_SET);
    }

    //把依赖段的数据写进去
    if (writeDependencies(fd, modWhen, crc) != 0) {
        ALOGW(&quot;Failed writing dependencies&quot;);
        goto bail;
    }

    //计算依赖段的长度，然后再设置opt段八字节对齐
    optOffset = lseek(fd, 0, SEEK_END);
    depsLength = optOffset - depsOffset;

    adjOffset = (optOffset + 7) &amp; ~(0x07);
    if (adjOffset != optOffset) {
        ALOGV(&quot;Adjusting opt start from %d to %d&quot;,
            (int) optOffset, (int) adjOffset);
        optOffset = adjOffset;
        lseek(fd, optOffset, SEEK_SET);
    }

    //写优化段的数据
    if (!writeOptData(fd, pClassLookup, pRegMapBuilder)) {
        ALOGW(&quot;Failed writing opt data&quot;);
        goto bail;
    }

    endOffset = lseek(fd, 0, SEEK_END);
    optLength = endOffset - optOffset;

    //计算checksum
    if (!computeFileChecksum(fd, depsOffset,
            (optOffset+optLength) - depsOffset, &amp;optChecksum))
    {
        goto bail;
    }

    //填充ODex Header
    DexOptHeader optHdr;
    memset(&amp;optHdr, 0xff, sizeof(optHdr));
    memcpy(optHdr.magic, DEX_OPT_MAGIC, 4);
    memcpy(optHdr.magic+4, DEX_OPT_MAGIC_VERS, 4);
    optHdr.dexOffset = (u4) dexOffset;
    optHdr.dexLength = (u4) dexLength;
    optHdr.depsOffset = (u4) depsOffset;
    optHdr.depsLength = (u4) depsLength;
    optHdr.optOffset = (u4) optOffset;
    optHdr.optLength = (u4) optLength;
#if __BYTE_ORDER != __LITTLE_ENDIAN
    optHdr.flags = DEX_OPT_FLAG_BIG;
#else
    optHdr.flags = 0;
#endif
    optHdr.checksum = optChecksum;

    //同步数据
    fsync(fd);      

    //把刚才的ODex Header结构体的数据写进ODex文件
    lseek(fd, 0, SEEK_SET);
    if (sysWriteFully(fd, &amp;optHdr, sizeof(optHdr), &quot;DexOpt opt header&quot;) != 0)
        goto bail;

    ALOGV(&quot;Successfully wrote DEX header&quot;);
    result = true;

    //dvmRegisterMapDumpStats();

bail:
    dvmFreeRegisterMapBuilder(pRegMapBuilder);
    free(pClassLookup);
    return result;
}
</code></pre><p>这个函数执行完，ODex文件也就优化的差不多了</p>
<p>其中有几个函数需要进一步跟进</p>
<pre><code>- rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &amp;pClassLookup, NULL)
- dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex)
- dvmGenerateRegisterMaps(pDvmDex)
- writeDependencies(fd, modWhen, crc)
- writeOptData(fd, pClassLookup, pRegMapBuilder)
</code></pre><p>看来是要再写一篇了</p>
<h2 id="0x02-">0x02 小结</h2>
<p>好好学习，天天向上，友情提示，我用的是Dalvik虚拟机，不是ART</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
