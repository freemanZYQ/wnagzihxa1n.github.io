<!DOCTYPE html>
<html>
<head>
<title>ELF格式与解析</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="elf-">ELF格式与解析</h1>
<p><strong>Author:wnagzihxa1n<br>E-Mail:wnagzihxa1n@gmail.com</strong></p>
<h2 id="0x00-">0x00 前言</h2>
<p>这里说的ELF是指NDK开发时的so文件，这是Android Native逆向基础知识点，也是搞壳的一个关键</p>
<h2 id="0x01-">0x01 整体的结构解析</h2>
<p>来自非虫的一张图片</p>
<p><img src="Image/1.png" alt=""></p>
<p>在ELF中使用如下的数据类型定义，同时也有64位的定义，本文以32位的为例进行知识的分享</p>
<pre><code>/* 32-bit ELF base types. */
typedef uint32_t Elf32_Addr;
typedef uint16_t Elf32_Half;
typedef uint32_t Elf32_Off;
typedef int32_t  Elf32_Sword;
typedef uint32_t Elf32_Word;
</code></pre><p>使用一个很简单的so作为样本来分析，我们先来看这个ELF的文件头信息，这里存储着整体的数据划分</p>
<pre><code>$ readelf -h libtotoc.so
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          52 (bytes into file)
  Start of section headers:          12660 (bytes into file)
  Flags:                             0x5000200, Version5 EABI, soft-float ABI
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         26
  Section header string table index: 25
</code></pre><p>不按顺序进行拆分，<code>ELF32_Header</code>结构体如下</p>
<pre><code>typedef struct elf32_hdr {
    unsigned char    e_ident[EI_NIDENT];  //魔数以及一些版本信息
    Elf32_Half    e_type;     //文件类型
    Elf32_Half    e_machine;  //架构
    Elf32_Word    e_version;  //文件版本
    Elf32_Addr    e_entry;    /* Entry point */
    Elf32_Off     e_phoff;    //Program Header Offset
    Elf32_Off     e_shoff;    //Section Header Offset
    Elf32_Word    e_flags;    //
    Elf32_Half    e_ehsize;   //ELF Header Size
    Elf32_Half    e_phentsize;//Program Header Size
    Elf32_Half    e_phnum;    //Program Header Number
    Elf32_Half    e_shentsize;//Section Header Size
    Elf32_Half    e_shnum;    //Section Header Number 
    Elf32_Half    e_shstrndx; //字符串池在段列表的索引
} Elf32_Ehdr;
</code></pre><p>对照着本ELF样本的数据进行解析</p>
<pre><code>bool ParseELFHeader(FILE* fp_elf)
{
    int32_t dwSizeofStructElf32_Ehdr = sizeof(Elf32_Ehdr);
    printf(&quot;The size of STRUCT Elf32_Ehdr is %d\n&quot;, dwSizeofStructElf32_Ehdr);
    e32_hdr = (Elf32_Ehdr*) malloc(dwSizeofStructElf32_Ehdr);
    if (e32_hdr == NULL)
    {
        perror(&quot;Malloc e32_hdr&#39;s memory failed&quot;);
        exit(1);
    }
    memset(e32_hdr, 0, dwSizeofStructElf32_Ehdr);
    fseek(fp_elf, 0, SEEK_SET);
    int32_t READ_COUNT = fread((uint8_t*) e32_hdr, sizeof(uint8_t), dwSizeofStructElf32_Ehdr, fp_elf);
    //cout &lt;&lt; READ_COUNT &lt;&lt; endl;

    cout &lt;&lt; &quot;####################ELF Header####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;ELF Header:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Magic                                   :&quot; &lt;&lt; e32_hdr-&gt;e_ident &lt;&lt; endl;
    cout &lt;&lt; &quot;Type                                    :&quot; &lt;&lt; e32_hdr-&gt;e_type &lt;&lt; endl;
    cout &lt;&lt; &quot;Machine                                 :&quot; &lt;&lt; e32_hdr-&gt;e_machine &lt;&lt; endl;
    cout &lt;&lt; &quot;Version                                 :&quot; &lt;&lt; e32_hdr-&gt;e_version &lt;&lt; endl;
    cout &lt;&lt; &quot;Entry point address                     :&quot; &lt;&lt; e32_hdr-&gt;e_entry &lt;&lt; endl;
    cout &lt;&lt; &quot;Start of program headers                :&quot; &lt;&lt; e32_hdr-&gt;e_phoff &lt;&lt; endl;
    cout &lt;&lt; &quot;Start of section headers                :&quot; &lt;&lt; e32_hdr-&gt;e_shoff &lt;&lt; endl;
    cout &lt;&lt; &quot;Flags                                   :&quot; &lt;&lt; e32_hdr-&gt;e_flags &lt;&lt; endl;
    cout &lt;&lt; &quot;Size of this headerSize of this header  :&quot; &lt;&lt; e32_hdr-&gt;e_ehsize &lt;&lt; endl;
    cout &lt;&lt; &quot;Size of program headers                 :&quot; &lt;&lt; e32_hdr-&gt;e_phentsize &lt;&lt; endl;
    cout &lt;&lt; &quot;Number of program headers               :&quot; &lt;&lt; e32_hdr-&gt;e_phnum &lt;&lt; endl;
    cout &lt;&lt; &quot;Size of section headers                 :&quot; &lt;&lt; e32_hdr-&gt;e_shentsize &lt;&lt; endl;
    cout &lt;&lt; &quot;Number of section headers               :&quot; &lt;&lt; e32_hdr-&gt;e_shnum &lt;&lt; endl;
    cout &lt;&lt; &quot;Section header string table index       :&quot; &lt;&lt; e32_hdr-&gt;e_shstrndx &lt;&lt; endl;

    cout &lt;&lt; endl;
    return true;
}
</code></pre><p>对于那些需要转换的部分比如第一个成员写的粗糙了点，这里仅做数据的读取以及简单的输出测试，在后面会进行详细的信息输出处理和优化</p>
<pre><code>The size of STRUCT Elf32_Ehdr is 52
####################ELF Header Start####################
ELF Header:
    Magic                                   :ELF
    Type                                    :3
    Machine                                 :40
    Version                                 :1
    Entry point address                     :0
    Start of program headers                :52
    Start of section headers                :12660
    Flags                                   :83886592
    Size of this headerSize of this header  :52
    Size of program headers                 :32
    Number of program headers               :9
    Size of section headers                 :40
    Number of section headers               :26
    Section header string table index       :25
</code></pre><p>头部给了两组比较有用的信息<code>Program Headers</code>和<code>Section Headers</code>，并且这两组的信息也很详细</p>
<pre><code>Start of program headers                :52
Size of program headers                 :32
Number of program headers               :9

Start of section headers                :12660
Size of section headers                 :40
Number of section headers               :26
</code></pre><p>查看<code>Program Headers</code></p>
<pre><code>$ readelf -l libtotoc.so

Elf file type is DYN (Shared object file)
Entry point 0x0
There are 9 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x00000034 0x00000034 0x00120 0x00120 R   0x4
  INTERP         0x000154 0x00000154 0x00000154 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /system/bin/linker]
  LOAD           0x000000 0x00000000 0x00000000 0x02450 0x02450 R E 0x1000
  LOAD           0x002e78 0x00003e78 0x00003e78 0x0018c 0x0018c RW  0x1000
  DYNAMIC        0x002e84 0x00003e84 0x00003e84 0x00138 0x00138 RW  0x4
  NOTE           0x000168 0x00000168 0x00000168 0x00024 0x00024 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0
  EXIDX          0x002338 0x00002338 0x00002338 0x00108 0x00108 R   0x4
  GNU_RELRO      0x002e78 0x00003e78 0x00003e78 0x00188 0x00188 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.gnu.build-id .dynsym .dynstr .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.extab .ARM.exidx .rodata
   03     .fini_array .init_array .dynamic .got .data
   04     .dynamic
   05     .note.gnu.build-id
   06
   07     .ARM.exidx
   08     .fini_array .init_array .dynamic .got
</code></pre><p>我们先来解析<code>Program Headers</code>，因为这是一个Table，在这个样本里就有9个<code>Elf32_Phdr</code>类型的结构体，这9个结构体组成了<code>Program Headers Table</code>，那么在这里我使用<code>vector</code>来存储</p>
<pre><code>bool ParseProgramHeadersTable(FILE* fp_elf)
{
    fseek(fp_elf, e32_hdr-&gt;e_phoff, SEEK_SET);
    Elf32_Phdr* e32_phdr_temp = NULL;
    e32_phdr_temp = (Elf32_Phdr*) malloc(sizeof(Elf32_Phdr));
    e32_phdr_VECTOR.clear();
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_phnum; i++)
    {
        memset(e32_phdr_temp, 0, sizeof(Elf32_Phdr));
        int32_t READ_COUNT = fread((uint8_t*) e32_phdr_temp, sizeof(uint8_t), e32_hdr-&gt;e_phentsize, fp_elf);
        e32_phdr_VECTOR.push_back((Elf32_Phdr) *e32_phdr_temp);
    }

    cout &lt;&lt; &quot;####################ELF Program Headers####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Program Headers:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Type           Offset       VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align&quot; &lt;&lt; endl;
    for (int32_t i = 0; i &lt; e32_phdr_VECTOR.size(); i++)
    {
        printf(&quot;%d     &quot;, e32_phdr_VECTOR[i].p_type);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_offset);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_vaddr);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_paddr);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_filesz);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_memsz);
        printf(&quot;%d     &quot;, e32_phdr_VECTOR[i].p_flags);
        printf(&quot;%d     \n&quot;, e32_phdr_VECTOR[i].p_align);
    }
    free(e32_phdr_temp);
    e32_phdr_temp = NULL;
    return true;
}
</code></pre><p>输出，部分宏还有待优化输出</p>
<pre><code>####################ELF Program Headers####################
Program Headers:
Type           Offset       VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
6     0x00000034   0x00000034   0x00000034   0x00000120   0x00000120   4     4
3     0x00000154   0x00000154   0x00000154   0x00000013   0x00000013   4     1
1     0x00000000   0x00000000   0x00000000   0x00002450   0x00002450   5     4096
1     0x00002E78   0x00003E78   0x00003E78   0x0000018C   0x0000018C   6     4096
2     0x00002E84   0x00003E84   0x00003E84   0x00000138   0x00000138   6     4
4     0x00000168   0x00000168   0x00000168   0x00000024   0x00000024   4     4
1685382481     0x00000000   0x00000000   0x00000000   0x00000000   0x00000000   6     0
1879048193     0x00002338   0x00002338   0x00002338   0x00000108   0x00000108   4     4
1685382482     0x00002E78   0x00003E78   0x00003E78   0x00000188   0x00000188   6     4
</code></pre><p>另一个是<code>Section Headers</code></p>
<pre><code>$ readelf -S libtotoc.so
There are 26 section headers, starting at offset 0x3174:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        00000154 000154 000013 00   A  0   0  1
  [ 2] .note.gnu.build-i NOTE            00000168 000168 000024 00   A  0   0  4
  [ 3] .dynsym           DYNSYM          0000018c 00018c 000380 10   A  4   1  4
  [ 4] .dynstr           STRTAB          0000050c 00050c 00053e 00   A  0   0  1
  [ 5] .hash             HASH            00000a4c 000a4c 00017c 04   A  3   0  4
  [ 6] .gnu.version      VERSYM          00000bc8 000bc8 000070 02   A  3   0  2
  [ 7] .gnu.version_d    VERDEF          00000c38 000c38 00001c 00   A  4   1  4
  [ 8] .gnu.version_r    VERNEED         00000c54 000c54 000030 00   A  4   1  4
  [ 9] .rel.dyn          REL             00000c84 000c84 000040 08   A  3   0  4
  [10] .rel.plt          REL             00000cc4 000cc4 000038 08  AI  3  11  4
  [11] .plt              PROGBITS        00000cfc 000cfc 000068 00  AX  0   0  4
  [12] .text             PROGBITS        00000d64 000d64 00158c 00  AX  0   0  4
  [13] .ARM.extab        PROGBITS        000022f0 0022f0 000048 00   A  0   0  4
  [14] .ARM.exidx        ARM_EXIDX       00002338 002338 000108 08  AL 12   0  4
  [15] .rodata           PROGBITS        00002440 002440 000010 01 AMS  0   0  1
  [16] .fini_array       FINI_ARRAY      00003e78 002e78 000008 00  WA  0   0  4
  [17] .init_array       INIT_ARRAY      00003e80 002e80 000004 00  WA  0   0  1
  [18] .dynamic          DYNAMIC         00003e84 002e84 000138 08  WA  4   0  4
  [19] .got              PROGBITS        00003fbc 002fbc 000044 00  WA  0   0  4
  [20] .data             PROGBITS        00004000 003000 000004 00  WA  0   0  4
  [21] .bss              NOBITS          00004004 003004 000000 00  WA  0   0  1
  [22] .comment          PROGBITS        00000000 003004 000028 01  MS  0   0  1
  [23] .note.gnu.gold-ve NOTE            00000000 00302c 00001c 00      0   0  4
  [24] .ARM.attributes   ARM_ATTRIBUTES  00000000 003048 00002b 00      0   0  1
  [25] .shstrtab         STRTAB          00000000 003073 0000fe 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</code></pre><p>同样使用<code>vector</code>存储每一个<code>Elf32_Shdr</code>类型的结构体</p>
<pre><code>bool ParseSectionHeadersTable(FILE* fp_elf)
{
    fseek(fp_elf, e32_hdr-&gt;e_shoff, SEEK_SET);
    Elf32_Shdr* e32_shdr_temp = NULL;
    e32_shdr_temp = (Elf32_Shdr*) malloc(sizeof(Elf32_Shdr));
    e32_shdr_VECTOR.clear();
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_shnum; i++)
    {
        memset(e32_shdr_temp, 0, sizeof(Elf32_Shdr));
        int32_t READ_COUNT = fread((uint8_t*) e32_shdr_temp, sizeof(uint8_t), e32_hdr-&gt;e_shentsize, fp_elf);
        e32_shdr_VECTOR.push_back((Elf32_Shdr) *e32_shdr_temp);
    }

    cout &lt;&lt; &quot;####################ELF Section Headers Table####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Section Headers:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;[Nr] Name              Type            Addr       Off        Size       ES Flg Lk Inf Al&quot; &lt;&lt; endl;
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_shnum; i++)
    {
        printf(&quot;[%2d] &quot;, i);
        printf(&quot;%-17d &quot;, e32_shdr_VECTOR[i].sh_name);
        printf(&quot;%-15d &quot;, e32_shdr_VECTOR[i].sh_type);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_addr);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_offset);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_size);
        printf(&quot;%02x &quot;, e32_shdr_VECTOR[i].sh_entsize);
        printf(&quot;%02d  &quot;, e32_shdr_VECTOR[i].sh_flags);
        printf(&quot;%02d &quot;, e32_shdr_VECTOR[i].sh_link);
        printf(&quot;%02d &quot;, e32_shdr_VECTOR[i].sh_info);
        printf(&quot;%02d\n&quot;, e32_shdr_VECTOR[i].sh_addralign);
    }
    return true;
}
</code></pre><p>解析输出，有些宏未修复，不过为了好看，我做了对齐处理~~~</p>
<pre><code>####################ELF Section Headers Table####################
Section Headers:
[Nr] Name              Type            Addr       Off        Size       ES Flg Lk Inf Al
[ 0] 0                 0               0x00000000 0x00000000 0x00000000 00 00  00 00 00
[ 1] 11                1               0x00000154 0x00000154 0x00000013 00 02  00 00 01
[ 2] 19                7               0x00000168 0x00000168 0x00000024 00 02  00 00 04
[ 3] 38                11              0x0000018C 0x0000018C 0x00000380 10 02  04 01 04
[ 4] 46                3               0x0000050C 0x0000050C 0x0000053E 00 02  00 00 01
[ 5] 54                5               0x00000A4C 0x00000A4C 0x0000017C 04 02  03 00 04
[ 6] 60                1879048191      0x00000BC8 0x00000BC8 0x00000070 02 02  03 00 02
[ 7] 73                1879048189      0x00000C38 0x00000C38 0x0000001C 00 02  04 01 04
[ 8] 88                1879048190      0x00000C54 0x00000C54 0x00000030 00 02  04 01 04
[ 9] 103               9               0x00000C84 0x00000C84 0x00000040 08 02  03 00 04
[10] 112               9               0x00000CC4 0x00000CC4 0x00000038 08 66  03 11 04
[11] 116               1               0x00000CFC 0x00000CFC 0x00000068 00 06  00 00 04
[12] 121               1               0x00000D64 0x00000D64 0x0000158C 00 06  00 00 04
[13] 127               1               0x000022F0 0x000022F0 0x00000048 00 02  00 00 04
[14] 138               1879048193      0x00002338 0x00002338 0x00000108 08 130  12 00 04
[15] 149               1               0x00002440 0x00002440 0x00000010 01 50  00 00 01
[16] 157               15              0x00003E78 0x00002E78 0x00000008 00 03  00 00 04
[17] 169               14              0x00003E80 0x00002E80 0x00000004 00 03  00 00 01
[18] 181               6               0x00003E84 0x00002E84 0x00000138 08 03  04 00 04
[19] 190               1               0x00003FBC 0x00002FBC 0x00000044 00 03  00 00 04
[20] 195               1               0x00004000 0x00003000 0x00000004 00 03  00 00 04
[21] 201               8               0x00004004 0x00003004 0x00000000 00 03  00 00 01
[22] 206               1               0x00000000 0x00003004 0x00000028 01 48  00 00 01
[23] 215               7               0x00000000 0x0000302C 0x0000001C 00 00  00 00 04
[24] 238               1879048195      0x00000000 0x00003048 0x0000002B 00 00  00 00 01
[25] 1                 3               0x00000000 0x00003073 0x000000FE 00 00  00 00 01
</code></pre><p>犯了一个小小的错误，应该先解析一波字符串的。。。。。。</p>
<p>现在我们已经解析出了比较重要的三个结构体：<code>Elf32_Ehdr</code>，<code>Elf32_Phdr</code>，<code>Elf32_Shdr</code></p>
<p>不过由于前面写的代码比较粗糙，所以我们现在来优化一下输出，让它看起来和<code>readelf</code>像一点</p>
<p>首先是<code>Elf32_Ehdr</code>，把一些宏对应的给输出了</p>
<pre><code>bool ParseELFHeader(FILE* fp_elf)
{
    int32_t dwSizeofStructElf32_Ehdr = sizeof(Elf32_Ehdr);
    printf(&quot;The size of STRUCT Elf32_Ehdr is %d\n&quot;, dwSizeofStructElf32_Ehdr);
    e32_hdr = (Elf32_Ehdr*) malloc(dwSizeofStructElf32_Ehdr);
    if (e32_hdr == NULL)
    {
        perror(&quot;Malloc e32_hdr&#39;s memory failed&quot;);
        exit(1);
    }
    memset(e32_hdr, 0, dwSizeofStructElf32_Ehdr);
    fseek(fp_elf, 0, SEEK_SET);
    int32_t READ_COUNT = fread((uint8_t*) e32_hdr, sizeof(uint8_t), dwSizeofStructElf32_Ehdr, fp_elf);
    //cout &lt;&lt; READ_COUNT &lt;&lt; endl;

    LPSTR ELFFILETYPE[] = {&quot;ET_NONE&quot;, &quot;ET_REL&quot;, &quot;ET_EXEC&quot;, &quot;ET_DYN(Shared object file)&quot;, &quot;ET_CORE&quot;};

    string ELFTARGETMACHINE_Pre[23] = {&quot;EM_NONE&quot;, &quot;EM_M32&quot;, &quot;EM_SPARC&quot;, &quot;EM_386&quot;, &quot;EM_68K&quot;, &quot;EM_88K&quot;, 
        &quot;EM_486&quot;, &quot;EM_860&quot;, &quot;EM_MIPS&quot;, &quot;UNKNOWN&quot;, &quot;EM_MIPS_RS4_BE&quot;, 
        &quot;UNKNOWN&quot;, &quot;UNKNOWN&quot;, &quot;UNKNOWN&quot;, &quot;UNKNOWN&quot;, &quot;EM_PARISC&quot;, &quot;UNKNOWN&quot;, 
        &quot;UNKNOWN&quot;, &quot;EM_SPARC32PLUS&quot;, &quot;UNKNOWN&quot;, &quot;EM_PPC&quot;, &quot;EM_PPC64&quot;, &quot;EM_S390&quot;};
    map &lt;int32_t, string&gt; ELFTARGETMACHINE;
    printf(&quot;%d\n&quot;, sizeof(ELFTARGETMACHINE_Pre) / sizeof(ELFTARGETMACHINE_Pre[0]));
    for (int32_t i = 0; i &lt; sizeof(ELFTARGETMACHINE_Pre) / sizeof(ELFTARGETMACHINE_Pre[0]); i++)
    {
        ELFTARGETMACHINE.insert(make_pair(0, ELFTARGETMACHINE_Pre[i]));
    }
    ELFTARGETMACHINE.insert(make_pair(40, &quot;EM_ARM&quot;));
    ELFTARGETMACHINE.insert(make_pair(42, &quot;EM_SH&quot;));
    ELFTARGETMACHINE.insert(make_pair(43, &quot;EM_SPARCV9&quot;));
    ELFTARGETMACHINE.insert(make_pair(47, &quot;EM_H8_300H&quot;));
    ELFTARGETMACHINE.insert(make_pair(48, &quot;EM_H8S&quot;));
    ELFTARGETMACHINE.insert(make_pair(50, &quot;EM_IA_64&quot;));
    ELFTARGETMACHINE.insert(make_pair(62, &quot;EM_X86_64&quot;));
    ELFTARGETMACHINE.insert(make_pair(76, &quot;EM_CRIS&quot;));
    ELFTARGETMACHINE.insert(make_pair(87, &quot;EM_V850&quot;));    

    cout &lt;&lt; &quot;####################ELF Header####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;ELF Header:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Magic                                 : &quot; 
        &lt;&lt; e32_hdr-&gt;e_ident[EI_MAG0]
        &lt;&lt; e32_hdr-&gt;e_ident[EI_MAG1]
        &lt;&lt; e32_hdr-&gt;e_ident[EI_MAG2]
        &lt;&lt; e32_hdr-&gt;e_ident[EI_MAG3] &lt;&lt; endl;
    printf(&quot;Class                                 : %s\n&quot;, ((int32_t) e32_hdr-&gt;e_ident[4] == 0) ? &quot;Invalid&quot; : ((int32_t) e32_hdr-&gt;e_ident[4] == 1) ? &quot;ELF32&quot; : &quot;ELF64&quot;);
    printf(&quot;Data                                  : %s\n&quot;, ((int32_t) e32_hdr-&gt;e_ident[5] == 0) ? &quot;Invalid&quot; : ((int32_t) e32_hdr-&gt;e_ident[5] == 1) ? &quot;little endian&quot; : &quot;big endian&quot;);
    printf(&quot;Version                               : %d (current)\n&quot;, (int32_t)e32_hdr-&gt;e_ident[6]);
    printf(&quot;OS / ABI                              : %d\n&quot;, e32_hdr-&gt;e_ident);
    printf(&quot;Type                                  : %s\n&quot;, (e32_hdr-&gt;e_type) &lt; 5 ? ELFFILETYPE[e32_hdr-&gt;e_type] : (e32_hdr-&gt;e_type == 0xff00) ? &quot;ET_LOPROC&quot; : &quot;ET_HIPROC&quot;);
    printf(&quot;Machine                               : %s\n&quot;, ELFTARGETMACHINE[e32_hdr-&gt;e_machine].c_str());
    printf(&quot;Version                               : 0x%x\n&quot;, e32_hdr-&gt;e_version);
    printf(&quot;Entry point address                   : 0x%x\n&quot;, e32_hdr-&gt;e_entry);
    printf(&quot;Start of program headers              : %d (bytes into file)\n&quot;, e32_hdr-&gt;e_phoff);
    printf(&quot;Start of section headers              : %d (bytes into file)\n&quot;, e32_hdr-&gt;e_shoff);
    printf(&quot;Flags                                 : %d\n&quot;, e32_hdr-&gt;e_flags);
    printf(&quot;Size of this header                   : %d (bytes)\n&quot;, e32_hdr-&gt;e_ehsize);
    printf(&quot;Size of program headers               : %d (bytes)\n&quot;, e32_hdr-&gt;e_phentsize);
    printf(&quot;Number of program headers             : %d\n&quot;, e32_hdr-&gt;e_phnum);
    printf(&quot;Size of section headers               : %d (bytes)\n&quot;, e32_hdr-&gt;e_shentsize);
    printf(&quot;Number of section headers             : %d\n&quot;, e32_hdr-&gt;e_shnum);
    printf(&quot;Section header string table index     : %d\n&quot;, e32_hdr-&gt;e_shstrndx);

    cout &lt;&lt; endl;
    return true;
}
</code></pre><p>输出效果，可以说和<code>readelf -h libtotoc.so</code>很像了</p>
<pre><code>####################ELF Header####################
ELF Header:
Magic                                 : ELF
Class                                 : ELF32
Data                                  : little endian
Version                               : 1 (current)
OS / ABI                              : 24133544
Type                                  : ET_DYN(Shared object file)
Machine                               : EM_ARM
Version                               : 0x1
Entry point address                   : 0x0
Start of program headers              : 52 (bytes into file)
Start of section headers              : 12660 (bytes into file)
Flags                                 : 83886592
Size of this header                   : 52 (bytes)
Size of program headers               : 32 (bytes)
Number of program headers             : 9
Size of section headers               : 40 (bytes)
Number of section headers             : 26
Section header string table index     : 25
</code></pre><p><code>Program Headers Table</code>除了对其之外，修改的相对较少，<code>Flg</code>字段是权限，用的方式是数字表示法，<code>RWE</code>对应<code>421</code></p>
<pre><code>bool ParseProgramHeadersTable(FILE* fp_elf)
{
    fseek(fp_elf, e32_hdr-&gt;e_phoff, SEEK_SET);
    Elf32_Phdr* e32_phdr_temp = NULL;
    e32_phdr_temp = (Elf32_Phdr*) malloc(sizeof(Elf32_Phdr));
    e32_phdr_VECTOR.clear();
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_phnum; i++)
    {
        memset(e32_phdr_temp, 0, sizeof(Elf32_Phdr));
        int32_t READ_COUNT = fread((uint8_t*) e32_phdr_temp, sizeof(uint8_t), e32_hdr-&gt;e_phentsize, fp_elf);
        e32_phdr_VECTOR.push_back((Elf32_Phdr) *e32_phdr_temp);
    }

    string ELFSEGMENTTYPE_Pre[7] = {&quot;PT_NULL&quot;, &quot;PT_LOAD&quot;, &quot;PT_DYNAMIC&quot;, &quot;PT_INTERP&quot;, &quot;PT_NOTE&quot;, &quot;PT_SHLIB&quot;, &quot;PT_PHDR&quot;};
    map &lt;int32_t, string&gt; ELFSEGMENTTYPE;
    for (int32_t i = 0; i &lt; sizeof(ELFSEGMENTTYPE_Pre) / sizeof(ELFSEGMENTTYPE_Pre[0]); i++)
    {
        ELFSEGMENTTYPE.insert(make_pair(i, ELFSEGMENTTYPE_Pre[i]));
    }
    ELFSEGMENTTYPE.insert(make_pair(0x70000000, &quot;PT_LOPROC&quot;));
    ELFSEGMENTTYPE.insert(make_pair(0x7fffffff, &quot;PT_HIPROC&quot;));
    ELFSEGMENTTYPE.insert(make_pair(0x70000000, &quot;PT_MIPS_REGINFO&quot;));
    ELFSEGMENTTYPE.insert(make_pair(0x70000001, &quot;PT_MIPS_OPTIONS&quot;));

    map &lt;int, string&gt; PROGRAMHEADERSFLAG;
    PROGRAMHEADERSFLAG.insert(make_pair(4, &quot;R  &quot;));
    PROGRAMHEADERSFLAG.insert(make_pair(2, &quot; W&quot;));
    PROGRAMHEADERSFLAG.insert(make_pair(1, &quot;  E&quot;));
    PROGRAMHEADERSFLAG.insert(make_pair(6, &quot;RW &quot;));
    PROGRAMHEADERSFLAG.insert(make_pair(5, &quot;R E&quot;));
    PROGRAMHEADERSFLAG.insert(make_pair(3, &quot; WE&quot;));
    PROGRAMHEADERSFLAG.insert(make_pair(7, &quot;RWE&quot;));

    cout &lt;&lt; &quot;####################ELF Program Headers Table####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Program Headers:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Type            Offset       VirtAddr     PhysAddr     FileSiz      MemSiz       Flg   Align&quot; &lt;&lt; endl;
    for (int32_t i = 0; i &lt; e32_phdr_VECTOR.size(); i++)
    {
        printf(&quot;%-16s&quot;, ELFSEGMENTTYPE[e32_phdr_VECTOR[i].p_type].c_str());
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_offset);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_vaddr);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_paddr);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_filesz);
        printf(&quot;0x%p   &quot;, e32_phdr_VECTOR[i].p_memsz);
        printf(&quot;%s   &quot;, PROGRAMHEADERSFLAG[e32_phdr_VECTOR[i].p_flags].c_str());
        printf(&quot;0x%x\n&quot;, e32_phdr_VECTOR[i].p_align);
    }
    free(e32_phdr_temp);
    e32_phdr_temp = NULL;
    cout &lt;&lt; endl;
    return true;
}
</code></pre><p>最后一个是<code>Section Headers Table</code>，这一部分需要用到字符串，所以我们需要先处理一下字符串相关的数据</p>
<p>在ELF文件中，字符串池单独为一个Section，而且存储方式是使用index配合<code>\0</code>来表示一个字符串</p>
<pre><code>memset(lpStringBuffer, 0, strlen(lpStringBuffer));
int index = 0;
fseek(fp_elf, 0, SEEK_SET);
fseek(fp_elf, STRING_Offset + e32_shdr_VECTOR[i].sh_name, SEEK_SET);
while (fread(lpStringBuffer + index, 1, 1, fp_elf))
{
    if (*(lpStringBuffer + index++) == &#39;\0&#39;)
    {
        break;
    }
}
</code></pre><p>这里强行设1024可能会导致一个堆溢出，大家注意一下。。。。。。</p>
<pre><code>bool ParseSectionHeadersTable(FILE* fp_elf)
{
    fseek(fp_elf, e32_hdr-&gt;e_shoff, SEEK_SET);
    Elf32_Shdr* e32_shdr_temp = NULL;
    e32_shdr_temp = (Elf32_Shdr*) malloc(sizeof(Elf32_Shdr));
    e32_shdr_VECTOR.clear();
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_shnum; i++)
    {
        memset(e32_shdr_temp, 0, sizeof(Elf32_Shdr));
        int32_t READ_COUNT = fread((uint8_t*) e32_shdr_temp, sizeof(uint8_t), e32_hdr-&gt;e_shentsize, fp_elf);
        e32_shdr_VECTOR.push_back((Elf32_Shdr) *e32_shdr_temp);
    }

    cout &lt;&lt; &quot;####################ELF Section Headers Table####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Section Headers:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;[Nr] Name              Type            Addr       Off        Size       ES Flg Lk Inf Al&quot; &lt;&lt; endl;

    int32_t STRING_Offset = e32_shdr_VECTOR[e32_hdr-&gt;e_shstrndx].sh_offset;
    //printf(&quot;%d\n&quot;, STRING_Offset);

    char* lpStringBuffer = NULL;
    lpStringBuffer = (char*) malloc(1024);
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_shnum; i++)
    {
        printf(&quot;[%2d] &quot;, i);
        memset(lpStringBuffer, 0, strlen(lpStringBuffer));
        int index = 0;
        fseek(fp_elf, 0, SEEK_SET);
        fseek(fp_elf, STRING_Offset + e32_shdr_VECTOR[i].sh_name, SEEK_SET);
        while (fread(lpStringBuffer + index, 1, 1, fp_elf))
        {
            if (*(lpStringBuffer + index++) == &#39;\0&#39;)
            {
                break;
            }
        }
        printf(&quot;%-17s &quot;, lpStringBuffer);
        printf(&quot;%-15d &quot;, e32_shdr_VECTOR[i].sh_type);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_addr);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_offset);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_size);
        printf(&quot;%02x &quot;, e32_shdr_VECTOR[i].sh_entsize);
        printf(&quot;%02d  &quot;, e32_shdr_VECTOR[i].sh_flags);
        printf(&quot;%02d &quot;, e32_shdr_VECTOR[i].sh_link);
        printf(&quot;%02d &quot;, e32_shdr_VECTOR[i].sh_info);
        printf(&quot;%02d\n&quot;, e32_shdr_VECTOR[i].sh_addralign);
    }
    free(lpStringBuffer);
    free(e32_shdr_temp);
    lpStringBuffer = NULL;
    e32_shdr_temp = NULL;
    cout &lt;&lt; endl;
    return true;
}
</code></pre><p>输出后</p>
<pre><code>####################ELF Section Headers Table####################
Section Headers:
[Nr] Name              Type            Addr       Off        Size       ES Flg Lk Inf Al
[ 0]                   0               0x00000000 0x00000000 0x00000000 00 00  00 00 00
[ 1] .interp           1               0x00000154 0x00000154 0x00000013 00 02  00 00 01
[ 2] .note.gnu.build-id 7               0x00000168 0x00000168 0x00000024 00 02  00 00 04
[ 3] .dynsym           11              0x0000018C 0x0000018C 0x00000380 10 02  04 01 04
[ 4] .dynstr           3               0x0000050C 0x0000050C 0x0000053E 00 02  00 00 01
[ 5] .hash             5               0x00000A4C 0x00000A4C 0x0000017C 04 02  03 00 04
[ 6] .gnu.version      1879048191      0x00000BC8 0x00000BC8 0x00000070 02 02  03 00 02
[ 7] .gnu.version_d    1879048189      0x00000C38 0x00000C38 0x0000001C 00 02  04 01 04
[ 8] .gnu.version_r    1879048190      0x00000C54 0x00000C54 0x00000030 00 02  04 01 04
[ 9] .rel.dyn          9               0x00000C84 0x00000C84 0x00000040 08 02  03 00 04
[10] .rel.plt          9               0x00000CC4 0x00000CC4 0x00000038 08 66  03 11 04
[11] .plt              1               0x00000CFC 0x00000CFC 0x00000068 00 06  00 00 04
[12] .text             1               0x00000D64 0x00000D64 0x0000158C 00 06  00 00 04
[13] .ARM.extab        1               0x000022F0 0x000022F0 0x00000048 00 02  00 00 04
[14] .ARM.exidx        1879048193      0x00002338 0x00002338 0x00000108 08 130  12 00 04
[15] .rodata           1               0x00002440 0x00002440 0x00000010 01 50  00 00 01
[16] .fini_array       15              0x00003E78 0x00002E78 0x00000008 00 03  00 00 04
[17] .init_array       14              0x00003E80 0x00002E80 0x00000004 00 03  00 00 01
[18] .dynamic          6               0x00003E84 0x00002E84 0x00000138 08 03  04 00 04
[19] .got              1               0x00003FBC 0x00002FBC 0x00000044 00 03  00 00 04
[20] .data             1               0x00004000 0x00003000 0x00000004 00 03  00 00 04
[21] .bss              8               0x00004004 0x00003004 0x00000000 00 03  00 00 01
[22] .comment          1               0x00000000 0x00003004 0x00000028 01 48  00 00 01
[23] .note.gnu.gold-version 7               0x00000000 0x0000302C 0x0000001C 00 00  00 00 04
[24] .ARM.attributes   1879048195      0x00000000 0x00003048 0x0000002B 00 00  00 00 01
[25] .shstrtab         3               0x00000000 0x00003073 0x000000FE 00 00  00 00 01
</code></pre><p>接下来进行对其以及其余字段的输出优化</p>
<pre><code>bool ParseSectionHeadersTable(FILE* fp_elf)
{
    fseek(fp_elf, e32_hdr-&gt;e_shoff, SEEK_SET);
    Elf32_Shdr* e32_shdr_temp = NULL;
    e32_shdr_temp = (Elf32_Shdr*) malloc(sizeof(Elf32_Shdr));
    e32_shdr_VECTOR.clear();
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_shnum; i++)
    {
        memset(e32_shdr_temp, 0, sizeof(Elf32_Shdr));
        int32_t READ_COUNT = fread((uint8_t*) e32_shdr_temp, sizeof(uint8_t), e32_hdr-&gt;e_shentsize, fp_elf);
        e32_shdr_VECTOR.push_back((Elf32_Shdr) *e32_shdr_temp);
    }

    string ELFSEGMENTTYPE_Pre[13] = { &quot;SHT_NULL&quot;, &quot;SHT_PROGBITS&quot;, &quot;SHT_SYMTAB&quot;, &quot;SHT_STRTAB&quot;, &quot;SHT_RELA&quot;, &quot;SHT_HASH&quot;, &quot;SHT_DYNAMIC&quot;, &quot;SHT_NOTE&quot;, &quot;SHT_NOBITS&quot;, &quot;SHT_REL&quot;, &quot;SHT_SHLIB&quot;, &quot;SHT_DYNSYM&quot;, &quot;SHT_NUM&quot;};
    map &lt;int32_t, string&gt; ELFSEGMENTTYPE;
    for (int32_t i = 0; i &lt; sizeof(ELFSEGMENTTYPE_Pre) / sizeof(ELFSEGMENTTYPE_Pre[0]); i++)
    {
        ELFSEGMENTTYPE.insert(make_pair(i, ELFSEGMENTTYPE_Pre[i]));
    }
    ELFSEGMENTTYPE.insert(make_pair(0x70000000, &quot;SHT_LOPROC&quot;));
    ELFSEGMENTTYPE.insert(make_pair(0x7fffffff, &quot;SHT_HIPROC&quot;));
    ELFSEGMENTTYPE.insert(make_pair(0x80000000, &quot;SHT_LOUSER&quot;));
    ELFSEGMENTTYPE.insert(make_pair(0xffffffff, &quot;SHT_HIUSER&quot;));

    cout &lt;&lt; &quot;####################ELF Section Headers Table####################&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Section Headers:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;[Nr] Name                     Type            Addr       Off        Size       ES Flg  Lk Inf Al&quot; &lt;&lt; endl;

    int32_t STRING_Offset = e32_shdr_VECTOR[e32_hdr-&gt;e_shstrndx].sh_offset;
    //printf(&quot;%d\n&quot;, STRING_Offset);

    char* lpStringBuffer = NULL;
    lpStringBuffer = (char*) malloc(1024);
    for (int32_t i = 0; i &lt; e32_hdr-&gt;e_shnum; i++)
    {
        printf(&quot;[%2d] &quot;, i);
        memset(lpStringBuffer, 0, strlen(lpStringBuffer));
        int index = 0;
        fseek(fp_elf, 0, SEEK_SET);
        fseek(fp_elf, STRING_Offset + e32_shdr_VECTOR[i].sh_name, SEEK_SET);
        while (fread(lpStringBuffer + index, 1, 1, fp_elf))
        {
            if (*(lpStringBuffer + index++) == &#39;\0&#39;)
            {
                break;
            }
        }
        printf(&quot;%-24s &quot;, lpStringBuffer);
        printf(&quot;%-15s &quot;, ELFSEGMENTTYPE[e32_shdr_VECTOR[i].sh_type].c_str());
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_addr);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_offset);
        printf(&quot;0x%p &quot;, e32_shdr_VECTOR[i].sh_size);
        printf(&quot;%02x &quot;, e32_shdr_VECTOR[i].sh_entsize);
        printf(&quot;%03d  &quot;, e32_shdr_VECTOR[i].sh_flags);
        printf(&quot;%2d &quot;, e32_shdr_VECTOR[i].sh_link);
        printf(&quot;%2d  &quot;, e32_shdr_VECTOR[i].sh_info);
        printf(&quot;%02x\n&quot;, e32_shdr_VECTOR[i].sh_addralign);
    }
    free(lpStringBuffer);
    free(e32_shdr_temp);
    lpStringBuffer = NULL;
    e32_shdr_temp = NULL;
    cout &lt;&lt; endl;
    return true;
}
</code></pre><p>解析效果</p>
<pre><code>####################ELF Section Headers Table####################
Section Headers:
[Nr] Name                     Type            Addr       Off        Size       ES Flg  Lk Inf Al
[ 0]                          SHT_NULL        0x00000000 0x00000000 0x00000000 00 000   0  0  00
[ 1] .interp                  SHT_PROGBITS    0x00000154 0x00000154 0x00000013 00 002   0  0  01
[ 2] .note.gnu.build-id       SHT_NOTE        0x00000168 0x00000168 0x00000024 00 002   0  0  04
[ 3] .dynsym                  SHT_DYNSYM      0x0000018C 0x0000018C 0x00000380 10 002   4  1  04
[ 4] .dynstr                  SHT_STRTAB      0x0000050C 0x0000050C 0x0000053E 00 002   0  0  01
[ 5] .hash                    SHT_HASH        0x00000A4C 0x00000A4C 0x0000017C 04 002   3  0  04
[ 6] .gnu.version                             0x00000BC8 0x00000BC8 0x00000070 02 002   3  0  02
[ 7] .gnu.version_d                           0x00000C38 0x00000C38 0x0000001C 00 002   4  1  04
[ 8] .gnu.version_r                           0x00000C54 0x00000C54 0x00000030 00 002   4  1  04
[ 9] .rel.dyn                 SHT_REL         0x00000C84 0x00000C84 0x00000040 08 002   3  0  04
[10] .rel.plt                 SHT_REL         0x00000CC4 0x00000CC4 0x00000038 08 066   3 11  04
[11] .plt                     SHT_PROGBITS    0x00000CFC 0x00000CFC 0x00000068 00 006   0  0  04
[12] .text                    SHT_PROGBITS    0x00000D64 0x00000D64 0x0000158C 00 006   0  0  04
[13] .ARM.extab               SHT_PROGBITS    0x000022F0 0x000022F0 0x00000048 00 002   0  0  04
[14] .ARM.exidx                               0x00002338 0x00002338 0x00000108 08 130  12  0  04
[15] .rodata                  SHT_PROGBITS    0x00002440 0x00002440 0x00000010 01 050   0  0  01
[16] .fini_array                              0x00003E78 0x00002E78 0x00000008 00 003   0  0  04
[17] .init_array                              0x00003E80 0x00002E80 0x00000004 00 003   0  0  01
[18] .dynamic                 SHT_DYNAMIC     0x00003E84 0x00002E84 0x00000138 08 003   4  0  04
[19] .got                     SHT_PROGBITS    0x00003FBC 0x00002FBC 0x00000044 00 003   0  0  04
[20] .data                    SHT_PROGBITS    0x00004000 0x00003000 0x00000004 00 003   0  0  04
[21] .bss                     SHT_NOBITS      0x00004004 0x00003004 0x00000000 00 003   0  0  01
[22] .comment                 SHT_PROGBITS    0x00000000 0x00003004 0x00000028 01 048   0  0  01
[23] .note.gnu.gold-version   SHT_NOTE        0x00000000 0x0000302C 0x0000001C 00 000   0  0  04
[24] .ARM.attributes                          0x00000000 0x00003048 0x0000002B 00 000   0  0  01
[25] .shstrtab                SHT_STRTAB      0x00000000 0x00003073 0x000000FE 00 000   0  0  01
</code></pre><p>对照<code>readelf -S libtotoc.h</code></p>
<pre><code>$ readelf -S libtotoc.so
There are 26 section headers, starting at offset 0x3174:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        00000154 000154 000013 00   A  0   0  1
  [ 2] .note.gnu.build-i NOTE            00000168 000168 000024 00   A  0   0  4
  [ 3] .dynsym           DYNSYM          0000018c 00018c 000380 10   A  4   1  4
  [ 4] .dynstr           STRTAB          0000050c 00050c 00053e 00   A  0   0  1
  [ 5] .hash             HASH            00000a4c 000a4c 00017c 04   A  3   0  4
  [ 6] .gnu.version      VERSYM          00000bc8 000bc8 000070 02   A  3   0  2
  [ 7] .gnu.version_d    VERDEF          00000c38 000c38 00001c 00   A  4   1  4
  [ 8] .gnu.version_r    VERNEED         00000c54 000c54 000030 00   A  4   1  4
  [ 9] .rel.dyn          REL             00000c84 000c84 000040 08   A  3   0  4
  [10] .rel.plt          REL             00000cc4 000cc4 000038 08  AI  3  11  4
  [11] .plt              PROGBITS        00000cfc 000cfc 000068 00  AX  0   0  4
  [12] .text             PROGBITS        00000d64 000d64 00158c 00  AX  0   0  4
  [13] .ARM.extab        PROGBITS        000022f0 0022f0 000048 00   A  0   0  4
  [14] .ARM.exidx        ARM_EXIDX       00002338 002338 000108 08  AL 12   0  4
  [15] .rodata           PROGBITS        00002440 002440 000010 01 AMS  0   0  1
  [16] .fini_array       FINI_ARRAY      00003e78 002e78 000008 00  WA  0   0  4
  [17] .init_array       INIT_ARRAY      00003e80 002e80 000004 00  WA  0   0  1
  [18] .dynamic          DYNAMIC         00003e84 002e84 000138 08  WA  4   0  4
  [19] .got              PROGBITS        00003fbc 002fbc 000044 00  WA  0   0  4
  [20] .data             PROGBITS        00004000 003000 000004 00  WA  0   0  4
  [21] .bss              NOBITS          00004004 003004 000000 00  WA  0   0  1
  [22] .comment          PROGBITS        00000000 003004 000028 01  MS  0   0  1
  [23] .note.gnu.gold-ve NOTE            00000000 00302c 00001c 00      0   0  4
  [24] .ARM.attributes   ARM_ATTRIBUTES  00000000 003048 00002b 00      0   0  1
  [25] .shstrtab         STRTAB          00000000 003073 0000fe 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</code></pre><p>不足的有两点，一个是<code>TYPE</code>，在<code>elf.h</code>里没有找到其余几种描述，所以在上面的输出中是空的，而下面使用<code>readelf</code>是有输出的</p>
<p>第二个是<code>Flg</code>，从<code>readelf</code>的提示来看，这好像是和上面的权限数字表示有点像，但是我不确定。。。。。。</p>
<h2 id="0x02-">0x02 瞎扯</h2>
<ul>
<li><p>我们常在博客中看到，<code>ELF Header</code>结构在最前面，然后跟着<code>Program Header</code>，中间隔着一大片数据，最后是<code>Section Header</code>，其实这个顺序并不是固定的，不过这个顺序倒是比较常见</p>
</li><li><p><code>Program Header</code>和<code>Section Header</code>也被称为段表和节表，关于这两个的区别，引用玩命大牛一句话：段表是给程序看的，节表是给人看的。仔细观察可以发现，段表是指导程序装载该so到内存中的一个指引，比如下面这个，它显示了该so文件的段表，<code>Offset</code>表示的是在文件里的偏移，<code>VirtAddr</code>是映射到内存中的相对地址，因为这里有一个基地址以及相对地址的问题，然后是<code>PhyAddr</code>，这是一个烧到ROM里用的东西，具体我也不是很清楚，<code>FileSiz</code>是在文件里表示这个段的大小，后面的<code>MemSiz</code>是映射到内存里的大小，有的一样有的不一样，<code>Flg</code>指是的是该段的权限，最后一个<code>Align</code>是细粒度，也就是多少字节对齐，这个直接影响前面段的文件偏移和内存偏移，通常内存偏移会大一点，<code>PHDR</code>描述的是段表头，第二个<code>INTERP</code>是一个字符串，表示用于加载该so文件的<code>linker</code>，在下面已经解析出来了，两个<code>LOAD</code>段表示的是要映射的内容，<code>DYNAMIC</code>段是一个数据结构，用于描述整个so文件，其余的一些段有的so文件有，有的没有</p>
<pre><code>Program Headers:
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
PHDR           0x000034 0x00000034 0x00000034 0x00120 0x00120 R   0x4
INTERP         0x000154 0x00000154 0x00000154 0x00013 0x00013 R   0x1
    [Requesting program interpreter: /system/bin/linker]
LOAD           0x000000 0x00000000 0x00000000 0x02450 0x02450 R E 0x1000
LOAD           0x002e78 0x00003e78 0x00003e78 0x0018c 0x0018c RW  0x1000
DYNAMIC        0x002e84 0x00003e84 0x00003e84 0x00138 0x00138 RW  0x4
NOTE           0x000168 0x00000168 0x00000168 0x00024 0x00024 R   0x4
GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0
EXIDX          0x002338 0x00002338 0x00002338 0x00108 0x00108 R   0x4
GNU_RELRO      0x002e78 0x00003e78 0x00003e78 0x00188 0x00188 RW  0x4
</code></pre></li><li><p>关于节表，我们在静态分析一个so文件的时候是要重点关注的，因为这部分更加的详细的描述了整个so文件，在linker加载so文件的时候，比如4.x版本，不会加载节表，而在7开始，会导入节表进行一些处理，这也限制了一些壳的so节表破坏功能，而且在新版本的安卓系统上各种乱七八糟的限制。。。。。。特别是8，听说。。。。。。</p>
</li><li><p>我们在解析这个样本的节表的时候，会有26个节表，序号是<code>0 - 25</code>，但不是说一定只有26个节表，有几个比较重要的，大家可以在IDA里观察一下</p>
<ul>
<li>.plt：这个要和.got节合起来讲</li><li>.text：程序段，一般我们在IDA里看到的代码都在这个部分</li><li>.rodata：只读段</li><li>.fini_array：卸载的时候会调用的一个数组，里面存储的是函数指针</li><li>.init_array：装载的时候会调用的一个数组，里面存储的是函数指针，比如一些壳会在这里进行一些解密操作</li><li>.got：这个用于函数重定位，跟.plt节一起可以实现一些Hook操作</li><li>.data：全局数据</li><li>.bss：未初始化数据</li><li>.rel.dyn：重定位</li><li>.rel.plt：重定位</li></ul>
</li></ul>
<ul>
<li><p>so文件一般都会有的符号表<code>dynsym</code>，也就是动态符号表，但有的会有两个符号表，多了一个<code>symtab</code>，这两个的区别在于一个是用于程序使用，一个用于我们静态分析，动态符号表只包含导出导入符号，加载器够用就行，符号表多了很多，比如变量以及函数符号，这个是可以去掉的</p>
<pre><code>Symbol table &#39;.dynsym&#39; contains 56 entries:
 Num:    Value  Size Type    Bind   Vis      Ndx Name
   0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
   1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)
   2: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)
   3: 00000da1    24 FUNC    GLOBAL DEFAULT   12 Java_com_wnagzihxain_demo
   4: 0000193c     8 FUNC    WEAK   DEFAULT   12 __aeabi_unwind_cpp_pr1
   5: 00000db9    24 FUNC    GLOBAL DEFAULT   12 Java_com_wnagzihxain_demo
   6: 00004004     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
   7: 00004004     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
   8: 00004004     0 NOTYPE  GLOBAL DEFAULT  ABS _end
   9: 00000000     0 FUNC    WEAK   DEFAULT  UND __gnu_Unwind_Find_exidx@LIBC_N (3)
  10: 00001934     8 FUNC    GLOBAL DEFAULT   12 __aeabi_unwind_cpp_pr0
  11: 00001944     8 FUNC    WEAK   DEFAULT   12 __aeabi_unwind_cpp_pr2
  12: 00001cdc     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Restore_VFP_
  13: 00001ccc     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Restore_VFP
  14: 00001cec     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Restore_VFP_
  15: 00001cfc     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Restore_WMMX
  16: 00001d84     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Restore_WMMX
  17: 00000000     0 FUNC    GLOBAL DEFAULT  UND abort@LIBC (2)
  18: 00001cb8    20 FUNC    GLOBAL DEFAULT   12 restore_core_regs
  19: 00000000     0 FUNC    GLOBAL DEFAULT  UND memcpy@LIBC (2)
  20: 000011f8     8 FUNC    GLOBAL DEFAULT   12 _Unwind_GetCFA
  21: 00001200   164 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_RaiseExcepti
  22: 000012a4    28 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_ForcedUnwind
  23: 000012c0   116 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Resume
  24: 00001334    32 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Resume_or_Re
  25: 00001354     4 FUNC    GLOBAL DEFAULT   12 _Unwind_Complete
  26: 00001358    24 FUNC    GLOBAL DEFAULT   12 _Unwind_DeleteException
  27: 00001370    92 FUNC    GLOBAL DEFAULT   12 _Unwind_VRS_Get
  28: 000013f4    92 FUNC    GLOBAL DEFAULT   12 _Unwind_VRS_Set
  29: 0000147c   200 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Backtrace
  30: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __cxa_begin_cleanup
  31: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __cxa_type_match
  32: 00001eec   904 FUNC    GLOBAL DEFAULT   12 __gnu_unwind_execute
  33: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __cxa_call_unexpected
  34: 0000194c   876 FUNC    GLOBAL DEFAULT   12 _Unwind_VRS_Pop
  35: 00001ce4     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Save_VFP_D
  36: 00001cd4     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Save_VFP
  37: 00001cf4     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Save_VFP_D_1
  38: 00001d40     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Save_WMMXD
  39: 00001d98     0 FUNC    GLOBAL DEFAULT   12 __gnu_Unwind_Save_WMMXC
  40: 00001cb8    20 FUNC    GLOBAL DEFAULT   12 __restore_core_regs
  41: 00001dac    36 FUNC    GLOBAL DEFAULT   12 ___Unwind_RaiseException
  42: 00001dac    36 FUNC    GLOBAL DEFAULT   12 _Unwind_RaiseException
  43: 00001dd0    36 FUNC    GLOBAL DEFAULT   12 ___Unwind_Resume
  44: 00001dd0    36 FUNC    GLOBAL DEFAULT   12 _Unwind_Resume
  45: 00001df4    36 FUNC    GLOBAL DEFAULT   12 ___Unwind_Resume_or_Rethr
  46: 00001df4    36 FUNC    GLOBAL DEFAULT   12 _Unwind_Resume_or_Rethrow
  47: 00001e18    36 FUNC    GLOBAL DEFAULT   12 ___Unwind_ForcedUnwind
  48: 00001e18    36 FUNC    GLOBAL DEFAULT   12 _Unwind_ForcedUnwind
  49: 00001e3c    36 FUNC    GLOBAL DEFAULT   12 ___Unwind_Backtrace
  50: 00001e3c    36 FUNC    GLOBAL DEFAULT   12 _Unwind_Backtrace
  51: 00002274    64 FUNC    GLOBAL DEFAULT   12 __gnu_unwind_frame
  52: 000022b4    16 FUNC    GLOBAL DEFAULT   12 _Unwind_GetRegionStart
  53: 000022c4    28 FUNC    GLOBAL DEFAULT   12 _Unwind_GetLanguageSpecif
  54: 000022e0     8 FUNC    GLOBAL DEFAULT   12 _Unwind_GetDataRelBase
  55: 000022e8     8 FUNC    GLOBAL DEFAULT   12 _Unwind_GetTextRelBase
</code></pre></li><li><p>.hash节用于快速查找符号，如果要修改符号的话要牵扯到这里，还有其它地方，也是蛮麻烦的</p>
</li><li><p>.got和.plt两个节是很有意思的，这里简单介绍一下，具体的会单独写一篇跟Linux Pwn相关的文章来描述，首先.got节里面就是各种地址，比如32位的就是4字节，然后会跳转到.plt节，.plt节其实是各种代码，它会动态修改PC指针，最终指向要调用的函数地址</p>
</li><li><p>.rel.dyn和.rel.plt两个节用于重定位，有待研究，可以玩的很猥琐</p>
</li></ul>
<pre><code>readelf -r libtotoc.so
 elocation section &#39;.rel.dyn&#39; at offset 0x13b4 contains 19 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00004dd0  00000017 R_ARM_RELATIVE
00004dd8  00000017 R_ARM_RELATIVE
00004ddc  00000017 R_ARM_RELATIVE
00004f20  00000017 R_ARM_RELATIVE
00004f24  00000017 R_ARM_RELATIVE
00004f28  00000017 R_ARM_RELATIVE
00004f2c  00000017 R_ARM_RELATIVE
00004f30  00000017 R_ARM_RELATIVE
00004f38  00000017 R_ARM_RELATIVE
00004f3c  00000017 R_ARM_RELATIVE
00005004  00000017 R_ARM_RELATIVE
00005008  00000017 R_ARM_RELATIVE
0000500c  00000017 R_ARM_RELATIVE
00005010  00000017 R_ARM_RELATIVE
00005014  00000017 R_ARM_RELATIVE
00005018  00000017 R_ARM_RELATIVE
00004f1c  00000b15 R_ARM_GLOB_DAT    00000000   __stack_chk_guard
00004f34  00003a15 R_ARM_GLOB_DAT    00000000   __gnu_Unwind_Find_exid
00004f40  00005015 R_ARM_GLOB_DAT    00000000   __cxa_call_unexpected

Relocation section &#39;.rel.plt&#39; at offset 0x144c contains 44 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00004f50  00000216 R_ARM_JUMP_SLOT   00000000   __cxa_atexit
00004f54  00000116 R_ARM_JUMP_SLOT   00000000   __cxa_finalize
00004f58  00000416 R_ARM_JUMP_SLOT   00000000   memset
00004f5c  00000516 R_ARM_JUMP_SLOT   00000000   fopen
00004f60  00000616 R_ARM_JUMP_SLOT   00000000   fgets
00004f64  00000716 R_ARM_JUMP_SLOT   00000000   strstr
00004f68  00000816 R_ARM_JUMP_SLOT   00000000   kill
00004f6c  00000916 R_ARM_JUMP_SLOT   00000000   fclose
00004f70  00000a16 R_ARM_JUMP_SLOT   00000000   __stack_chk_fail
00004f74  00000e16 R_ARM_JUMP_SLOT   00000000   syscall
00004f78  00000f16 R_ARM_JUMP_SLOT   00000000   sprintf
00004f7c  00001016 R_ARM_JUMP_SLOT   00000000   fork
00004f80  00001116 R_ARM_JUMP_SLOT   00000000   ptrace
00004f84  00001216 R_ARM_JUMP_SLOT   00000000   exit
00004f88  00001316 R_ARM_JUMP_SLOT   00000000   strncmp
00004f8c  00001416 R_ARM_JUMP_SLOT   00000000   sleep
00004f90  00001516 R_ARM_JUMP_SLOT   00000000   atoi
00004f94  00001916 R_ARM_JUMP_SLOT   00000000   pthread_create
00004f98  00001a16 R_ARM_JUMP_SLOT   00000000   pthread_detach
00004f9c  00001c16 R_ARM_JUMP_SLOT   00000000   read
00004fa0  00001d16 R_ARM_JUMP_SLOT   00000000   getpid
00004fa4  00001f16 R_ARM_JUMP_SLOT   00000000   select
00004fa8  00002216 R_ARM_JUMP_SLOT   00000000   inotify_init
00004fac  00002316 R_ARM_JUMP_SLOT   00000000   inotify_add_watch
00004fb0  00002616 R_ARM_JUMP_SLOT   00000000   AAssetManager_fromJava
00004fb4  00002716 R_ARM_JUMP_SLOT   00000000   AAssetManager_open
00004fb8  00002816 R_ARM_JUMP_SLOT   00000000   AAsset_getLength
00004fbc  00002916 R_ARM_JUMP_SLOT   00000000   malloc
00004fc0  00002a16 R_ARM_JUMP_SLOT   00000000   AAsset_read
00004fc4  00002b16 R_ARM_JUMP_SLOT   00000000   mkdir
00004fc8  00002c16 R_ARM_JUMP_SLOT   00000000   open
00004fcc  00002d16 R_ARM_JUMP_SLOT   00000000   lseek
00004fd0  00002e16 R_ARM_JUMP_SLOT   00000000   write
00004fd4  00002f16 R_ARM_JUMP_SLOT   00000000   close
00004fd8  00003016 R_ARM_JUMP_SLOT   00000000   free
00004fdc  00003116 R_ARM_JUMP_SLOT   00000000   remove
00004fe0  00003216 R_ARM_JUMP_SLOT   00000000   AAsset_close
00004fe4  00003316 R_ARM_JUMP_SLOT   00000000   __android_log_print
00004fe8  00003416 R_ARM_JUMP_SLOT   00000000   access
00004fec  00003a16 R_ARM_JUMP_SLOT   00000000   __gnu_Unwind_Find_exid
00004ff0  00004016 R_ARM_JUMP_SLOT   00000000   abort
00004ff4  00004216 R_ARM_JUMP_SLOT   00000000   memcpy
00004ff8  00004d16 R_ARM_JUMP_SLOT   00000000   __cxa_begin_cleanup
00004ffc  00004e16 R_ARM_JUMP_SLOT   00000000   __cxa_type_match
</code></pre><ul>
<li>.dynamic节是在加载过程中使用</li></ul>
<pre><code>Dynamic section at offset 0x3de4 contains 34 entries:
  Tag        Type                         Name/Value
 0x00000003 (PLTGOT)                     0x4f44
 0x00000002 (PLTRELSZ)                   352 (bytes)
 0x00000017 (JMPREL)                     0x144c
 0x00000014 (PLTREL)                     REL
 0x00000011 (REL)                        0x13b4
 0x00000012 (RELSZ)                      152 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffa (RELCOUNT)                   16
 0x00000006 (SYMTAB)                     0x18c
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000005 (STRTAB)                     0x7fc
 0x0000000a (STRSZ)                      1922 (bytes)
 0x00000004 (HASH)                       0xf80
 0x00000001 (NEEDED)                     Shared library: [liblog.so]
 0x00000001 (NEEDED)                     Shared library: [libz.so]
 0x00000001 (NEEDED)                     Shared library: [libandroid.so]
 0x00000001 (NEEDED)                     Shared library: [libstdc++.so]
 0x00000001 (NEEDED)                     Shared library: [libm.so]
 0x00000001 (NEEDED)                     Shared library: [libc.so]
 0x00000001 (NEEDED)                     Shared library: [libdl.so]
 0x0000000e (SONAME)                     Library soname: [libtotoc.so]
 0x0000001a (FINI_ARRAY)                 0x4dd0
 0x0000001c (FINI_ARRAYSZ)               8 (bytes)
 0x00000019 (INIT_ARRAY)                 0x4dd8
 0x0000001b (INIT_ARRAYSZ)               12 (bytes)
 0x00000010 (SYMBOLIC)                   0x0
 0x0000001e (FLAGS)                      SYMBOLIC BIND_NOW
 0x6ffffffb (FLAGS_1)                    Flags: NOW
 0x6ffffff0 (VERSYM)                     0x12a8
 0x6ffffffc (VERDEF)                     0x1378
 0x6ffffffd (VERDEFNUM)                  1
 0x6ffffffe (VERNEED)                    0x1394
 0x6fffffff (VERNEEDNUM)                 1
 0x00000000 (NULL)                       0x0
</code></pre><p><strong>以上这些都是根据玩命大牛在硬创公开课讲的《玩命-Android原生保护壳的原理与实现》课程的一点点总结，课程质量和PPT质量都很高，确确实实的涨姿势，不过中间有部分终端挡住了PPT，大家可以结合放出来的PPT学习，视频在雷锋网上有，建议先学习ELF格式，然后再去学习会有一种全程涨姿势的感觉</strong></p>
<h2 id="0x03-">0x03 小结</h2>
<p>本来只是写了一些解析的过程，对ELF的理解除了文件的格式之外，还需要结合linker的源码进行分析，刚好昨晚玩命大牛分享了一波相关的知识，于是今天就结合着昨天学到的知识给加了点总结，我想：实现一个自己的类抽取器应该是大部分搞脱壳的同学一个小小的梦想吧？</p>
<p><strong>听大牛讲课就是涨姿势</strong></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
